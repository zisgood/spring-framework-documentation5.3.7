<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Core Technologies</title>
<style>
@import 'css/spring.css';

.listingblock .switch {
border-style: none;
display: inline-block;
position: relative;
bottom: -3px;
}

.listingblock .switch--item {
padding: 10px;
background-color: #e6e1dc;
color: #282c34;
display: inline-block;
cursor: pointer;
border-top-left-radius: 4px;
border-top-right-radius: 4px;
}

.listingblock .switch--item:not(:first-child) {
border-style: none;
}

.listingblock .switch--item.selected {
background-color: #282c34;
color: #e6e1dc;
}

.listingblock pre.highlightjs {
padding: 0;
}
.translate {
#	display: none;
#	font-size: small;
#	color: #090;
color: #6db33f;
}

div p + div {
margin-top: -20px;
}

div p {
#    display: none;
}
</style>
<link rel="stylesheet" href="css/cloudflare/font-awesome.min.css">
<link rel="stylesheet" href="css/translate.css">
<link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon">
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="js/cloudflare/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

function globalSwitch() {
	$('.switch--item').each(function() {
		var blockId = blockIdForSwitchItem($(this));
		$(this).off('click');
		$(this).on('click', function() {
			selectedText = $(this).text()
			window.localStorage.setItem(blockId, selectedText);
			$(".switch--item").filter(function() {
				return blockIdForSwitchItem($(this)) === blockId;
			}).filter(function() {
				return $(this).text() === selectedText;
			}).each(function() {
				select($(this))
			});
		});
		if ($(this).text() === window.localStorage.getItem(blockId)) {
			select($(this))
		}
	});
}

function blockIdForSwitchItem(item) {
	idComponents = []
	idComponents.push(item.text().toLowerCase());
	item.siblings(".switch--item").each(function(index, sibling) {
		idComponents.push($(sibling).text().toLowerCase());
	});
	return idComponents.sort().join("-")
}

function select(selected) {
	selected.addClass('selected');
	selected.siblings().removeClass('selected');
	selectedContent = selected.parent().siblings(".content").eq(selected.index())
	selectedContent.removeClass('hidden');
	selectedContent.siblings().addClass('hidden');
}

$(addBlockSwitches);
$(globalSwitch);

</script>
</head>
<body id="spring-core" class="book toc2 toc-left">
<div id="header">
<h1>Core Technologies<div class="translate">核心技术</div></h1>
<div class="details">
<span id="revnumber">version 5.3.7</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#beans">1. The IoC Container</a>
<ul class="sectlevel2">
<li><a href="#beans-introduction">1.1. Introduction to the Spring IoC Container and Beans</a></li>
<li><a href="#beans-basics">1.2. Container Overview</a>
<ul class="sectlevel3">
<li><a href="#beans-factory-metadata">1.2.1. Configuration Metadata</a></li>
<li><a href="#beans-factory-instantiation">1.2.2. Instantiating a Container</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-xml-import">Composing XML-based Configuration Metadata</a></li>
<li><a href="#groovy-bean-definition-dsl">The Groovy Bean Definition DSL</a></li>
</ul>
</li>
<li><a href="#beans-factory-client">1.2.3. Using the Container</a></li>
</ul>
</li>
<li><a href="#beans-definition">1.3. Bean Overview</a>
<ul class="sectlevel3">
<li><a href="#beans-beanname">1.3.1. Naming Beans</a>
<ul class="sectlevel4">
<li><a href="#beans-beanname-alias">Aliasing a Bean outside the Bean Definition</a></li>
</ul>
</li>
<li><a href="#beans-factory-class">1.3.2. Instantiating Beans</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-class-ctor">Instantiation with a Constructor</a></li>
<li><a href="#beans-factory-class-static-factory-method">Instantiation with a Static Factory Method</a></li>
<li><a href="#beans-factory-class-instance-factory-method">Instantiation by Using an Instance Factory Method</a></li>
<li><a href="#beans-factory-type-determination">Determining a Bean&#8217;s Runtime Type</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#beans-dependencies">1.4. Dependencies</a>
<ul class="sectlevel3">
<li><a href="#beans-factory-collaborators">1.4.1. Dependency Injection</a>
<ul class="sectlevel4">
<li><a href="#beans-constructor-injection">Constructor-based Dependency Injection</a></li>
<li><a href="#beans-setter-injection">Setter-based Dependency Injection</a></li>
<li><a href="#beans-dependency-resolution">Dependency Resolution Process</a></li>
<li><a href="#beans-some-examples">Examples of Dependency Injection</a></li>
</ul>
</li>
<li><a href="#beans-factory-properties-detailed">1.4.2. Dependencies and Configuration in Detail</a>
<ul class="sectlevel4">
<li><a href="#beans-value-element">Straight Values (Primitives, Strings, and so on)</a></li>
<li><a href="#beans-ref-element">References to Other Beans (Collaborators)</a></li>
<li><a href="#beans-inner-beans">Inner Beans</a></li>
<li><a href="#beans-collection-elements">Collections</a></li>
<li><a href="#beans-null-element">Null and Empty String Values</a></li>
<li><a href="#beans-p-namespace">XML Shortcut with the p-namespace</a></li>
<li><a href="#beans-c-namespace">XML Shortcut with the c-namespace</a></li>
<li><a href="#beans-compound-property-names">Compound Property Names</a></li>
</ul>
</li>
<li><a href="#beans-factory-dependson">1.4.3. Using <code>depends-on</code></a></li>
<li><a href="#beans-factory-lazy-init">1.4.4. Lazy-initialized Beans</a></li>
<li><a href="#beans-factory-autowire">1.4.5. Autowiring Collaborators</a>
<ul class="sectlevel4">
<li><a href="#beans-autowired-exceptions">Limitations and Disadvantages of Autowiring</a></li>
<li><a href="#beans-factory-autowire-candidate">Excluding a Bean from Autowiring</a></li>
</ul>
</li>
<li><a href="#beans-factory-method-injection">1.4.6. Method Injection</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-lookup-method-injection">Lookup Method Injection</a></li>
<li><a href="#beans-factory-arbitrary-method-replacement">Arbitrary Method Replacement</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#beans-factory-scopes">1.5. Bean Scopes</a>
<ul class="sectlevel3">
<li><a href="#beans-factory-scopes-singleton">1.5.1. The Singleton Scope</a></li>
<li><a href="#beans-factory-scopes-prototype">1.5.2. The Prototype Scope</a></li>
<li><a href="#beans-factory-scopes-sing-prot-interaction">1.5.3. Singleton Beans with Prototype-bean Dependencies</a></li>
<li><a href="#beans-factory-scopes-other">1.5.4. Request, Session, Application, and WebSocket Scopes</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-scopes-other-web-configuration">Initial Web Configuration</a></li>
<li><a href="#beans-factory-scopes-request">Request scope</a></li>
<li><a href="#beans-factory-scopes-session">Session Scope</a></li>
<li><a href="#beans-factory-scopes-application">Application Scope</a></li>
<li><a href="#beans-factory-scopes-other-injection">Scoped Beans as Dependencies</a></li>
</ul>
</li>
<li><a href="#beans-factory-scopes-custom">1.5.5. Custom Scopes</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-scopes-custom-creating">Creating a Custom Scope</a></li>
<li><a href="#beans-factory-scopes-custom-using">Using a Custom Scope</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#beans-factory-nature">1.6. Customizing the Nature of a Bean</a>
<ul class="sectlevel3">
<li><a href="#beans-factory-lifecycle">1.6.1. Lifecycle Callbacks</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-lifecycle-initializingbean">Initialization Callbacks</a></li>
<li><a href="#beans-factory-lifecycle-disposablebean">Destruction Callbacks</a></li>
<li><a href="#beans-factory-lifecycle-default-init-destroy-methods">Default Initialization and Destroy Methods</a></li>
<li><a href="#beans-factory-lifecycle-combined-effects">Combining Lifecycle Mechanisms</a></li>
<li><a href="#beans-factory-lifecycle-processor">Startup and Shutdown Callbacks</a></li>
<li><a href="#beans-factory-shutdown">Shutting Down the Spring IoC Container Gracefully in Non-Web Applications</a></li>
</ul>
</li>
<li><a href="#beans-factory-aware">1.6.2. <code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></li>
<li><a href="#aware-list">1.6.3. Other <code>Aware</code> Interfaces</a></li>
</ul>
</li>
<li><a href="#beans-child-bean-definitions">1.7. Bean Definition Inheritance</a></li>
<li><a href="#beans-factory-extension">1.8. Container Extension Points</a>
<ul class="sectlevel3">
<li><a href="#beans-factory-extension-bpp">1.8.1. Customizing Beans by Using a <code>BeanPostProcessor</code></a>
<ul class="sectlevel4">
<li><a href="#beans-factory-extension-bpp-examples-hw">Example: Hello World, <code>BeanPostProcessor</code>-style</a></li>
<li><a href="#beans-factory-extension-bpp-examples-aabpp">Example: The <code>AutowiredAnnotationBeanPostProcessor</code></a></li>
</ul>
</li>
<li><a href="#beans-factory-extension-factory-postprocessors">1.8.2. Customizing Configuration Metadata with a <code>BeanFactoryPostProcessor</code></a>
<ul class="sectlevel4">
<li><a href="#beans-factory-placeholderconfigurer">Example: The Class Name Substitution <code>PropertySourcesPlaceholderConfigurer</code></a></li>
<li><a href="#beans-factory-overrideconfigurer">Example: The <code>PropertyOverrideConfigurer</code></a></li>
</ul>
</li>
<li><a href="#beans-factory-extension-factorybean">1.8.3. Customizing Instantiation Logic with a <code>FactoryBean</code></a></li>
</ul>
</li>
<li><a href="#beans-annotation-config">1.9. Annotation-based Container Configuration</a>
<ul class="sectlevel3">
<li><a href="#beans-required-annotation">1.9.1. @Required</a></li>
<li><a href="#beans-autowired-annotation">1.9.2. Using <code>@Autowired</code></a></li>
<li><a href="#beans-autowired-annotation-primary">1.9.3. Fine-tuning Annotation-based Autowiring with <code>@Primary</code></a></li>
<li><a href="#beans-autowired-annotation-qualifiers">1.9.4. Fine-tuning Annotation-based Autowiring with Qualifiers</a></li>
<li><a href="#beans-generics-as-qualifiers">1.9.5. Using Generics as Autowiring Qualifiers</a></li>
<li><a href="#beans-custom-autowire-configurer">1.9.6. Using <code>CustomAutowireConfigurer</code></a></li>
<li><a href="#beans-resource-annotation">1.9.7. Injection with <code>@Resource</code></a></li>
<li><a href="#beans-value-annotations">1.9.8. Using <code>@Value</code></a></li>
<li><a href="#beans-postconstruct-and-predestroy-annotations">1.9.9. Using <code>@PostConstruct</code> and <code>@PreDestroy</code></a></li>
</ul>
</li>
<li><a href="#beans-classpath-scanning">1.10. Classpath Scanning and Managed Components</a>
<ul class="sectlevel3">
<li><a href="#beans-stereotype-annotations">1.10.1. <code>@Component</code> and Further Stereotype Annotations</a></li>
<li><a href="#beans-meta-annotations">1.10.2. Using Meta-annotations and Composed Annotations</a></li>
<li><a href="#beans-scanning-autodetection">1.10.3. Automatically Detecting Classes and Registering Bean Definitions</a></li>
<li><a href="#beans-scanning-filters">1.10.4. Using Filters to Customize Scanning</a></li>
<li><a href="#beans-factorybeans-annotations">1.10.5. Defining Bean Metadata within Components</a></li>
<li><a href="#beans-scanning-name-generator">1.10.6. Naming Autodetected Components</a></li>
<li><a href="#beans-scanning-scope-resolver">1.10.7. Providing a Scope for Autodetected Components</a></li>
<li><a href="#beans-scanning-qualifiers">1.10.8. Providing Qualifier Metadata with Annotations</a></li>
<li><a href="#beans-scanning-index">1.10.9. Generating an Index of Candidate Components</a></li>
</ul>
</li>
<li><a href="#beans-standard-annotations">1.11. Using JSR 330 Standard Annotations</a>
<ul class="sectlevel3">
<li><a href="#beans-inject-named">1.11.1. Dependency Injection with <code>@Inject</code> and <code>@Named</code></a></li>
<li><a href="#beans-named">1.11.2. <code>@Named</code> and <code>@ManagedBean</code>: Standard Equivalents to the <code>@Component</code> Annotation</a></li>
<li><a href="#beans-standard-annotations-limitations">1.11.3. Limitations of JSR-330 Standard Annotations</a></li>
</ul>
</li>
<li><a href="#beans-java">1.12. Java-based Container Configuration</a>
<ul class="sectlevel3">
<li><a href="#beans-java-basic-concepts">1.12.1. Basic Concepts: <code>@Bean</code> and <code>@Configuration</code></a></li>
<li><a href="#beans-java-instantiating-container">1.12.2. Instantiating the Spring Container by Using <code>AnnotationConfigApplicationContext</code></a>
<ul class="sectlevel4">
<li><a href="#beans-java-instantiating-container-constructor">Simple Construction</a></li>
<li><a href="#beans-java-instantiating-container-register">Building the Container Programmatically by Using <code>register(Class&lt;?&gt;&#8230;&#8203;)</code></a></li>
<li><a href="#beans-java-instantiating-container-scan">Enabling Component Scanning with <code>scan(String&#8230;&#8203;)</code></a></li>
<li><a href="#beans-java-instantiating-container-web">Support for Web Applications with <code>AnnotationConfigWebApplicationContext</code></a></li>
</ul>
</li>
<li><a href="#beans-java-bean-annotation">1.12.3. Using the <code>@Bean</code> Annotation</a>
<ul class="sectlevel4">
<li><a href="#beans-java-declaring-a-bean">Declaring a Bean</a></li>
<li><a href="#beans-java-dependencies">Bean Dependencies</a></li>
<li><a href="#beans-java-lifecycle-callbacks">Receiving Lifecycle Callbacks</a></li>
<li><a href="#beans-java-specifying-bean-scope">Specifying Bean Scope</a></li>
<li><a href="#beans-java-customizing-bean-naming">Customizing Bean Naming</a></li>
<li><a href="#beans-java-bean-aliasing">Bean Aliasing</a></li>
<li><a href="#beans-java-bean-description">Bean Description</a></li>
</ul>
</li>
<li><a href="#beans-java-configuration-annotation">1.12.4. Using the <code>@Configuration</code> annotation</a>
<ul class="sectlevel4">
<li><a href="#beans-java-injecting-dependencies">Injecting Inter-bean Dependencies</a></li>
<li><a href="#beans-java-method-injection">Lookup Method Injection</a></li>
<li><a href="#beans-java-further-information-java-config">Further Information About How Java-based Configuration Works Internally</a></li>
</ul>
</li>
<li><a href="#beans-java-composing-configuration-classes">1.12.5. Composing Java-based Configurations</a>
<ul class="sectlevel4">
<li><a href="#beans-java-using-import">Using the <code>@Import</code> Annotation</a></li>
<li><a href="#beans-java-conditional">Conditionally Include <code>@Configuration</code> Classes or <code>@Bean</code> Methods</a></li>
<li><a href="#beans-java-combining">Combining Java and XML Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#beans-environment">1.13. Environment Abstraction</a>
<ul class="sectlevel3">
<li><a href="#beans-definition-profiles">1.13.1. Bean Definition Profiles</a>
<ul class="sectlevel4">
<li><a href="#beans-definition-profiles-java">Using <code>@Profile</code></a></li>
<li><a href="#beans-definition-profiles-xml">XML Bean Definition Profiles</a></li>
<li><a href="#beans-definition-profiles-enable">Activating a Profile</a></li>
<li><a href="#beans-definition-profiles-default">Default Profile</a></li>
</ul>
</li>
<li><a href="#beans-property-source-abstraction">1.13.2. <code>PropertySource</code> Abstraction</a></li>
<li><a href="#beans-using-propertysource">1.13.3. Using <code>@PropertySource</code></a></li>
<li><a href="#beans-placeholder-resolution-in-statements">1.13.4. Placeholder Resolution in Statements</a></li>
</ul>
</li>
<li><a href="#context-load-time-weaver">1.14. Registering a <code>LoadTimeWeaver</code></a></li>
<li><a href="#context-introduction">1.15. Additional Capabilities of the <code>ApplicationContext</code></a>
<ul class="sectlevel3">
<li><a href="#context-functionality-messagesource">1.15.1. Internationalization using <code>MessageSource</code></a></li>
<li><a href="#context-functionality-events">1.15.2. Standard and Custom Events</a>
<ul class="sectlevel4">
<li><a href="#context-functionality-events-annotation">Annotation-based Event Listeners</a></li>
<li><a href="#context-functionality-events-async">Asynchronous Listeners</a></li>
<li><a href="#context-functionality-events-order">Ordering Listeners</a></li>
<li><a href="#context-functionality-events-generics">Generic Events</a></li>
</ul>
</li>
<li><a href="#context-functionality-resources">1.15.3. Convenient Access to Low-level Resources</a></li>
<li><a href="#context-functionality-startup">1.15.4. Application Startup Tracking</a></li>
<li><a href="#context-create">1.15.5. Convenient ApplicationContext Instantiation for Web Applications</a></li>
<li><a href="#context-deploy-rar">1.15.6. Deploying a Spring <code>ApplicationContext</code> as a Java EE RAR File</a></li>
</ul>
</li>
<li><a href="#beans-beanfactory">1.16. The <code>BeanFactory</code></a>
<ul class="sectlevel3">
<li><a href="#context-introduction-ctx-vs-beanfactory">1.16.1. <code>BeanFactory</code> or <code>ApplicationContext</code>?</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#resources">2. Resources</a>
<ul class="sectlevel2">
<li><a href="#resources-introduction">2.1. Introduction</a></li>
<li><a href="#resources-resource">2.2. The <code>Resource</code> Interface</a></li>
<li><a href="#resources-implementations">2.3. Built-in <code>Resource</code> Implementations</a>
<ul class="sectlevel3">
<li><a href="#resources-implementations-urlresource">2.3.1. <code>UrlResource</code></a></li>
<li><a href="#resources-implementations-classpathresource">2.3.2. <code>ClassPathResource</code></a></li>
<li><a href="#resources-implementations-filesystemresource">2.3.3. <code>FileSystemResource</code></a></li>
<li><a href="#resources-implementations-pathresource">2.3.4. <code>PathResource</code></a></li>
<li><a href="#resources-implementations-servletcontextresource">2.3.5. <code>ServletContextResource</code></a></li>
<li><a href="#resources-implementations-inputstreamresource">2.3.6. <code>InputStreamResource</code></a></li>
<li><a href="#resources-implementations-bytearrayresource">2.3.7. <code>ByteArrayResource</code></a></li>
</ul>
</li>
<li><a href="#resources-resourceloader">2.4. The <code>ResourceLoader</code> Interface</a></li>
<li><a href="#resources-resourcepatternresolver">2.5. The <code>ResourcePatternResolver</code> Interface</a></li>
<li><a href="#resources-resourceloaderaware">2.6. The <code>ResourceLoaderAware</code> Interface</a></li>
<li><a href="#resources-as-dependencies">2.7. Resources as Dependencies</a></li>
<li><a href="#resources-app-ctx">2.8. Application Contexts and Resource Paths</a>
<ul class="sectlevel3">
<li><a href="#resources-app-ctx-construction">2.8.1. Constructing Application Contexts</a>
<ul class="sectlevel4">
<li><a href="#resources-app-ctx-classpathxml">Constructing <code>ClassPathXmlApplicationContext</code> Instances&#8201;&#8212;&#8201;Shortcuts</a></li>
</ul>
</li>
<li><a href="#resources-app-ctx-wildcards-in-resource-paths">2.8.2. Wildcards in Application Context Constructor Resource Paths</a>
<ul class="sectlevel4">
<li><a href="#resources-app-ctx-ant-patterns-in-paths">Ant-style Patterns</a></li>
<li><a href="#resources-classpath-wildcards">The <code>classpath*:</code> Prefix</a></li>
<li><a href="#resources-wildcards-in-path-other-stuff">Other Notes Relating to Wildcards</a></li>
</ul>
</li>
<li><a href="#resources-filesystemresource-caveats">2.8.3. <code>FileSystemResource</code> Caveats</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#validation">3. Validation, Data Binding, and Type Conversion</a>
<ul class="sectlevel2">
<li><a href="#validator">3.1. Validation by Using Spring&#8217;s Validator Interface</a></li>
<li><a href="#validation-conversion">3.2. Resolving Codes to Error Messages</a></li>
<li><a href="#beans-beans">3.3. Bean Manipulation and the <code>BeanWrapper</code></a>
<ul class="sectlevel3">
<li><a href="#beans-beans-conventions">3.3.1. Setting and Getting Basic and Nested Properties</a></li>
<li><a href="#beans-beans-conversion">3.3.2. Built-in <code>PropertyEditor</code> Implementations</a>
<ul class="sectlevel4">
<li><a href="#beans-beans-conversion-customeditor-registration">Registering Additional Custom <code>PropertyEditor</code> Implementations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#core-convert">3.4. Spring Type Conversion</a>
<ul class="sectlevel3">
<li><a href="#core-convert-Converter-API">3.4.1. Converter SPI</a></li>
<li><a href="#core-convert-ConverterFactory-SPI">3.4.2. Using <code>ConverterFactory</code></a></li>
<li><a href="#core-convert-GenericConverter-SPI">3.4.3. Using <code>GenericConverter</code></a>
<ul class="sectlevel4">
<li><a href="#core-convert-ConditionalGenericConverter-SPI">Using <code>ConditionalGenericConverter</code></a></li>
</ul>
</li>
<li><a href="#core-convert-ConversionService-API">3.4.4. The <code>ConversionService</code> API</a></li>
<li><a href="#core-convert-Spring-config">3.4.5. Configuring a <code>ConversionService</code></a></li>
<li><a href="#core-convert-programmatic-usage">3.4.6. Using a <code>ConversionService</code> Programmatically</a></li>
</ul>
</li>
<li><a href="#format">3.5. Spring Field Formatting</a>
<ul class="sectlevel3">
<li><a href="#format-Formatter-SPI">3.5.1. The <code>Formatter</code> SPI</a></li>
<li><a href="#format-CustomFormatAnnotations">3.5.2. Annotation-driven Formatting</a>
<ul class="sectlevel4">
<li><a href="#format-annotations-api">Format Annotation API</a></li>
</ul>
</li>
<li><a href="#format-FormatterRegistry-SPI">3.5.3. The <code>FormatterRegistry</code> SPI</a></li>
<li><a href="#format-FormatterRegistrar-SPI">3.5.4. The <code>FormatterRegistrar</code> SPI</a></li>
<li><a href="#format-configuring-formatting-mvc">3.5.5. Configuring Formatting in Spring MVC</a></li>
</ul>
</li>
<li><a href="#format-configuring-formatting-globaldatetimeformat">3.6. Configuring a Global Date and Time Format</a></li>
<li><a href="#validation-beanvalidation">3.7. Java Bean Validation</a>
<ul class="sectlevel3">
<li><a href="#validation-beanvalidation-overview">3.7.1. Overview of Bean Validation</a></li>
<li><a href="#validation-beanvalidation-spring">3.7.2. Configuring a Bean Validation Provider</a>
<ul class="sectlevel4">
<li><a href="#validation-beanvalidation-spring-inject">Injecting a Validator</a></li>
<li><a href="#validation-beanvalidation-spring-constraints">Configuring Custom Constraints</a></li>
<li><a href="#validation-beanvalidation-spring-method">Spring-driven Method Validation</a></li>
<li><a href="#validation-beanvalidation-spring-other">Additional Configuration Options</a></li>
</ul>
</li>
<li><a href="#validation-binder">3.7.3. Configuring a <code>DataBinder</code></a></li>
<li><a href="#validation-mvc">3.7.4. Spring MVC 3 Validation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#expressions">4. Spring Expression Language (SpEL)</a>
<ul class="sectlevel2">
<li><a href="#expressions-evaluation">4.1. Evaluation</a>
<ul class="sectlevel3">
<li><a href="#expressions-evaluation-context">4.1.1. Understanding <code>EvaluationContext</code></a>
<ul class="sectlevel4">
<li><a href="#expressions-type-conversion">Type Conversion</a></li>
</ul>
</li>
<li><a href="#expressions-parser-configuration">4.1.2. Parser Configuration</a></li>
<li><a href="#expressions-spel-compilation">4.1.3. SpEL Compilation</a>
<ul class="sectlevel4">
<li><a href="#expressions-compiler-configuration">Compiler Configuration</a></li>
<li><a href="#expressions-compiler-limitations">Compiler Limitations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#expressions-beandef">4.2. Expressions in Bean Definitions</a>
<ul class="sectlevel3">
<li><a href="#expressions-beandef-xml-based">4.2.1. XML Configuration</a></li>
<li><a href="#expressions-beandef-annotation-based">4.2.2. Annotation Configuration</a></li>
</ul>
</li>
<li><a href="#expressions-language-ref">4.3. Language Reference</a>
<ul class="sectlevel3">
<li><a href="#expressions-ref-literal">4.3.1. Literal Expressions</a></li>
<li><a href="#expressions-properties-arrays">4.3.2. Properties, Arrays, Lists, Maps, and Indexers</a></li>
<li><a href="#expressions-inline-lists">4.3.3. Inline Lists</a></li>
<li><a href="#expressions-inline-maps">4.3.4. Inline Maps</a></li>
<li><a href="#expressions-array-construction">4.3.5. Array Construction</a></li>
<li><a href="#expressions-methods">4.3.6. Methods</a></li>
<li><a href="#expressions-operators">4.3.7. Operators</a>
<ul class="sectlevel4">
<li><a href="#expressions-operators-relational">Relational Operators</a></li>
<li><a href="#expressions-operators-logical">Logical Operators</a></li>
<li><a href="#expressions-operators-mathematical">Mathematical Operators</a></li>
<li><a href="#expressions-assignment">The Assignment Operator</a></li>
</ul>
</li>
<li><a href="#expressions-types">4.3.8. Types</a></li>
<li><a href="#expressions-constructors">4.3.9. Constructors</a></li>
<li><a href="#expressions-ref-variables">4.3.10. Variables</a>
<ul class="sectlevel4">
<li><a href="#expressions-this-root">The <code>#this</code> and <code>#root</code> Variables</a></li>
</ul>
</li>
<li><a href="#expressions-ref-functions">4.3.11. Functions</a></li>
<li><a href="#expressions-bean-references">4.3.12. Bean References</a></li>
<li><a href="#expressions-operator-ternary">4.3.13. Ternary Operator (If-Then-Else)</a></li>
<li><a href="#expressions-operator-elvis">4.3.14. The Elvis Operator</a></li>
<li><a href="#expressions-operator-safe-navigation">4.3.15. Safe Navigation Operator</a></li>
<li><a href="#expressions-collection-selection">4.3.16. Collection Selection</a></li>
<li><a href="#expressions-collection-projection">4.3.17. Collection Projection</a></li>
<li><a href="#expressions-templating">4.3.18. Expression templating</a></li>
</ul>
</li>
<li><a href="#expressions-example-classes">4.4. Classes Used in the Examples</a></li>
</ul>
</li>
<li><a href="#aop">5. Aspect Oriented Programming with Spring</a>
<ul class="sectlevel2">
<li><a href="#aop-introduction-defn">5.1. AOP Concepts</a></li>
<li><a href="#aop-introduction-spring-defn">5.2. Spring AOP Capabilities and Goals</a></li>
<li><a href="#aop-introduction-proxies">5.3. AOP Proxies</a></li>
<li><a href="#aop-ataspectj">5.4. @AspectJ support</a>
<ul class="sectlevel3">
<li><a href="#aop-aspectj-support">5.4.1. Enabling @AspectJ Support</a>
<ul class="sectlevel4">
<li><a href="#aop-enable-aspectj-java">Enabling @AspectJ Support with Java Configuration</a></li>
<li><a href="#aop-enable-aspectj-xml">Enabling @AspectJ Support with XML Configuration</a></li>
</ul>
</li>
<li><a href="#aop-at-aspectj">5.4.2. Declaring an Aspect</a></li>
<li><a href="#aop-pointcuts">5.4.3. Declaring a Pointcut</a>
<ul class="sectlevel4">
<li><a href="#aop-pointcuts-designators">Supported Pointcut Designators</a></li>
<li><a href="#aop-pointcuts-combining">Combining Pointcut Expressions</a></li>
<li><a href="#aop-common-pointcuts">Sharing Common Pointcut Definitions</a></li>
<li><a href="#aop-pointcuts-examples">Examples</a></li>
<li><a href="#writing-good-pointcuts">Writing Good Pointcuts</a></li>
</ul>
</li>
<li><a href="#aop-advice">5.4.4. Declaring Advice</a>
<ul class="sectlevel4">
<li><a href="#aop-advice-before">Before Advice</a></li>
<li><a href="#aop-advice-after-returning">After Returning Advice</a></li>
<li><a href="#aop-advice-after-throwing">After Throwing Advice</a></li>
<li><a href="#aop-advice-after-finally">After (Finally) Advice</a></li>
<li><a href="#aop-ataspectj-around-advice">Around Advice</a></li>
<li><a href="#aop-ataspectj-advice-params">Advice Parameters</a></li>
<li><a href="#aop-ataspectj-advice-ordering">Advice Ordering</a></li>
</ul>
</li>
<li><a href="#aop-introductions">5.4.5. Introductions</a></li>
<li><a href="#aop-instantiation-models">5.4.6. Aspect Instantiation Models</a></li>
<li><a href="#aop-ataspectj-example">5.4.7. An AOP Example</a></li>
</ul>
</li>
<li><a href="#aop-schema">5.5. Schema-based AOP Support</a>
<ul class="sectlevel3">
<li><a href="#aop-schema-declaring-an-aspect">5.5.1. Declaring an Aspect</a></li>
<li><a href="#aop-schema-pointcuts">5.5.2. Declaring a Pointcut</a></li>
<li><a href="#aop-schema-advice">5.5.3. Declaring Advice</a>
<ul class="sectlevel4">
<li><a href="#aop-schema-advice-before">Before Advice</a></li>
<li><a href="#aop-schema-advice-after-returning">After Returning Advice</a></li>
<li><a href="#aop-schema-advice-after-throwing">After Throwing Advice</a></li>
<li><a href="#aop-schema-advice-after-finally">After (Finally) Advice</a></li>
<li><a href="#aop-schema-advice-around">Around Advice</a></li>
<li><a href="#aop-schema-params">Advice Parameters</a></li>
<li><a href="#aop-ordering">Advice Ordering</a></li>
</ul>
</li>
<li><a href="#aop-schema-introductions">5.5.4. Introductions</a></li>
<li><a href="#aop-schema-instatiation-models">5.5.5. Aspect Instantiation Models</a></li>
<li><a href="#aop-schema-advisors">5.5.6. Advisors</a></li>
<li><a href="#aop-schema-example">5.5.7. An AOP Schema Example</a></li>
</ul>
</li>
<li><a href="#aop-choosing">5.6. Choosing which AOP Declaration Style to Use</a>
<ul class="sectlevel3">
<li><a href="#aop-spring-or-aspectj">5.6.1. Spring AOP or Full AspectJ?</a></li>
<li><a href="#aop-ataspectj-or-xml">5.6.2. @AspectJ or XML for Spring AOP?</a></li>
</ul>
</li>
<li><a href="#aop-mixing-styles">5.7. Mixing Aspect Types</a></li>
<li><a href="#aop-proxying">5.8. Proxying Mechanisms</a>
<ul class="sectlevel3">
<li><a href="#aop-understanding-aop-proxies">5.8.1. Understanding AOP Proxies</a></li>
</ul>
</li>
<li><a href="#aop-aspectj-programmatic">5.9. Programmatic Creation of @AspectJ Proxies</a></li>
<li><a href="#aop-using-aspectj">5.10. Using AspectJ with Spring Applications</a>
<ul class="sectlevel3">
<li><a href="#aop-atconfigurable">5.10.1. Using AspectJ to Dependency Inject Domain Objects with Spring</a>
<ul class="sectlevel4">
<li><a href="#aop-configurable-testing">Unit Testing <code>@Configurable</code> Objects</a></li>
<li><a href="#aop-configurable-container">Working with Multiple Application Contexts</a></li>
</ul>
</li>
<li><a href="#aop-ajlib-other">5.10.2. Other Spring aspects for AspectJ</a></li>
<li><a href="#aop-aj-configure">5.10.3. Configuring AspectJ Aspects by Using Spring IoC</a></li>
<li><a href="#aop-aj-ltw">5.10.4. Load-time Weaving with AspectJ in the Spring Framework</a>
<ul class="sectlevel4">
<li><a href="#aop-aj-ltw-first-example">A First Example</a></li>
<li><a href="#aop-aj-ltw-the-aspects">Aspects</a></li>
<li><a href="#aop-aj-ltw-aop_dot_xml">'META-INF/aop.xml'</a></li>
<li><a href="#aop-aj-ltw-libraries">Required libraries (JARS)</a></li>
<li><a href="#aop-aj-ltw-spring">Spring Configuration</a></li>
<li><a href="#aop-aj-ltw-environments">Environment-specific Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#aop-resources">5.11. Further Resources</a></li>
</ul>
</li>
<li><a href="#aop-api">6. Spring AOP APIs</a>
<ul class="sectlevel2">
<li><a href="#aop-api-pointcuts">6.1. Pointcut API in Spring</a>
<ul class="sectlevel3">
<li><a href="#aop-api-concepts">6.1.1. Concepts</a></li>
<li><a href="#aop-api-pointcut-ops">6.1.2. Operations on Pointcuts</a></li>
<li><a href="#aop-api-pointcuts-aspectj">6.1.3. AspectJ Expression Pointcuts</a></li>
<li><a href="#aop-api-pointcuts-impls">6.1.4. Convenience Pointcut Implementations</a>
<ul class="sectlevel4">
<li><a href="#aop-api-pointcuts-static">Static Pointcuts</a></li>
<li><a href="#aop-api-pointcuts-dynamic">Dynamic pointcuts</a></li>
</ul>
</li>
<li><a href="#aop-api-pointcuts-superclasses">6.1.5. Pointcut Superclasses</a></li>
<li><a href="#aop-api-pointcuts-custom">6.1.6. Custom Pointcuts</a></li>
</ul>
</li>
<li><a href="#aop-api-advice">6.2. Advice API in Spring</a>
<ul class="sectlevel3">
<li><a href="#aop-api-advice-lifecycle">6.2.1. Advice Lifecycles</a></li>
<li><a href="#aop-api-advice-types">6.2.2. Advice Types in Spring</a>
<ul class="sectlevel4">
<li><a href="#aop-api-advice-around">Interception Around Advice</a></li>
<li><a href="#aop-api-advice-before">Before Advice</a></li>
<li><a href="#aop-api-advice-throws">Throws Advice</a></li>
<li><a href="#aop-api-advice-after-returning">After Returning Advice</a></li>
<li><a href="#aop-api-advice-introduction">Introduction Advice</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#aop-api-advisor">6.3. The Advisor API in Spring</a></li>
<li><a href="#aop-pfb">6.4. Using the <code>ProxyFactoryBean</code> to Create AOP Proxies</a>
<ul class="sectlevel3">
<li><a href="#aop-pfb-1">6.4.1. Basics</a></li>
<li><a href="#aop-pfb-2">6.4.2. JavaBean Properties</a></li>
<li><a href="#aop-pfb-proxy-types">6.4.3. JDK- and CGLIB-based proxies</a></li>
<li><a href="#aop-api-proxying-intf">6.4.4. Proxying Interfaces</a></li>
<li><a href="#aop-api-proxying-class">6.4.5. Proxying Classes</a></li>
<li><a href="#aop-global-advisors">6.4.6. Using &#8220;Global&#8221; Advisors</a></li>
</ul>
</li>
<li><a href="#aop-concise-proxy">6.5. Concise Proxy Definitions</a></li>
<li><a href="#aop-prog">6.6. Creating AOP Proxies Programmatically with the <code>ProxyFactory</code></a></li>
<li><a href="#aop-api-advised">6.7. Manipulating Advised Objects</a></li>
<li><a href="#aop-autoproxy">6.8. Using the "auto-proxy" facility</a>
<ul class="sectlevel3">
<li><a href="#aop-autoproxy-choices">6.8.1. Auto-proxy Bean Definitions</a>
<ul class="sectlevel4">
<li><a href="#aop-api-autoproxy"><code>BeanNameAutoProxyCreator</code></a></li>
<li><a href="#aop-api-autoproxy-default"><code>DefaultAdvisorAutoProxyCreator</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#aop-targetsource">6.9. Using <code>TargetSource</code> Implementations</a>
<ul class="sectlevel3">
<li><a href="#aop-ts-swap">6.9.1. Hot-swappable Target Sources</a></li>
<li><a href="#aop-ts-pool">6.9.2. Pooling Target Sources</a></li>
<li><a href="#aop-ts-prototype">6.9.3. Prototype Target Sources</a></li>
<li><a href="#aop-ts-threadlocal">6.9.4. <code>ThreadLocal</code> Target Sources</a></li>
</ul>
</li>
<li><a href="#aop-extensibility">6.10. Defining New Advice Types</a></li>
</ul>
</li>
<li><a href="#null-safety">7. Null-safety</a>
<ul class="sectlevel2">
<li><a href="#use-cases">7.1. Use cases</a></li>
<li><a href="#jsr-305-meta-annotations">7.2. JSR-305 meta-annotations</a></li>
</ul>
</li>
<li><a href="#databuffers">8. Data Buffers and Codecs</a>
<ul class="sectlevel2">
<li><a href="#databuffers-factory">8.1. <code>DataBufferFactory</code></a></li>
<li><a href="#databuffers-buffer">8.2. <code>DataBuffer</code></a></li>
<li><a href="#databuffers-buffer-pooled">8.3. <code>PooledDataBuffer</code></a></li>
<li><a href="#databuffers-utils">8.4. <code>DataBufferUtils</code></a></li>
<li><a href="#codecs">8.5. Codecs</a></li>
<li><a href="#databuffers-using">8.6. Using <code>DataBuffer</code></a></li>
</ul>
</li>
<li><a href="#spring-jcl">9. Logging</a></li>
<li><a href="#appendix">10. Appendix</a>
<ul class="sectlevel2">
<li><a href="#xsd-schemas">10.1. XML Schemas</a>
<ul class="sectlevel3">
<li><a href="#xsd-schemas-util">10.1.1. The <code>util</code> Schema</a>
<ul class="sectlevel4">
<li><a href="#xsd-schemas-util-constant">Using <code>&lt;util:constant/&gt;</code></a></li>
<li><a href="#xsd-schemas-util-property-path">Using <code>&lt;util:property-path/&gt;</code></a></li>
<li><a href="#xsd-schemas-util-properties">Using <code>&lt;util:properties/&gt;</code></a></li>
<li><a href="#xsd-schemas-util-list">Using <code>&lt;util:list/&gt;</code></a></li>
<li><a href="#xsd-schemas-util-map">Using <code>&lt;util:map/&gt;</code></a></li>
<li><a href="#xsd-schemas-util-set">Using <code>&lt;util:set/&gt;</code></a></li>
</ul>
</li>
<li><a href="#xsd-schemas-aop">10.1.2. The <code>aop</code> Schema</a></li>
<li><a href="#xsd-schemas-context">10.1.3. The <code>context</code> Schema</a>
<ul class="sectlevel4">
<li><a href="#xsd-schemas-context-pphc">Using <code>&lt;property-placeholder/&gt;</code></a></li>
<li><a href="#xsd-schemas-context-ac">Using <code>&lt;annotation-config/&gt;</code></a></li>
<li><a href="#xsd-schemas-context-component-scan">Using <code>&lt;component-scan/&gt;</code></a></li>
<li><a href="#xsd-schemas-context-ltw">Using <code>&lt;load-time-weaver/&gt;</code></a></li>
<li><a href="#xsd-schemas-context-sc">Using <code>&lt;spring-configured/&gt;</code></a></li>
<li><a href="#xsd-schemas-context-mbe">Using <code>&lt;mbean-export/&gt;</code></a></li>
</ul>
</li>
<li><a href="#xsd-schemas-beans">10.1.4. The Beans Schema</a></li>
</ul>
</li>
<li><a href="#xml-custom">10.2. XML Schema Authoring</a>
<ul class="sectlevel3">
<li><a href="#xsd-custom-schema">10.2.1. Authoring the Schema</a></li>
<li><a href="#xsd-custom-namespacehandler">10.2.2. Coding a <code>NamespaceHandler</code></a></li>
<li><a href="#xsd-custom-parser">10.2.3. Using <code>BeanDefinitionParser</code></a></li>
<li><a href="#xsd-custom-registration">10.2.4. Registering the Handler and the Schema</a>
<ul class="sectlevel4">
<li><a href="#xsd-custom-registration-spring-handlers">Writing <code>META-INF/spring.handlers</code></a></li>
<li><a href="#xsd-custom-registration-spring-schemas">Writing 'META-INF/spring.schemas'</a></li>
</ul>
</li>
<li><a href="#xsd-custom-using">10.2.5. Using a Custom Extension in Your Spring XML Configuration</a></li>
<li><a href="#xsd-custom-meat">10.2.6. More Detailed Examples</a>
<ul class="sectlevel4">
<li><a href="#xsd-custom-custom-nested">Nesting Custom Elements within Custom Elements</a></li>
<li><a href="#xsd-custom-custom-just-attributes">Custom Attributes on &#8220;Normal&#8221; Elements</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#application-startup-steps">10.3. Application Startup Steps</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This part of the reference documentation covers all the technologies that are
absolutely integral to the Spring Framework.
<div class="translate">
参考文档的这一部分涵盖了Spring框架中绝对不可或缺的所有技术。
</div>
</p>
</div>
<div class="paragraph">
<p>Foremost amongst these is the Spring Framework&#8217;s Inversion of Control (IoC) container.
A thorough treatment of the Spring Framework&#8217;s IoC container is closely followed by
comprehensive coverage of Spring&#8217;s Aspect-Oriented Programming (AOP) technologies.
The Spring Framework has its own AOP framework, which is conceptually easy to
understand and which successfully addresses the 80% sweet spot of AOP requirements
in Java enterprise programming.
<div class="translate">
其中最重要的是Spring框架的控制反转(IoC)容器。
在对Spring框架的IoC容器进行了全面的处理之后，紧接着全面介绍了Spring的面向切面编程(AOP)技术。
Spring框架有自己的AOP框架，它在概念上很容易理解，并且成功地解决了Java企业编程中80%的AOP需求。
</div>
</p>
</div>
<div class="paragraph">
<p>Coverage of Spring&#8217;s integration with AspectJ (currently the richest&#8201;&#8212;&#8201;in terms of
features&#8201;&#8212;&#8201;and certainly most mature AOP implementation in the Java enterprise space)
is also provided.
<div class="translate">
还介绍了Spring与AspectJ的集成(就特性而言，目前AspectJ是最丰富的，当然也是Java企业空间中最成熟的AOP实现)。
</div>
</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="beans"><a class="anchor" href="#beans"></a>1. The IoC Container <div class="translate">（IoC容器）</div></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter covers Spring&#8217;s Inversion of Control (IoC) container.<div class="translate">本章介绍Spring的控制反转(IoC)容器。</div></p>
</div>
<div class="sect2">
<h3 id="beans-introduction"><a class="anchor" href="#beans-introduction"></a>1.1. Introduction to the Spring IoC Container and Beans<div class="translate">（Spring IoC容器和Beans的介绍）</div></h3>
<div class="paragraph">
<p>This chapter covers the Spring Framework implementation of the Inversion of Control
(IoC) principle. IoC is also known as dependency injection (DI). It is a process whereby
objects define their dependencies (that is, the other objects they work with) only through
constructor arguments, arguments to a factory method, or properties that are set on the
object instance after it is constructed or returned from a factory method. The container
then injects those dependencies when it creates the bean. This process is fundamentally
the inverse (hence the name, Inversion of Control) of the bean itself
controlling the instantiation or location of its dependencies by using direct
construction of classes or a mechanism such as the Service Locator pattern.
<div class="translate">
本章介绍了控制反转(IoC)原理的Spring框架实现。IoC也称为依赖项注入(DI)。在这个过程中，
对象只能通过构造函数参数、工厂方法的参数或在对象实例被构造或从工厂方法返回后设置的属性来定义它们的依赖关系(即它们使用的其他对象)。
然后，容器在创建bean时注入这些依赖项。这个过程基本上是bean本身通过直接构造类或诸如Service Locator模式这样的机制来控制其依赖项的实例化或位置的逆过程(因此得名“控制反转”)。
</div>
</p>
</div>
<div class="paragraph">
<p>The <code>org.springframework.beans</code> and <code>org.springframework.context</code> packages are the basis
for Spring Framework&#8217;s IoC container. The
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/beans/factory/BeanFactory.html"><code>BeanFactory</code></a>
interface provides an advanced configuration mechanism capable of managing any type of
object.
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/context/ApplicationContext.html"><code>ApplicationContext</code></a>
is a sub-interface of <code>BeanFactory</code>. It adds:
<div class="translate">
org.springframework.beans和org.springframework.context包是Spring框架的IoC容器的基础。
BeanFactory接口提供了能够管理任何类型对象的高级配置机制。ApplicationContext是BeanFactory的一个子接口。它增加了以下特性:
</div>
</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Easier integration with Spring&#8217;s AOP features<div class="translate">更容易与Spring的AOP特性集成</div></p>
</li>
<li>
<p>Message resource handling (for use in internationalization)<div class="translate">消息资源处理(用于国际化)</div></p>
</li>
<li>
<p>Event publication<div class="translate">事件发布</div></p>
</li>
<li>
<p>Application-layer specific contexts such as the <code>WebApplicationContext</code>
for use in web applications.<div class="translate">应用层特定的上下文，如web应用中使用的WebApplicationContext。</div></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In short, the <code>BeanFactory</code> provides the configuration framework and basic
functionality, and the <code>ApplicationContext</code> adds more enterprise-specific functionality.
The <code>ApplicationContext</code> is a complete superset of the <code>BeanFactory</code> and is used
exclusively in this chapter in descriptions of Spring&#8217;s IoC container. For more
information on using the <code>BeanFactory</code> instead of the <code>ApplicationContext,</code> see
<a href="#beans-beanfactory">The <code>BeanFactory</code></a>.
<div class="translate">
简而言之，BeanFactory提供了配置框架和基本功能，而ApplicationContext添加了更多特定于企业的功能。
ApplicationContext是BeanFactory的一个完整超集，被专门用来在本章中描述Spring的IoC容器。
有关使用BeanFactory而不是ApplicationContext的更多信息，请参见BeanFactory。
</div>
</p>
</div>
<div class="paragraph">
<p>In Spring, the objects that form the backbone of your application and that are managed
by the Spring IoC container are called beans. A bean is an object that is
instantiated, assembled, and managed by a Spring IoC container. Otherwise, a
bean is simply one of many objects in your application. Beans, and the dependencies
among them, are reflected in the configuration metadata used by a container.
<div class="translate">
在Spring中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。
bean是由Spring IoC容器实例化、组装和管理的对象。否则，bean只是应用程序中的众多对象之一。
bean及其之间的依赖关系反映在容器使用的配置元数据中。
</div>
</p>
</div>
</div>
<div class="sect2">
<h3 id="beans-basics"><a class="anchor" href="#beans-basics"></a>1.2. Container Overview<div class="translate">（容器概述）</div></h3>
<div class="paragraph">
<p>The <code>org.springframework.context.ApplicationContext</code> interface represents the Spring IoC
container and is responsible for instantiating, configuring, and assembling the
beans. The container gets its instructions on what objects to
instantiate, configure, and assemble by reading configuration metadata. The
configuration metadata is represented in XML, Java annotations, or Java code. It lets
you express the objects that compose your application and the rich interdependencies
between those objects.
<div class="translate">
org.springframework.context.ApplicationContext接口代表Spring IoC容器，它负责实例化、配置和组装beans。容器通过读取配置元数据获得关于实例化、配置和组装哪些对象的指令。
配置元数据用XML、Java注释或Java代码表示。它允许您表达组成应用程序的对象以及这些对象之间丰富的相互依赖关系。
</div>
</p>
</div>
<div class="paragraph">
<p>Several implementations of the <code>ApplicationContext</code> interface are supplied
with Spring. In stand-alone applications, it is common to create an
instance of
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html"><code>ClassPathXmlApplicationContext</code></a>
or <a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/context/support/FileSystemXmlApplicationContext.html"><code>FileSystemXmlApplicationContext</code></a>.
While XML has been the traditional format for defining configuration metadata, you can
instruct the container to use Java annotations or code as the metadata format by
providing a small amount of XML configuration to declaratively enable support for these
additional metadata formats.
<div class="translate">
Spring提供了ApplicationContext接口的几个实现。在独立应用程序中，通常会创建ClassPathXmlApplicationContext或FileSystemXmlApplicationContext的实例。
虽然XML是定义配置元数据的传统格式，但是您可以通过提供少量XML配置以声明方式支持这些额外的元数据格式，指示容器使用Java注释或代码作为元数据格式。
</div>
</p>
</div>
<div class="paragraph">
<p>In most application scenarios, explicit user code is not required to instantiate one or
more instances of a Spring IoC container. For example, in a web application scenario, a
simple eight (or so) lines of boilerplate web descriptor XML in the <code>web.xml</code> file
of the application typically suffices (see <a href="#context-create">Convenient ApplicationContext Instantiation for Web Applications</a>). If you use the
<a href="https://spring.io/tools">Spring Tools for Eclipse</a> (an Eclipse-powered development
environment), you can easily create this boilerplate configuration with a few mouse clicks or
keystrokes.
<div class="translate">
在大多数应用程序场景中，不需要显式的用户代码来实例化Spring IoC容器的一个或多个实例。
例如，在一个web应用程序场景中，在应用程序的web.xml文件中简单的8行(大约)web描述符XML样本就足够了(参见方便的web应用程序上下文实例化)。
如果您使用用于Eclipse的Spring Tools (Eclipse支持的开发环境)，那么只需点击几下鼠标或击几下键，就可以轻松创建这个样板配置。
</div>
</p>
</div>
<div class="paragraph">
<p>The following diagram shows a high-level view of how Spring works. Your application classes
are combined with configuration metadata so that, after the <code>ApplicationContext</code> is
created and initialized, you have a fully configured and executable system or
application.</p>
<div class="translate">
下图显示了Spring如何工作的高级视图。应用程序类与配置元数据相结合，这样在ApplicationContext创建并初始化之后，您就拥有了一个配置完整且可执行的系统或应用程序。
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/container-magic.png" alt="container magic">
</div>
<div class="title">Figure 1. The Spring IoC container</div>
</div>
<div class="sect3">
<h4 id="beans-factory-metadata"><a class="anchor" href="#beans-factory-metadata"></a>1.2.1. Configuration Metadata</h4>
<div class="paragraph">
<p>As the preceding diagram shows, the Spring IoC container consumes a form of
configuration metadata. This configuration metadata represents how you, as an
application developer, tell the Spring container to instantiate, configure, and assemble
the objects in your application.</p>
</div>
<div class="paragraph">
<p>Configuration metadata is traditionally supplied in a simple and intuitive XML format,
which is what most of this chapter uses to convey key concepts and features of the
Spring IoC container.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
XML-based metadata is not the only allowed form of configuration metadata.
The Spring IoC container itself is totally decoupled from the format in which this
configuration metadata is actually written. These days, many developers choose
<a href="#beans-java">Java-based configuration</a> for their Spring applications.
<div class="translate">
基于xml的元数据并不是唯一允许的配置元数据形式。Spring IoC容器本身与配置元数据实际编写的格式完全分离。现在，许多开发人员为他们的Spring应用程序选择基于java的配置。
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For information about using other forms of metadata with the Spring container, see:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#beans-annotation-config">Annotation-based configuration</a>: Spring 2.5 introduced
support for annotation-based configuration metadata.</p>
</li>
<li>
<p><a href="#beans-java">Java-based configuration</a>: Starting with Spring 3.0, many features
provided by the Spring JavaConfig project became part of the core Spring Framework.
Thus, you can define beans external to your application classes by using Java rather
than XML files. To use these new features, see the
<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Configuration.html"><code>@Configuration</code></a>,
<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Bean.html"><code>@Bean</code></a>,
<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/Import.html"><code>@Import</code></a>,
and <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/DependsOn.html"><code>@DependsOn</code></a> annotations.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring configuration consists of at least one and typically more than one bean
definition that the container must manage. XML-based configuration metadata configures these
beans as <code>&lt;bean/&gt;</code> elements inside a top-level <code>&lt;beans/&gt;</code> element. Java
configuration typically uses <code>@Bean</code>-annotated methods within a <code>@Configuration</code> class.</p>
</div>
<div class="paragraph">
<p>These bean definitions correspond to the actual objects that make up your application.
Typically, you define service layer objects, data access objects (DAOs), presentation
objects such as Struts <code>Action</code> instances, infrastructure objects such as Hibernate
<code>SessionFactories</code>, JMS <code>Queues</code>, and so forth. Typically, one does not configure
fine-grained domain objects in the container, because it is usually the responsibility
of DAOs and business logic to create and load domain objects. However, you can use
Spring&#8217;s integration with AspectJ to configure objects that have been created outside
the control of an IoC container. See <a href="#aop-atconfigurable">Using AspectJ to
dependency-inject domain objects with Spring</a>.</p>
</div>
<div class="paragraph">
<p>The following example shows the basic structure of XML-based configuration metadata:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean id="..." class="..."&gt; <i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b>
        &lt;!-- collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;bean id="..." class="..."&gt;
        &lt;!-- collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;!-- more bean definitions go here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>id</code> attribute is a string that identifies the individual bean definition.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>class</code> attribute defines the type of the bean and uses the fully qualified
classname.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The value of the <code>id</code> attribute refers to collaborating objects. The XML for
referring to collaborating objects is not shown in this example. See
<a href="#beans-dependencies">Dependencies</a> for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-instantiation"><a class="anchor" href="#beans-factory-instantiation"></a>1.2.2. Instantiating a Container</h4>
<div class="paragraph">
<p>The location path or paths
supplied to an <code>ApplicationContext</code> constructor are resource strings that let
the container load configuration metadata from a variety of external resources, such
as the local file system, the Java <code>CLASSPATH</code>, and so on.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val context = ClassPathXmlApplicationContext("services.xml", "daos.xml")</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>After you learn about Spring&#8217;s IoC container, you may want to know more about Spring&#8217;s
<code>Resource</code> abstraction (as described in <a href="#resources">Resources</a>), which provides a convenient
mechanism for reading an InputStream from locations defined in a URI syntax. In particular,
<code>Resource</code> paths are used to construct applications contexts, as described in <a href="#resources-app-ctx">Application Contexts and Resource Paths</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows the service layer objects <code>(services.xml)</code> configuration file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;!-- services --&gt;

    &lt;bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl"&gt;
        &lt;property name="accountDao" ref="accountDao"/&gt;
        &lt;property name="itemDao" ref="itemDao"/&gt;
        &lt;!-- additional collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;!-- more bean definitions for services go here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the data access objects <code>daos.xml</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean id="accountDao"
        class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao"&gt;
        &lt;!-- additional collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao"&gt;
        &lt;!-- additional collaborators and configuration for this bean go here --&gt;
    &lt;/bean&gt;

    &lt;!-- more bean definitions for data access objects go here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the service layer consists of the <code>PetStoreServiceImpl</code> class
and two data access objects of the types <code>JpaAccountDao</code> and <code>JpaItemDao</code> (based
on the JPA Object-Relational Mapping standard). The <code>property name</code> element refers to the
name of the JavaBean property, and the <code>ref</code> element refers to the name of another bean
definition. This linkage between <code>id</code> and <code>ref</code> elements expresses the dependency between
collaborating objects. For details of configuring an object&#8217;s dependencies, see
<a href="#beans-dependencies">Dependencies</a>.</p>
</div>
<div class="sect4">
<h5 id="beans-factory-xml-import"><a class="anchor" href="#beans-factory-xml-import"></a>Composing XML-based Configuration Metadata</h5>
<div class="paragraph">
<p>It can be useful to have bean definitions span multiple XML files. Often, each individual
XML configuration file represents a logical layer or module in your architecture.</p>
</div>
<div class="paragraph">
<p>You can use the application context constructor to load bean definitions from all these
XML fragments. This constructor takes multiple <code>Resource</code> locations, as was shown in the
<a href="#beans-factory-instantiation">previous section</a>. Alternatively, use one or more
occurrences of the <code>&lt;import/&gt;</code> element to load bean definitions from another file or
files. The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;import resource="services.xml"/&gt;
    &lt;import resource="resources/messageSource.xml"/&gt;
    &lt;import resource="/resources/themeSource.xml"/&gt;

    &lt;bean id="bean1" class="..."/&gt;
    &lt;bean id="bean2" class="..."/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, external bean definitions are loaded from three files:
<code>services.xml</code>, <code>messageSource.xml</code>, and <code>themeSource.xml</code>. All location paths are
relative to the definition file doing the importing, so <code>services.xml</code> must be in the
same directory or classpath location as the file doing the importing, while
<code>messageSource.xml</code> and <code>themeSource.xml</code> must be in a <code>resources</code> location below the
location of the importing file. As you can see, a leading slash is ignored. However, given
that these paths are relative, it is better form not to use the slash at all. The
contents of the files being imported, including the top level <code>&lt;beans/&gt;</code> element, must
be valid XML bean definitions, according to the Spring Schema.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>It is possible, but not recommended, to reference files in parent directories using a
relative "../" path. Doing so creates a dependency on a file that is outside the current
application. In particular, this reference is not recommended for <code>classpath:</code> URLs (for
example, <code>classpath:../services.xml</code>), where the runtime resolution process chooses the
&#8220;nearest&#8221; classpath root and then looks into its parent directory. Classpath
configuration changes may lead to the choice of a different, incorrect directory.</p>
</div>
<div class="paragraph">
<p>You can always use fully qualified resource locations instead of relative paths: for
example, <code>file:C:/config/services.xml</code> or <code>classpath:/config/services.xml</code>. However, be
aware that you are coupling your application&#8217;s configuration to specific absolute
locations. It is generally preferable to keep an indirection for such absolute
locations&#8201;&#8212;&#8201;for example, through "${&#8230;&#8203;}" placeholders that are resolved against JVM
system properties at runtime.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The namespace itself provides the import directive feature. Further
configuration features beyond plain bean definitions are available in a selection
of XML namespaces provided by Spring&#8201;&#8212;&#8201;for example, the <code>context</code> and <code>util</code> namespaces.</p>
</div>
</div>
<div class="sect4">
<h5 id="groovy-bean-definition-dsl"><a class="anchor" href="#groovy-bean-definition-dsl"></a>The Groovy Bean Definition DSL</h5>
<div class="paragraph">
<p>As a further example for externalized configuration metadata, bean definitions can also
be expressed in Spring&#8217;s Groovy Bean Definition DSL, as known from the Grails framework.
Typically, such configuration live in a ".groovy" file with the structure shown in the
following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">beans {
    dataSource(BasicDataSource) {
        driverClassName = "org.hsqldb.jdbcDriver"
        url = "jdbc:hsqldb:mem:grailsDB"
        username = "sa"
        password = ""
        settings = [mynew:"setting"]
    }
    sessionFactory(SessionFactory) {
        dataSource = dataSource
    }
    myService(MyService) {
        nestedBean = { AnotherBean bean -&gt;
            dataSource = dataSource
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This configuration style is largely equivalent to XML bean definitions and even
supports Spring&#8217;s XML configuration namespaces. It also allows for importing XML
bean definition files through an <code>importBeans</code> directive.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-client"><a class="anchor" href="#beans-factory-client"></a>1.2.3. Using the Container</h4>
<div class="paragraph">
<p>The <code>ApplicationContext</code> is the interface for an advanced factory capable of maintaining
a registry of different beans and their dependencies. By using the method
<code>T getBean(String name, Class&lt;T&gt; requiredType)</code>, you can retrieve instances of your beans.</p>
</div>
<div class="paragraph">
<p>The <code>ApplicationContext</code> lets you read bean definitions and access them, as the following
example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// create and configure beans
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");

// retrieve configured instance
PetStoreService service = context.getBean("petStore", PetStoreService.class);

// use configured instance
List&lt;String&gt; userList = service.getUsernameList();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.beans.factory.getBean

// create and configure beans
val context = ClassPathXmlApplicationContext("services.xml", "daos.xml")

// retrieve configured instance
val service = context.getBean&lt;PetStoreService&gt;("petStore")

// use configured instance
var userList = service.getUsernameList()</code></pre>
</div>
</div>
<div class="paragraph">
<p>With Groovy configuration, bootstrapping looks very similar. It has a different context
implementation class which is Groovy-aware (but also understands XML bean definitions).
The following example shows Groovy configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ApplicationContext context = new GenericGroovyApplicationContext("services.groovy", "daos.groovy");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val context = GenericGroovyApplicationContext("services.groovy", "daos.groovy")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The most flexible variant is <code>GenericApplicationContext</code> in combination with reader
delegates&#8201;&#8212;&#8201;for example, with <code>XmlBeanDefinitionReader</code> for XML files, as the following
example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">GenericApplicationContext context = new GenericApplicationContext();
new XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml");
context.refresh();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val context = GenericApplicationContext()
XmlBeanDefinitionReader(context).loadBeanDefinitions("services.xml", "daos.xml")
context.refresh()</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also use the <code>GroovyBeanDefinitionReader</code> for Groovy files, as the following
example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">GenericApplicationContext context = new GenericApplicationContext();
new GroovyBeanDefinitionReader(context).loadBeanDefinitions("services.groovy", "daos.groovy");
context.refresh();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val context = GenericApplicationContext()
GroovyBeanDefinitionReader(context).loadBeanDefinitions("services.groovy", "daos.groovy")
context.refresh()</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can mix and match such reader delegates on the same <code>ApplicationContext</code>,
reading bean definitions from diverse configuration sources.</p>
</div>
<div class="paragraph">
<p>You can then use <code>getBean</code> to retrieve instances of your beans. The <code>ApplicationContext</code>
interface has a few other methods for retrieving beans, but, ideally, your application
code should never use them. Indeed, your application code should have no calls to the
<code>getBean()</code> method at all and thus have no dependency on Spring APIs at all. For example,
Spring&#8217;s integration with web frameworks provides dependency injection for various web
framework components such as controllers and JSF-managed beans, letting you declare
a dependency on a specific bean through metadata (such as an autowiring annotation).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-definition"><a class="anchor" href="#beans-definition"></a>1.3. Bean Overview</h3>
<div class="paragraph">
<p>A Spring IoC container manages one or more beans. These beans are created with the
configuration metadata that you supply to the container (for example, in the form of XML
<code>&lt;bean/&gt;</code> definitions).</p>
</div>
<div class="paragraph">
<p>Within the container itself, these bean definitions are represented as <code>BeanDefinition</code>
objects, which contain (among other information) the following metadata:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A package-qualified class name: typically, the actual implementation class of the
bean being defined.</p>
</li>
<li>
<p>Bean behavioral configuration elements, which state how the bean should behave in the
container (scope, lifecycle callbacks, and so forth).</p>
</li>
<li>
<p>References to other beans that are needed for the bean to do its work. These
references are also called collaborators or dependencies.</p>
</li>
<li>
<p>Other configuration settings to set in the newly created object&#8201;&#8212;&#8201;for example, the size
limit of the pool or the number of connections to use in a bean that manages a
connection pool.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This metadata translates to a set of properties that make up each bean definition.
The following table describes these properties:</p>
</div>
<table id="beans-factory-bean-definition-tbl" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. The bean definition</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Explained in&#8230;&#8203;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Class</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-class">Instantiating Beans</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-beanname">Naming Beans</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Scope</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes">Bean Scopes</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Constructor arguments</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-collaborators">Dependency Injection</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Properties</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-collaborators">Dependency Injection</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Autowiring mode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-autowire">Autowiring Collaborators</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lazy initialization mode</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-lazy-init">Lazy-initialized Beans</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initialization method</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-lifecycle-initializingbean">Initialization Callbacks</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Destruction method</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-lifecycle-disposablebean">Destruction Callbacks</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>In addition to bean definitions that contain information on how to create a specific
bean, the <code>ApplicationContext</code> implementations also permit the registration of existing
objects that are created outside the container (by users). This is done by accessing the
ApplicationContext&#8217;s BeanFactory through the <code>getBeanFactory()</code> method, which returns the
BeanFactory <code>DefaultListableBeanFactory</code> implementation. <code>DefaultListableBeanFactory</code>
supports this registration through the <code>registerSingleton(..)</code> and
<code>registerBeanDefinition(..)</code> methods. However, typical applications work solely with beans
defined through regular bean definition metadata.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Bean metadata and manually supplied singleton instances need to be registered as early
as possible, in order for the container to properly reason about them during autowiring
and other introspection steps. While overriding existing metadata and existing
singleton instances is supported to some degree, the registration of new beans at
runtime (concurrently with live access to the factory) is not officially supported and may
lead to concurrent access exceptions, inconsistent state in the bean container, or both.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-beanname"><a class="anchor" href="#beans-beanname"></a>1.3.1. Naming Beans</h4>
<div class="paragraph">
<p>Every bean has one or more identifiers. These identifiers must be unique within the
container that hosts the bean. A bean usually has only one identifier. However, if it
requires more than one, the extra ones can be considered aliases.</p>
</div>
<div class="paragraph">
<p>In XML-based configuration metadata, you use the <code>id</code> attribute, the <code>name</code> attribute, or
both to specify the bean identifiers. The <code>id</code> attribute lets you specify
exactly one id. Conventionally, these names are alphanumeric ('myBean',
'someService', etc.), but they can contain special characters as well. If you want to
introduce other aliases for the bean, you can also specify them in the <code>name</code>
attribute, separated by a comma (<code>,</code>), semicolon (<code>;</code>), or white space. As a
historical note, in versions prior to Spring 3.1, the <code>id</code> attribute was
defined as an <code>xsd:ID</code> type, which constrained possible characters. As of 3.1,
it is defined as an <code>xsd:string</code> type. Note that bean <code>id</code> uniqueness is still
enforced by the container, though no longer by XML parsers.</p>
</div>
<div class="paragraph">
<p>You are not required to supply a <code>name</code> or an <code>id</code> for a bean. If you do not supply a
<code>name</code> or <code>id</code> explicitly, the container generates a unique name for that bean. However,
if you want to refer to that bean by name, through the use of the <code>ref</code> element or a
Service Locator style lookup, you must provide a name.
Motivations for not supplying a name are related to using <a href="#beans-inner-beans">inner
beans</a> and <a href="#beans-factory-autowire">autowiring collaborators</a>.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Bean Naming Conventions</div>
<div class="paragraph">
<p>The convention is to use the standard Java convention for instance field names when
naming beans. That is, bean names start with a lowercase letter and are camel-cased
from there. Examples of such names include <code>accountManager</code>,
<code>accountService</code>, <code>userDao</code>, <code>loginController</code>, and so forth.</p>
</div>
<div class="paragraph">
<p>Naming beans consistently makes your configuration easier to read and understand.
Also, if you use Spring AOP, it helps a lot when applying advice to a set of beans
related by name.</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
With component scanning in the classpath, Spring generates bean names for unnamed
components, following the rules described earlier: essentially, taking the simple class name
and turning its initial character to lower-case. However, in the (unusual) special
case when there is more than one character and both the first and second characters
are upper case, the original casing gets preserved. These are the same rules as
defined by <code>java.beans.Introspector.decapitalize</code> (which Spring uses here).
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="beans-beanname-alias"><a class="anchor" href="#beans-beanname-alias"></a>Aliasing a Bean outside the Bean Definition</h5>
<div class="paragraph">
<p>In a bean definition itself, you can supply more than one name for the bean, by using a
combination of up to one name specified by the <code>id</code> attribute and any number of other
names in the <code>name</code> attribute. These names can be equivalent aliases to the same bean
and are useful for some situations, such as letting each component in an application
refer to a common dependency by using a bean name that is specific to that component
itself.</p>
</div>
<div class="paragraph">
<p>Specifying all aliases where the bean is actually defined is not always adequate,
however. It is sometimes desirable to introduce an alias for a bean that is defined
elsewhere. This is commonly the case in large systems where configuration is split
amongst each subsystem, with each subsystem having its own set of object definitions.
In XML-based configuration metadata, you can use the <code>&lt;alias/&gt;</code> element to accomplish
this. The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;alias name="fromName" alias="toName"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, a bean (in the same container) named <code>fromName</code> may also,
after the use of this alias definition, be referred to as <code>toName</code>.</p>
</div>
<div class="paragraph">
<p>For example, the configuration metadata for subsystem A may refer to a DataSource by the
name of <code>subsystemA-dataSource</code>. The configuration metadata for subsystem B may refer to
a DataSource by the name of <code>subsystemB-dataSource</code>. When composing the main application
that uses both these subsystems, the main application refers to the DataSource by the
name of <code>myApp-dataSource</code>. To have all three names refer to the same object, you can
add the following alias definitions to the configuration metadata:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;alias name="myApp-dataSource" alias="subsystemA-dataSource"/&gt;
&lt;alias name="myApp-dataSource" alias="subsystemB-dataSource"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now each component and the main application can refer to the dataSource through a name
that is unique and guaranteed not to clash with any other definition (effectively
creating a namespace), yet they refer to the same bean.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Java-configuration</div>
<div class="paragraph">
<p>If you use Javaconfiguration, the <code>@Bean</code> annotation can be used to provide aliases.
See <a href="#beans-java-bean-annotation">Using the <code>@Bean</code> Annotation</a> for details.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-class"><a class="anchor" href="#beans-factory-class"></a>1.3.2. Instantiating Beans</h4>
<div class="paragraph">
<p>A bean definition is essentially a recipe for creating one or more objects. The
container looks at the recipe for a named bean when asked and uses the configuration
metadata encapsulated by that bean definition to create (or acquire) an actual object.</p>
</div>
<div class="paragraph">
<p>If you use XML-based configuration metadata, you specify the type (or class) of object
that is to be instantiated in the <code>class</code> attribute of the <code>&lt;bean/&gt;</code> element. This
<code>class</code> attribute (which, internally, is a <code>Class</code> property on a <code>BeanDefinition</code>
instance) is usually mandatory. (For exceptions, see
<a href="#beans-factory-class-instance-factory-method">Instantiation by Using an Instance Factory Method</a> and <a href="#beans-child-bean-definitions">Bean Definition Inheritance</a>.)
You can use the <code>Class</code> property in one of two ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Typically, to specify the bean class to be constructed in the case where the container
itself directly creates the bean by calling its constructor reflectively, somewhat
equivalent to Java code with the <code>new</code> operator.</p>
</li>
<li>
<p>To specify the actual class containing the <code>static</code> factory method that is
invoked to create the object, in the less common case where the container invokes a
<code>static</code> factory method on a class to create the bean. The object type returned
from the invocation of the <code>static</code> factory method may be the same class or another
class entirely.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Nested class names</div>
<div class="paragraph">
<p>If you want to configure a bean definition for a nested class, you may use either the
binary name or the source name of the nested class.</p>
</div>
<div class="paragraph">
<p>For example, if you have a class called <code>SomeThing</code> in the <code>com.example</code> package, and
this <code>SomeThing</code> class has a <code>static</code> nested class called <code>OtherThing</code>, they can be
separated by a dollar sign (<code>$</code>) or a dot (<code>.</code>). So the value of the <code>class</code> attribute in
a bean definition would be <code>com.example.SomeThing$OtherThing</code> or
<code>com.example.SomeThing.OtherThing</code>.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-class-ctor"><a class="anchor" href="#beans-factory-class-ctor"></a>Instantiation with a Constructor</h5>
<div class="paragraph">
<p>When you create a bean by the constructor approach, all normal classes are usable by and
compatible with Spring. That is, the class being developed does not need to implement
any specific interfaces or to be coded in a specific fashion. Simply specifying the bean
class should suffice. However, depending on what type of IoC you use for that specific
bean, you may need a default (empty) constructor.</p>
</div>
<div class="paragraph">
<p>The Spring IoC container can manage virtually any class you want it to manage. It is
not limited to managing true JavaBeans. Most Spring users prefer actual JavaBeans with
only a default (no-argument) constructor and appropriate setters and getters modeled
after the properties in the container. You can also have more exotic non-bean-style
classes in your container. If, for example, you need to use a legacy connection pool
that absolutely does not adhere to the JavaBean specification, Spring can manage it as
well.</p>
</div>
<div class="paragraph">
<p>With XML-based configuration metadata you can specify your bean class as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="exampleBean" class="examples.ExampleBean"/&gt;

&lt;bean name="anotherExample" class="examples.ExampleBeanTwo"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For details about the mechanism for supplying arguments to the constructor (if required)
and setting object instance properties after the object is constructed, see
<a href="#beans-factory-collaborators">Injecting Dependencies</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-class-static-factory-method"><a class="anchor" href="#beans-factory-class-static-factory-method"></a>Instantiation with a Static Factory Method</h5>
<div class="paragraph">
<p>When defining a bean that you create with a static factory method, use the <code>class</code>
attribute to specify the class that contains the <code>static</code> factory method and an attribute
named <code>factory-method</code> to specify the name of the factory method itself. You should be
able to call this method (with optional arguments, as described later) and return a live
object, which subsequently is treated as if it had been created through a constructor.
One use for such a bean definition is to call <code>static</code> factories in legacy code.</p>
</div>
<div class="paragraph">
<p>The following bean definition specifies that the bean be created by calling a
factory method. The definition does not specify the type (class) of the returned object,
only the class containing the factory method. In this example, the <code>createInstance()</code>
method must be a static method. The following example shows how to specify a factory method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="clientService"
    class="examples.ClientService"
    factory-method="createInstance"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows a class that would work with the preceding bean definition:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class ClientService {
    private static ClientService clientService = new ClientService();
    private ClientService() {}

    public static ClientService createInstance() {
        return clientService;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class ClientService private constructor() {
    companion object {
        private val clientService = ClientService()
        fun createInstance() = clientService
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For details about the mechanism for supplying (optional) arguments to the factory method
and setting object instance properties after the object is returned from the factory,
see <a href="#beans-factory-properties-detailed">Dependencies and Configuration in Detail</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-class-instance-factory-method"><a class="anchor" href="#beans-factory-class-instance-factory-method"></a>Instantiation by Using an Instance Factory Method</h5>
<div class="paragraph">
<p>Similar to instantiation through a <a href="#beans-factory-class-static-factory-method">static
factory method</a>, instantiation with an instance factory method invokes a non-static
method of an existing bean from the container to create a new bean. To use this
mechanism, leave the <code>class</code> attribute empty and, in the <code>factory-bean</code> attribute,
specify the name of a bean in the current (or parent or ancestor) container that contains
the instance method that is to be invoked to create the object. Set the name of the
factory method itself with the <code>factory-method</code> attribute. The following example shows
how to configure such a bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;
&lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"&gt;
    &lt;!-- inject any dependencies required by this locator bean --&gt;
&lt;/bean&gt;

&lt;!-- the bean to be created via the factory bean --&gt;
&lt;bean id="clientService"
    factory-bean="serviceLocator"
    factory-method="createClientServiceInstance"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the corresponding class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class DefaultServiceLocator {

    private static ClientService clientService = new ClientServiceImpl();

    public ClientService createClientServiceInstance() {
        return clientService;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class DefaultServiceLocator {
    companion object {
        private val clientService = ClientServiceImpl()
    }
    fun createClientServiceInstance(): ClientService {
        return clientService
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>One factory class can also hold more than one factory method, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"&gt;
    &lt;!-- inject any dependencies required by this locator bean --&gt;
&lt;/bean&gt;

&lt;bean id="clientService"
    factory-bean="serviceLocator"
    factory-method="createClientServiceInstance"/&gt;

&lt;bean id="accountService"
    factory-bean="serviceLocator"
    factory-method="createAccountServiceInstance"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the corresponding class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class DefaultServiceLocator {

    private static ClientService clientService = new ClientServiceImpl();

    private static AccountService accountService = new AccountServiceImpl();

    public ClientService createClientServiceInstance() {
        return clientService;
    }

    public AccountService createAccountServiceInstance() {
        return accountService;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class DefaultServiceLocator {
    companion object {
        private val clientService = ClientServiceImpl()
        private val accountService = AccountServiceImpl()
    }

    fun createClientServiceInstance(): ClientService {
        return clientService
    }

    fun createAccountServiceInstance(): AccountService {
        return accountService
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This approach shows that the factory bean itself can be managed and configured through
dependency injection (DI). See <a href="#beans-factory-properties-detailed">Dependencies and
Configuration in Detail</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In Spring documentation, "factory bean" refers to a bean that is configured in the
Spring container and that creates objects through an
<a href="#beans-factory-class-instance-factory-method">instance</a> or
<a href="#beans-factory-class-static-factory-method">static</a> factory method. By contrast,
<code>FactoryBean</code> (notice the capitalization) refers to a Spring-specific
<a href="#beans-factory-extension-factorybean"><code>FactoryBean</code></a> implementation class.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-type-determination"><a class="anchor" href="#beans-factory-type-determination"></a>Determining a Bean&#8217;s Runtime Type</h5>
<div class="paragraph">
<p>The runtime type of a specific bean is non-trivial to determine. A specified class in
the bean metadata definition is just an initial class reference, potentially combined
with a declared factory method or being a <code>FactoryBean</code> class which may lead to a
different runtime type of the bean, or not being set at all in case of an instance-level
factory method (which is resolved via the specified <code>factory-bean</code> name instead).
Additionally, AOP proxying may wrap a bean instance with an interface-based proxy with
limited exposure of the target bean&#8217;s actual type (just its implemented interfaces).</p>
</div>
<div class="paragraph">
<p>The recommended way to find out about the actual runtime type of a particular bean is
a <code>BeanFactory.getType</code> call for the specified bean name. This takes all of the above
cases into account and returns the type of object that a <code>BeanFactory.getBean</code> call is
going to return for the same bean name.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-dependencies"><a class="anchor" href="#beans-dependencies"></a>1.4. Dependencies</h3>
<div class="paragraph">
<p>A typical enterprise application does not consist of a single object (or bean in the
Spring parlance). Even the simplest application has a few objects that work together to
present what the end-user sees as a coherent application. This next section explains how
you go from defining a number of bean definitions that stand alone to a fully realized
application where objects collaborate to achieve a goal.</p>
</div>
<div class="sect3">
<h4 id="beans-factory-collaborators"><a class="anchor" href="#beans-factory-collaborators"></a>1.4.1. Dependency Injection</h4>
<div class="paragraph">
<p>Dependency injection (DI) is a process whereby objects define their dependencies
(that is, the other objects with which they work) only through constructor arguments,
arguments to a factory method, or properties that are set on the object instance after
it is constructed or returned from a factory method. The container then injects those
dependencies when it creates the bean. This process is fundamentally the inverse (hence
the name, Inversion of Control) of the bean itself controlling the instantiation
or location of its dependencies on its own by using direct construction of classes or
the Service Locator pattern.</p>
</div>
<div class="paragraph">
<p>Code is cleaner with the DI principle, and decoupling is more effective when objects are
provided with their dependencies. The object does not look up its dependencies and does
not know the location or class of the dependencies. As a result, your classes become easier
to test, particularly when the dependencies are on interfaces or abstract base classes,
which allow for stub or mock implementations to be used in unit tests.</p>
</div>
<div class="paragraph">
<p>DI exists in two major variants: <a href="#beans-constructor-injection">Constructor-based
dependency injection</a> and <a href="#beans-setter-injection">Setter-based dependency injection</a>.</p>
</div>
<div class="sect4">
<h5 id="beans-constructor-injection"><a class="anchor" href="#beans-constructor-injection"></a>Constructor-based Dependency Injection</h5>
<div class="paragraph">
<p>Constructor-based DI is accomplished by the container invoking a constructor with a
number of arguments, each representing a dependency. Calling a <code>static</code> factory method
with specific arguments to construct the bean is nearly equivalent, and this discussion
treats arguments to a constructor and to a <code>static</code> factory method similarly. The
following example shows a class that can only be dependency-injected with constructor
injection:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on a MovieFinder
    private final MovieFinder movieFinder;

    // a constructor so that the Spring container can inject a MovieFinder
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// a constructor so that the Spring container can inject a MovieFinder
class SimpleMovieLister(private val movieFinder: MovieFinder) {
    // business logic that actually uses the injected MovieFinder is omitted...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that there is nothing special about this class. It is a POJO that
has no dependencies on container specific interfaces, base classes, or annotations.</p>
</div>
<div class="sect5">
<h6 id="beans-factory-ctor-arguments-resolution"><a class="anchor" href="#beans-factory-ctor-arguments-resolution"></a>Constructor Argument Resolution</h6>
<div class="paragraph">
<p>Constructor argument resolution matching occurs by using the argument&#8217;s type. If no
potential ambiguity exists in the constructor arguments of a bean definition, the
order in which the constructor arguments are defined in a bean definition is the order
in which those arguments are supplied to the appropriate constructor when the bean is
being instantiated. Consider the following class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package x.y;

public class ThingOne {

    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package x.y

class ThingOne(thingTwo: ThingTwo, thingThree: ThingThree)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assuming that the <code>ThingTwo</code> and <code>ThingThree</code> classes are not related by inheritance, no
potential ambiguity exists. Thus, the following configuration works fine, and you do not
need to specify the constructor argument indexes or types explicitly in the
<code>&lt;constructor-arg/&gt;</code> element.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;bean id="beanOne" class="x.y.ThingOne"&gt;
        &lt;constructor-arg ref="beanTwo"/&gt;
        &lt;constructor-arg ref="beanThree"/&gt;
    &lt;/bean&gt;

    &lt;bean id="beanTwo" class="x.y.ThingTwo"/&gt;

    &lt;bean id="beanThree" class="x.y.ThingThree"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When another bean is referenced, the type is known, and matching can occur (as was the
case with the preceding example). When a simple type is used, such as
<code>&lt;value&gt;true&lt;/value&gt;</code>, Spring cannot determine the type of the value, and so cannot match
by type without help. Consider the following class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package examples;

public class ExampleBean {

    // Number of years to calculate the Ultimate Answer
    private final int years;

    // The Answer to Life, the Universe, and Everything
    private final String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package examples

class ExampleBean(
    private val years: Int, // Number of years to calculate the Ultimate Answer
    private val ultimateAnswer: String// The Answer to Life, the Universe, and Everything
)</code></pre>
</div>
</div>
<div class="openblock">
<div class="title"><a id="beans-factory-ctor-arguments-type"></a>Constructor argument type matching</div>
<div class="content">
<div class="paragraph">
<p>In the preceding scenario, the container can use type matching with simple types if
you explicitly specify the type of the constructor argument by using the <code>type</code> attribute,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
    &lt;constructor-arg type="int" value="7500000"/&gt;
    &lt;constructor-arg type="java.lang.String" value="42"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="openblock">
<div class="title"><a id="beans-factory-ctor-arguments-index"></a>Constructor argument index</div>
<div class="content">
<div class="paragraph">
<p>You can use the <code>index</code> attribute to specify explicitly the index of constructor arguments,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
    &lt;constructor-arg index="0" value="7500000"/&gt;
    &lt;constructor-arg index="1" value="42"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition to resolving the ambiguity of multiple simple values, specifying an index
resolves ambiguity where a constructor has two arguments of the same type.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The index is 0-based.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="openblock">
<div class="title"><a id="beans-factory-ctor-arguments-name"></a>Constructor argument name</div>
<div class="content">
<div class="paragraph">
<p>You can also use the constructor parameter name for value disambiguation, as the following
example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
    &lt;constructor-arg name="years" value="7500000"/&gt;
    &lt;constructor-arg name="ultimateAnswer" value="42"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Keep in mind that, to make this work out of the box, your code must be compiled with the
debug flag enabled so that Spring can look up the parameter name from the constructor.
If you cannot or do not want to compile your code with the debug flag, you can use the
<a href="https://download.oracle.com/javase/8/docs/api/java/beans/ConstructorProperties.html">@ConstructorProperties</a>
JDK annotation to explicitly name your constructor arguments. The sample class would
then have to look as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package examples;

public class ExampleBean {

    // Fields omitted

    @ConstructorProperties({"years", "ultimateAnswer"})
    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package examples

class ExampleBean
@ConstructorProperties("years", "ultimateAnswer")
constructor(val years: Int, val ultimateAnswer: String)</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-setter-injection"><a class="anchor" href="#beans-setter-injection"></a>Setter-based Dependency Injection</h5>
<div class="paragraph">
<p>Setter-based DI is accomplished by the container calling setter methods on your
beans after invoking a no-argument constructor or a no-argument <code>static</code> factory method to
instantiate your bean.</p>
</div>
<div class="paragraph">
<p>The following example shows a class that can only be dependency-injected by using pure
setter injection. This class is conventional Java. It is a POJO that has no dependencies
on container specific interfaces, base classes, or annotations.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on the MovieFinder
    private MovieFinder movieFinder;

    // a setter method so that the Spring container can inject a MovieFinder
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class SimpleMovieLister {

    // a late-initialized property so that the Spring container can inject a MovieFinder
    lateinit var movieFinder: MovieFinder

    // business logic that actually uses the injected MovieFinder is omitted...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ApplicationContext</code> supports constructor-based and setter-based DI for the beans it
manages. It also supports setter-based DI after some dependencies have already been
injected through the constructor approach. You configure the dependencies in the form of
a <code>BeanDefinition</code>, which you use in conjunction with <code>PropertyEditor</code> instances to
convert properties from one format to another. However, most Spring users do not work
with these classes directly (that is, programmatically) but rather with XML <code>bean</code>
definitions, annotated components (that is, classes annotated with <code>@Component</code>,
<code>@Controller</code>, and so forth), or <code>@Bean</code> methods in Java-based <code>@Configuration</code> classes.
These sources are then converted internally into instances of <code>BeanDefinition</code> and used to
load an entire Spring IoC container instance.</p>
</div>
<div id="beans-constructor-vs-setter-injection" class="sidebarblock">
<div class="content">
<div class="title">Constructor-based or setter-based DI?</div>
<div class="paragraph">
<p>Since you can mix constructor-based and setter-based DI, it is a good rule of thumb to
use constructors for mandatory dependencies and setter methods or configuration methods
for optional dependencies. Note that use of the <a href="#beans-required-annotation">@Required</a>
annotation on a setter method can be used to make the property be a required dependency;
however, constructor injection with programmatic validation of arguments is preferable.</p>
</div>
<div class="paragraph">
<p>The Spring team generally advocates constructor injection, as it lets you implement
application components as immutable objects and ensures that required dependencies
are not <code>null</code>. Furthermore, constructor-injected components are always returned to the client
(calling) code in a fully initialized state. As a side note, a large number of constructor
arguments is a bad code smell, implying that the class likely has too many
responsibilities and should be refactored to better address proper separation of concerns.</p>
</div>
<div class="paragraph">
<p>Setter injection should primarily only be used for optional dependencies that can be
assigned reasonable default values within the class. Otherwise, not-null checks must be
performed everywhere the code uses the dependency. One benefit of setter injection is that
setter methods make objects of that class amenable to reconfiguration or re-injection
later. Management through <a href="integration.html#jmx">JMX MBeans</a> is therefore a compelling
use case for setter injection.</p>
</div>
<div class="paragraph">
<p>Use the DI style that makes the most sense for a particular class. Sometimes, when dealing
with third-party classes for which you do not have the source, the choice is made for you.
For example, if a third-party class does not expose any setter methods, then constructor
injection may be the only available form of DI.</p>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-dependency-resolution"><a class="anchor" href="#beans-dependency-resolution"></a>Dependency Resolution Process</h5>
<div class="paragraph">
<p>The container performs bean dependency resolution as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>ApplicationContext</code> is created and initialized with configuration metadata that
describes all the beans. Configuration metadata can be specified by XML, Java code, or
annotations.</p>
</li>
<li>
<p>For each bean, its dependencies are expressed in the form of properties, constructor
arguments, or arguments to the static-factory method (if you use that instead of a
normal constructor). These dependencies are provided to the bean, when the bean is
actually created.</p>
</li>
<li>
<p>Each property or constructor argument is an actual definition of the value to set, or
a reference to another bean in the container.</p>
</li>
<li>
<p>Each property or constructor argument that is a value is converted from its specified
format to the actual type of that property or constructor argument. By default, Spring
can convert a value supplied in string format to all built-in types, such as <code>int</code>,
<code>long</code>, <code>String</code>, <code>boolean</code>, and so forth.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Spring container validates the configuration of each bean as the container is created.
However, the bean properties themselves are not set until the bean is actually created.
Beans that are singleton-scoped and set to be pre-instantiated (the default) are created
when the container is created. Scopes are defined in <a href="#beans-factory-scopes">Bean Scopes</a>. Otherwise,
the bean is created only when it is requested. Creation of a bean potentially causes a
graph of beans to be created, as the bean&#8217;s dependencies and its dependencies'
dependencies (and so on) are created and assigned. Note that resolution mismatches among
those dependencies may show up late&#8201;&#8212;&#8201;that is, on first creation of the affected bean.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Circular dependencies</div>
<div class="paragraph">
<p>If you use predominantly constructor injection, it is possible to create an unresolvable
circular dependency scenario.</p>
</div>
<div class="paragraph">
<p>For example: Class A requires an instance of class B through constructor injection, and
class B requires an instance of class A through constructor injection. If you configure
beans for classes A and B to be injected into each other, the Spring IoC container
detects this circular reference at runtime, and throws a
<code>BeanCurrentlyInCreationException</code>.</p>
</div>
<div class="paragraph">
<p>One possible solution is to edit the source code of some classes to be configured by
setters rather than constructors. Alternatively, avoid constructor injection and use
setter injection only. In other words, although it is not recommended, you can configure
circular dependencies with setter injection.</p>
</div>
<div class="paragraph">
<p>Unlike the typical case (with no circular dependencies), a circular dependency
between bean A and bean B forces one of the beans to be injected into the other prior to
being fully initialized itself (a classic chicken-and-egg scenario).</p>
</div>
</div>
</div>
<div class="paragraph">
<p>You can generally trust Spring to do the right thing. It detects configuration problems,
such as references to non-existent beans and circular dependencies, at container
load-time. Spring sets properties and resolves dependencies as late as possible, when
the bean is actually created. This means that a Spring container that has loaded
correctly can later generate an exception when you request an object if there is a
problem creating that object or one of its dependencies&#8201;&#8212;&#8201;for example, the bean throws an
exception as a result of a missing or invalid property. This potentially delayed
visibility of some configuration issues is why <code>ApplicationContext</code> implementations by
default pre-instantiate singleton beans. At the cost of some upfront time and memory to
create these beans before they are actually needed, you discover configuration issues
when the <code>ApplicationContext</code> is created, not later. You can still override this default
behavior so that singleton beans initialize lazily, rather than being eagerly
pre-instantiated.</p>
</div>
<div class="paragraph">
<p>If no circular dependencies exist, when one or more collaborating beans are being
injected into a dependent bean, each collaborating bean is totally configured prior
to being injected into the dependent bean. This means that, if bean A has a dependency on
bean B, the Spring IoC container completely configures bean B prior to invoking the
setter method on bean A. In other words, the bean is instantiated (if it is not a
pre-instantiated singleton), its dependencies are set, and the relevant lifecycle
methods (such as a <a href="#beans-factory-lifecycle-initializingbean">configured init method</a>
or the <a href="#beans-factory-lifecycle-initializingbean">InitializingBean callback method</a>)
are invoked.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-some-examples"><a class="anchor" href="#beans-some-examples"></a>Examples of Dependency Injection</h5>
<div class="paragraph">
<p>The following example uses XML-based configuration metadata for setter-based DI. A small
part of a Spring XML configuration file specifies some bean definitions as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
    &lt;!-- setter injection using the nested ref element --&gt;
    &lt;property name="beanOne"&gt;
        &lt;ref bean="anotherExampleBean"/&gt;
    &lt;/property&gt;

    &lt;!-- setter injection using the neater ref attribute --&gt;
    &lt;property name="beanTwo" ref="yetAnotherBean"/&gt;
    &lt;property name="integerProperty" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the corresponding <code>ExampleBean</code> class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class ExampleBean {

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }

    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }

    public void setIntegerProperty(int i) {
        this.i = i;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class ExampleBean {
    lateinit var beanOne: AnotherBean
    lateinit var beanTwo: YetAnotherBean
    var i: Int = 0
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, setters are declared to match against the properties specified
in the XML file. The following example uses constructor-based DI:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
    &lt;!-- constructor injection using the nested ref element --&gt;
    &lt;constructor-arg&gt;
        &lt;ref bean="anotherExampleBean"/&gt;
    &lt;/constructor-arg&gt;

    &lt;!-- constructor injection using the neater ref attribute --&gt;
    &lt;constructor-arg ref="yetAnotherBean"/&gt;

    &lt;constructor-arg type="int" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the corresponding <code>ExampleBean</code> class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class ExampleBean {

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public ExampleBean(
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        this.beanOne = anotherBean;
        this.beanTwo = yetAnotherBean;
        this.i = i;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">class ExampleBean(
        private val beanOne: AnotherBean,
        private val beanTwo: YetAnotherBean,
        private val i: Int)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The constructor arguments specified in the bean definition are used as arguments to
the constructor of the <code>ExampleBean</code>.</p>
</div>
<div class="paragraph">
<p>Now consider a variant of this example, where, instead of using a constructor, Spring is
told to call a <code>static</code> factory method to return an instance of the object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="exampleBean" class="examples.ExampleBean" factory-method="createInstance"&gt;
    &lt;constructor-arg ref="anotherExampleBean"/&gt;
    &lt;constructor-arg ref="yetAnotherBean"/&gt;
    &lt;constructor-arg value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the corresponding <code>ExampleBean</code> class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class ExampleBean {

    // a private constructor
    private ExampleBean(...) {
        ...
    }

    // a static factory method; the arguments to this method can be
    // considered the dependencies of the bean that is returned,
    // regardless of how those arguments are actually used.
    public static ExampleBean createInstance (
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {

        ExampleBean eb = new ExampleBean (...);
        // some other operations...
        return eb;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class ExampleBean private constructor() {
    companion object {
        // a static factory method; the arguments to this method can be
        // considered the dependencies of the bean that is returned,
        // regardless of how those arguments are actually used.
        fun createInstance(anotherBean: AnotherBean, yetAnotherBean: YetAnotherBean, i: Int): ExampleBean {
            val eb = ExampleBean (...)
            // some other operations...
            return eb
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Arguments to the <code>static</code> factory method are supplied by <code>&lt;constructor-arg/&gt;</code> elements,
exactly the same as if a constructor had actually been used. The type of the class being
returned by the factory method does not have to be of the same type as the class that
contains the <code>static</code> factory method (although, in this example, it is). An instance
(non-static) factory method can be used in an essentially identical fashion (aside
from the use of the <code>factory-bean</code> attribute instead of the <code>class</code> attribute), so we
do not discuss those details here.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-properties-detailed"><a class="anchor" href="#beans-factory-properties-detailed"></a>1.4.2. Dependencies and Configuration in Detail</h4>
<div class="paragraph">
<p>As mentioned in the <a href="#beans-factory-collaborators">previous section</a>, you can define bean
properties and constructor arguments as references to other managed beans (collaborators)
or as values defined inline. Spring&#8217;s XML-based configuration metadata supports
sub-element types within its <code>&lt;property/&gt;</code> and <code>&lt;constructor-arg/&gt;</code> elements for this
purpose.</p>
</div>
<div class="sect4">
<h5 id="beans-value-element"><a class="anchor" href="#beans-value-element"></a>Straight Values (Primitives, Strings, and so on)</h5>
<div class="paragraph">
<p>The <code>value</code> attribute of the <code>&lt;property/&gt;</code> element specifies a property or constructor
argument as a human-readable string representation. Spring&#8217;s
<a href="#core-convert-ConversionService-API">conversion service</a> is used to convert these
values from a <code>String</code> to the actual type of the property or argument.
The following example shows various values being set:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;!-- results in a setDriverClassName(String) call --&gt;
    &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt;
    &lt;property name="url" value="jdbc:mysql://localhost:3306/mydb"/&gt;
    &lt;property name="username" value="root"/&gt;
    &lt;property name="password" value="misterkaoli"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example uses the <a href="#beans-p-namespace">p-namespace</a> for even more succinct
XML configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource"
        destroy-method="close"
        p:driverClassName="com.mysql.jdbc.Driver"
        p:url="jdbc:mysql://localhost:3306/mydb"
        p:username="root"
        p:password="misterkaoli"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding XML is more succinct. However, typos are discovered at runtime rather than
design time, unless you use an IDE (such as <a href="https://www.jetbrains.com/idea/">IntelliJ
IDEA</a> or the <a href="https://spring.io/tools">Spring Tools for Eclipse</a>)
that supports automatic property completion when you create bean definitions. Such IDE
assistance is highly recommended.</p>
</div>
<div class="paragraph">
<p>You can also configure a <code>java.util.Properties</code> instance, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="mappings"
    class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer"&gt;

    &lt;!-- typed as a java.util.Properties --&gt;
    &lt;property name="properties"&gt;
        &lt;value&gt;
            jdbc.driver.className=com.mysql.jdbc.Driver
            jdbc.url=jdbc:mysql://localhost:3306/mydb
        &lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Spring container converts the text inside the <code>&lt;value/&gt;</code> element into a
<code>java.util.Properties</code> instance by using the JavaBeans <code>PropertyEditor</code> mechanism. This
is a nice shortcut, and is one of a few places where the Spring team do favor the use of
the nested <code>&lt;value/&gt;</code> element over the <code>value</code> attribute style.</p>
</div>
<div class="sect5">
<h6 id="beans-idref-element"><a class="anchor" href="#beans-idref-element"></a>The <code>idref</code> element</h6>
<div class="paragraph">
<p>The <code>idref</code> element is simply an error-proof way to pass the <code>id</code> (a string value - not
a reference) of another bean in the container to a <code>&lt;constructor-arg/&gt;</code> or <code>&lt;property/&gt;</code>
element. The following example shows how to use it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="theTargetBean" class="..."/&gt;

&lt;bean id="theClientBean" class="..."&gt;
    &lt;property name="targetName"&gt;
        &lt;idref bean="theTargetBean"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding bean definition snippet is exactly equivalent (at runtime) to the
following snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="theTargetBean" class="..." /&gt;

&lt;bean id="client" class="..."&gt;
    &lt;property name="targetName" value="theTargetBean"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first form is preferable to the second, because using the <code>idref</code> tag lets the
container validate at deployment time that the referenced, named bean actually
exists. In the second variation, no validation is performed on the value that is passed
to the <code>targetName</code> property of the <code>client</code> bean. Typos are only discovered (with most
likely fatal results) when the <code>client</code> bean is actually instantiated. If the <code>client</code>
bean is a <a href="#beans-factory-scopes">prototype</a> bean, this typo and the resulting exception
may only be discovered long after the container is deployed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>local</code> attribute on the <code>idref</code> element is no longer supported in the 4.0 beans
XSD, since it does not provide value over a regular <code>bean</code> reference any more. Change
your existing <code>idref local</code> references to <code>idref bean</code> when upgrading to the 4.0 schema.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A common place (at least in versions earlier than Spring 2.0) where the <code>&lt;idref/&gt;</code> element
brings value is in the configuration of <a href="#aop-pfb-1">AOP interceptors</a> in a
<code>ProxyFactoryBean</code> bean definition. Using <code>&lt;idref/&gt;</code> elements when you specify the
interceptor names prevents you from misspelling an interceptor ID.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-ref-element"><a class="anchor" href="#beans-ref-element"></a>References to Other Beans (Collaborators)</h5>
<div class="paragraph">
<p>The <code>ref</code> element is the final element inside a <code>&lt;constructor-arg/&gt;</code> or <code>&lt;property/&gt;</code>
definition element. Here, you set the value of the specified property of a bean to be a
reference to another bean (a collaborator) managed by the container. The referenced bean
is a dependency of the bean whose property is to be set, and it is initialized on demand
as needed before the property is set. (If the collaborator is a singleton bean, it may
already be initialized by the container.) All references are ultimately a reference to
another object. Scoping and validation depend on whether you specify the ID or name of the
other object through the <code>bean</code> or <code>parent</code> attribute.</p>
</div>
<div class="paragraph">
<p>Specifying the target bean through the <code>bean</code> attribute of the <code>&lt;ref/&gt;</code> tag is the most
general form and allows creation of a reference to any bean in the same container or
parent container, regardless of whether it is in the same XML file. The value of the
<code>bean</code> attribute may be the same as the <code>id</code> attribute of the target bean or be the same
as one of the values in the <code>name</code> attribute of the target bean. The following example
shows how to use a <code>ref</code> element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;ref bean="someBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Specifying the target bean through the <code>parent</code> attribute creates a reference to a bean
that is in a parent container of the current container. The value of the <code>parent</code>
attribute may be the same as either the <code>id</code> attribute of the target bean or one of the
values in the <code>name</code> attribute of the target bean. The target bean must be in a
parent container of the current one. You should use this bean reference variant mainly
when you have a hierarchy of containers and you want to wrap an existing bean in a parent
container with a proxy that has the same name as the parent bean. The following pair of
listings shows how to use the <code>parent</code> attribute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- in the parent context --&gt;
&lt;bean id="accountService" class="com.something.SimpleAccountService"&gt;
    &lt;!-- insert dependencies as required as here --&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- in the child (descendant) context --&gt;
&lt;bean id="accountService" &lt;!-- bean name is the same as the parent bean --&gt;
    class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="target"&gt;
        &lt;ref parent="accountService"/&gt; &lt;!-- notice how we refer to the parent bean --&gt;
    &lt;/property&gt;
    &lt;!-- insert other configuration and dependencies as required here --&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>local</code> attribute on the <code>ref</code> element is no longer supported in the 4.0 beans
XSD, since it does not provide value over a regular <code>bean</code> reference any more. Change
your existing <code>ref local</code> references to <code>ref bean</code> when upgrading to the 4.0 schema.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-inner-beans"><a class="anchor" href="#beans-inner-beans"></a>Inner Beans</h5>
<div class="paragraph">
<p>A <code>&lt;bean/&gt;</code> element inside the <code>&lt;property/&gt;</code> or <code>&lt;constructor-arg/&gt;</code> elements defines an
inner bean, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="outer" class="..."&gt;
    &lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;
    &lt;property name="target"&gt;
        &lt;bean class="com.example.Person"&gt; &lt;!-- this is the inner bean --&gt;
            &lt;property name="name" value="Fiona Apple"/&gt;
            &lt;property name="age" value="25"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>An inner bean definition does not require a defined ID or name. If specified, the container
does not use such a value as an identifier. The container also ignores the <code>scope</code> flag on
creation, because inner beans are always anonymous and are always created with the outer
bean. It is not possible to access inner beans independently or to inject them into
collaborating beans other than into the enclosing bean.</p>
</div>
<div class="paragraph">
<p>As a corner case, it is possible to receive destruction callbacks from a custom scope&#8201;&#8212;&#8201;for example, for a request-scoped inner bean contained within a singleton bean. The creation
of the inner bean instance is tied to its containing bean, but destruction callbacks let it
participate in the request scope&#8217;s lifecycle. This is not a common scenario. Inner beans
typically simply share their containing bean&#8217;s scope.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-collection-elements"><a class="anchor" href="#beans-collection-elements"></a>Collections</h5>
<div class="paragraph">
<p>The <code>&lt;list/&gt;</code>, <code>&lt;set/&gt;</code>, <code>&lt;map/&gt;</code>, and <code>&lt;props/&gt;</code> elements set the properties
and arguments of the Java <code>Collection</code> types <code>List</code>, <code>Set</code>, <code>Map</code>, and <code>Properties</code>,
respectively. The following example shows how to use them:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="moreComplexObject" class="example.ComplexObject"&gt;
    &lt;!-- results in a setAdminEmails(java.util.Properties) call --&gt;
    &lt;property name="adminEmails"&gt;
        &lt;props&gt;
            &lt;prop key="administrator"&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="58393c353136312b2c2a392c372a183d20393528343d76372a3f">[email&#160;protected]</a>&lt;/prop&gt;
            &lt;prop key="support"&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e4979194948b9690a4819c8589948881ca8b9683">[email&#160;protected]</a>&lt;/prop&gt;
            &lt;prop key="development"&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5d39382b3831322d303833291d38253c302d313873322f3a">[email&#160;protected]</a>&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeList(java.util.List) call --&gt;
    &lt;property name="someList"&gt;
        &lt;list&gt;
            &lt;value&gt;a list element followed by a reference&lt;/value&gt;
            &lt;ref bean="myDataSource" /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeMap(java.util.Map) call --&gt;
    &lt;property name="someMap"&gt;
        &lt;map&gt;
            &lt;entry key="an entry" value="just some string"/&gt;
            &lt;entry key ="a ref" value-ref="myDataSource"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;!-- results in a setSomeSet(java.util.Set) call --&gt;
    &lt;property name="someSet"&gt;
        &lt;set&gt;
            &lt;value&gt;just some string&lt;/value&gt;
            &lt;ref bean="myDataSource" /&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value of a map key or value, or a set value, can also be any of the
following elements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">bean | ref | idref | list | set | map | props | value | null</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="beans-collection-elements-merging"><a class="anchor" href="#beans-collection-elements-merging"></a>Collection Merging</h6>
<div class="paragraph">
<p>The Spring container also supports merging collections. An application
developer can define a parent <code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>, <code>&lt;set/&gt;</code> or <code>&lt;props/&gt;</code> element
and have child <code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>, <code>&lt;set/&gt;</code> or <code>&lt;props/&gt;</code> elements inherit and
override values from the parent collection. That is, the child collection&#8217;s values are
the result of merging the elements of the parent and child collections, with the child&#8217;s
collection elements overriding values specified in the parent collection.</p>
</div>
<div class="paragraph">
<p>This section on merging discusses the parent-child bean mechanism. Readers unfamiliar
with parent and child bean definitions may wish to read the
<a href="#beans-child-bean-definitions">relevant section</a> before continuing.</p>
</div>
<div class="paragraph">
<p>The following example demonstrates collection merging:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;bean id="parent" abstract="true" class="example.ComplexObject"&gt;
        &lt;property name="adminEmails"&gt;
            &lt;props&gt;
                &lt;prop key="administrator"&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0d6c69606463647e797f6c79627f4d68756c607d6168236e6260">[email&#160;protected]</a>&lt;/prop&gt;
                &lt;prop key="support"&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="3c4f494c4c534e487c59445d514c5059125f5351">[email&#160;protected]</a>&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id="child" parent="parent"&gt;
        &lt;property name="adminEmails"&gt;
            &lt;!-- the merge is specified on the child collection definition --&gt;
            &lt;props merge="true"&gt;
                &lt;prop key="sales"&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0d7e6c61687e4d68756c607d6168236e6260">[email&#160;protected]</a>&lt;/prop&gt;
                &lt;prop key="support"&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="3e4d4b4e4e514c4a7e5b465f534e525b105d51104b55">[email&#160;protected]</a>&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice the use of the <code>merge=true</code> attribute on the <code>&lt;props/&gt;</code> element of the
<code>adminEmails</code> property of the <code>child</code> bean definition. When the <code>child</code> bean is resolved
and instantiated by the container, the resulting instance has an <code>adminEmails</code>
<code>Properties</code> collection that contains the result of merging the child&#8217;s
<code>adminEmails</code> collection with the parent&#8217;s <code>adminEmails</code> collection. The following listing
shows the result:</p>
</div>
<div class="literalblock">
<div class="content">
<pre><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="48292c252126213b3c3a293c273a75292c252126213b3c3a293c273a082d30292538242d662b2725">[email&#160;protected]</a>
<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ec9f8d80899fd19f8d80899fac89948d819c8089c28f8381">[email&#160;protected]</a>
<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="63101613130c11175e101613130c111723061b020e130f064d000c4d1608">[email&#160;protected]</a></pre>
</div>
</div>
<div class="paragraph">
<p>The child <code>Properties</code> collection&#8217;s value set inherits all property elements from the
parent <code>&lt;props/&gt;</code>, and the child&#8217;s value for the <code>support</code> value overrides the value in
the parent collection.</p>
</div>
<div class="paragraph">
<p>This merging behavior applies similarly to the <code>&lt;list/&gt;</code>, <code>&lt;map/&gt;</code>, and <code>&lt;set/&gt;</code>
collection types. In the specific case of the <code>&lt;list/&gt;</code> element, the semantics
associated with the <code>List</code> collection type (that is, the notion of an <code>ordered</code>
collection of values) is maintained. The parent&#8217;s values precede all of the child list&#8217;s
values. In the case of the <code>Map</code>, <code>Set</code>, and <code>Properties</code> collection types, no ordering
exists. Hence, no ordering semantics are in effect for the collection types that underlie
the associated <code>Map</code>, <code>Set</code>, and <code>Properties</code> implementation types that the container
uses internally.</p>
</div>
</div>
<div class="sect5">
<h6 id="beans-collection-merge-limitations"><a class="anchor" href="#beans-collection-merge-limitations"></a>Limitations of Collection Merging</h6>
<div class="paragraph">
<p>You cannot merge different collection types (such as a <code>Map</code> and a <code>List</code>). If you
do attempt to do so, an appropriate <code>Exception</code> is thrown. The <code>merge</code> attribute must be
specified on the lower, inherited, child definition. Specifying the <code>merge</code> attribute on
a parent collection definition is redundant and does not result in the desired merging.</p>
</div>
</div>
<div class="sect5">
<h6 id="beans-collection-elements-strongly-typed"><a class="anchor" href="#beans-collection-elements-strongly-typed"></a>Strongly-typed collection</h6>
<div class="paragraph">
<p>With the introduction of generic types in Java 5, you can use strongly typed collections.
That is, it is possible to declare a <code>Collection</code> type such that it can only contain
(for example) <code>String</code> elements. If you use Spring to dependency-inject a
strongly-typed <code>Collection</code> into a bean, you can take advantage of Spring&#8217;s
type-conversion support such that the elements of your strongly-typed <code>Collection</code>
instances are converted to the appropriate type prior to being added to the <code>Collection</code>.
The following Java class and bean definition show how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class SomeClass {

    private Map&lt;String, Float&gt; accounts;

    public void setAccounts(Map&lt;String, Float&gt; accounts) {
        this.accounts = accounts;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class SomeClass {
    lateinit var accounts: Map&lt;String, Float&gt;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;bean id="something" class="x.y.SomeClass"&gt;
        &lt;property name="accounts"&gt;
            &lt;map&gt;
                &lt;entry key="one" value="9.99"/&gt;
                &lt;entry key="two" value="2.75"/&gt;
                &lt;entry key="six" value="3.99"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the <code>accounts</code> property of the <code>something</code> bean is prepared for injection, the generics
information about the element type of the strongly-typed <code>Map&lt;String, Float&gt;</code> is
available by reflection. Thus, Spring&#8217;s type conversion infrastructure recognizes the
various value elements as being of type <code>Float</code>, and the string values (<code>9.99, 2.75</code>, and
<code>3.99</code>) are converted into an actual <code>Float</code> type.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-null-element"><a class="anchor" href="#beans-null-element"></a>Null and Empty String Values</h5>
<div class="paragraph">
<p>Spring treats empty arguments for properties and the like as empty <code>Strings</code>. The
following XML-based configuration metadata snippet sets the <code>email</code> property to the empty
<code>String</code> value ("").</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean class="ExampleBean"&gt;
    &lt;property name="email" value=""/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example is equivalent to the following Java code:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">exampleBean.setEmail("");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">exampleBean.email = ""</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>&lt;null/&gt;</code> element handles <code>null</code> values. The following listing shows an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean class="ExampleBean"&gt;
    &lt;property name="email"&gt;
        &lt;null/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration is equivalent to the following Java code:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">exampleBean.setEmail(null);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">exampleBean.email = null</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-p-namespace"><a class="anchor" href="#beans-p-namespace"></a>XML Shortcut with the p-namespace</h5>
<div class="paragraph">
<p>The p-namespace lets you use the <code>bean</code> element&#8217;s attributes (instead of nested
<code>&lt;property/&gt;</code> elements) to describe your property values collaborating beans, or both.</p>
</div>
<div class="paragraph">
<p>Spring supports extensible configuration formats <a href="#xsd-schemas">with namespaces</a>,
which are based on an XML Schema definition. The <code>beans</code> configuration format discussed in
this chapter is defined in an XML Schema document. However, the p-namespace is not defined
in an XSD file and exists only in the core of Spring.</p>
</div>
<div class="paragraph">
<p>The following example shows two XML snippets (the first uses
standard XML format and the second uses the p-namespace) that resolve to the same result:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean name="classic" class="com.example.ExampleBean"&gt;
        &lt;property name="email" value="<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="681b07050d07060d281b07050d1f000d1a0d460b0705">[email&#160;protected]</a>"/&gt;
    &lt;/bean&gt;

    &lt;bean name="p-namespace" class="com.example.ExampleBean"
        p:email="<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="582b37353d37363d182b37353d2f303d2a3d763b3735">[email&#160;protected]</a>"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example shows an attribute in the p-namespace called <code>email</code> in the bean definition.
This tells Spring to include a property declaration. As previously mentioned, the
p-namespace does not have a schema definition, so you can set the name of the attribute
to the property name.</p>
</div>
<div class="paragraph">
<p>This next example includes two more bean definitions that both have a reference to
another bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean name="john-classic" class="com.example.Person"&gt;
        &lt;property name="name" value="John Doe"/&gt;
        &lt;property name="spouse" ref="jane"/&gt;
    &lt;/bean&gt;

    &lt;bean name="john-modern"
        class="com.example.Person"
        p:name="John Doe"
        p:spouse-ref="jane"/&gt;

    &lt;bean name="jane" class="com.example.Person"&gt;
        &lt;property name="name" value="Jane Doe"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example includes not only a property value using the p-namespace
but also uses a special format to declare property references. Whereas the first bean
definition uses <code>&lt;property name="spouse" ref="jane"/&gt;</code> to create a reference from bean
<code>john</code> to bean <code>jane</code>, the second bean definition uses <code>p:spouse-ref="jane"</code> as an
attribute to do the exact same thing. In this case, <code>spouse</code> is the property name,
whereas the <code>-ref</code> part indicates that this is not a straight value but rather a
reference to another bean.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The p-namespace is not as flexible as the standard XML format. For example, the format
for declaring property references clashes with properties that end in <code>Ref</code>, whereas the
standard XML format does not. We recommend that you choose your approach carefully and
communicate this to your team members to avoid producing XML documents that use all
three approaches at the same time.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-c-namespace"><a class="anchor" href="#beans-c-namespace"></a>XML Shortcut with the c-namespace</h5>
<div class="paragraph">
<p>Similar to the <a href="#beans-p-namespace">XML Shortcut with the p-namespace</a>, the c-namespace, introduced in Spring
3.1, allows inlined attributes for configuring the constructor arguments rather
then nested <code>constructor-arg</code> elements.</p>
</div>
<div class="paragraph">
<p>The following example uses the <code>c:</code> namespace to do the same thing as the from
<a href="#beans-constructor-injection">Constructor-based Dependency Injection</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:c="http://www.springframework.org/schema/c"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean id="beanTwo" class="x.y.ThingTwo"/&gt;
    &lt;bean id="beanThree" class="x.y.ThingThree"/&gt;

    &lt;!-- traditional declaration with optional argument names --&gt;
    &lt;bean id="beanOne" class="x.y.ThingOne"&gt;
        &lt;constructor-arg name="thingTwo" ref="beanTwo"/&gt;
        &lt;constructor-arg name="thingThree" ref="beanThree"/&gt;
        &lt;constructor-arg name="email" value="<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="62110d0f07160a0b0c0522110d0f07150a0710074c010d0f">[email&#160;protected]</a>"/&gt;
    &lt;/bean&gt;

    &lt;!-- c-namespace declaration with argument names --&gt;
    &lt;bean id="beanOne" class="x.y.ThingOne" c:thingTwo-ref="beanTwo"
        c:thingThree-ref="beanThree" c:email="<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5625393b33223e3f38311625393b33213e3324337835393b">[email&#160;protected]</a>"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>c:</code> namespace uses the same conventions as the <code>p:</code> one (a trailing <code>-ref</code> for
bean references) for setting the constructor arguments by their names. Similarly,
it needs to be declared in the XML file even though it is not defined in an XSD schema
(it exists inside the Spring core).</p>
</div>
<div class="paragraph">
<p>For the rare cases where the constructor argument names are not available (usually if
the bytecode was compiled without debugging information), you can use fallback to the
argument indexes, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- c-namespace index declaration --&gt;
&lt;bean id="beanOne" class="x.y.ThingOne" c:_0-ref="beanTwo" c:_1-ref="beanThree"
    c:_2="<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9eedf1f3fbeaf6f7f0f9deedf1f3fbe9f6fbecfbb0fdf1f3">[email&#160;protected]</a>"/&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Due to the XML grammar, the index notation requires the presence of the leading <code>_</code>,
as XML attribute names cannot start with a number (even though some IDEs allow it).
A corresponding index notation is also available for <code>&lt;constructor-arg&gt;</code> elements but
not commonly used since the plain order of declaration is usually sufficient there.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In practice, the constructor resolution
<a href="#beans-factory-ctor-arguments-resolution">mechanism</a> is quite efficient in matching
arguments, so unless you really need to, we recommend using the name notation
through-out your configuration.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-compound-property-names"><a class="anchor" href="#beans-compound-property-names"></a>Compound Property Names</h5>
<div class="paragraph">
<p>You can use compound or nested property names when you set bean properties, as long as
all components of the path except the final property name are not <code>null</code>. Consider the
following bean definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="something" class="things.ThingOne"&gt;
    &lt;property name="fred.bob.sammy" value="123" /&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>something</code> bean has a <code>fred</code> property, which has a <code>bob</code> property, which has a <code>sammy</code>
property, and that final <code>sammy</code> property is being set to a value of <code>123</code>. In order for
this to work, the <code>fred</code> property of <code>something</code> and the <code>bob</code> property of <code>fred</code> must not
be <code>null</code> after the bean is constructed. Otherwise, a <code>NullPointerException</code> is thrown.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-dependson"><a class="anchor" href="#beans-factory-dependson"></a>1.4.3. Using <code>depends-on</code></h4>
<div class="paragraph">
<p>If a bean is a dependency of another bean, that usually means that one bean is set as a
property of another. Typically you accomplish this with the <a href="#beans-ref-element"><code>&lt;ref/&gt;</code>
element</a> in XML-based configuration metadata. However, sometimes dependencies between
beans are less direct. An example is when a static initializer in a class needs to be
triggered, such as for database driver registration. The <code>depends-on</code> attribute can
explicitly force one or more beans to be initialized before the bean using this element
is initialized. The following example uses the <code>depends-on</code> attribute to express a
dependency on a single bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="beanOne" class="ExampleBean" depends-on="manager"/&gt;
&lt;bean id="manager" class="ManagerBean" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To express a dependency on multiple beans, supply a list of bean names as the value of
the <code>depends-on</code> attribute (commas, whitespace, and semicolons are valid
delimiters):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao"&gt;
    &lt;property name="manager" ref="manager" /&gt;
&lt;/bean&gt;

&lt;bean id="manager" class="ManagerBean" /&gt;
&lt;bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" /&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>depends-on</code> attribute can specify both an initialization-time dependency and,
in the case of <a href="#beans-factory-scopes-singleton">singleton</a> beans only, a corresponding
destruction-time dependency. Dependent beans that define a <code>depends-on</code> relationship
with a given bean are destroyed first, prior to the given bean itself being destroyed.
Thus, <code>depends-on</code> can also control shutdown order.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-lazy-init"><a class="anchor" href="#beans-factory-lazy-init"></a>1.4.4. Lazy-initialized Beans</h4>
<div class="paragraph">
<p>By default, <code>ApplicationContext</code> implementations eagerly create and configure all
<a href="#beans-factory-scopes-singleton">singleton</a> beans as part of the initialization
process. Generally, this pre-instantiation is desirable, because errors in the
configuration or surrounding environment are discovered immediately, as opposed to hours
or even days later. When this behavior is not desirable, you can prevent
pre-instantiation of a singleton bean by marking the bean definition as being
lazy-initialized. A lazy-initialized bean tells the IoC container to create a bean
instance when it is first requested, rather than at startup.</p>
</div>
<div class="paragraph">
<p>In XML, this behavior is controlled by the <code>lazy-init</code> attribute on the <code>&lt;bean/&gt;</code>
element, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="lazy" class="com.something.ExpensiveToCreateBean" lazy-init="true"/&gt;
&lt;bean name="not.lazy" class="com.something.AnotherBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the preceding configuration is consumed by an <code>ApplicationContext</code>, the <code>lazy</code> bean
is not eagerly pre-instantiated when the <code>ApplicationContext</code> starts,
whereas the <code>not.lazy</code> bean is eagerly pre-instantiated.</p>
</div>
<div class="paragraph">
<p>However, when a lazy-initialized bean is a dependency of a singleton bean that is
not lazy-initialized, the <code>ApplicationContext</code> creates the lazy-initialized bean at
startup, because it must satisfy the singleton&#8217;s dependencies. The lazy-initialized bean
is injected into a singleton bean elsewhere that is not lazy-initialized.</p>
</div>
<div class="paragraph">
<p>You can also control lazy-initialization at the container level by using the
<code>default-lazy-init</code> attribute on the <code>&lt;beans/&gt;</code> element, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans default-lazy-init="true"&gt;
    &lt;!-- no beans will be pre-instantiated... --&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-autowire"><a class="anchor" href="#beans-factory-autowire"></a>1.4.5. Autowiring Collaborators</h4>
<div class="paragraph">
<p>The Spring container can autowire relationships between collaborating beans. You can
let Spring resolve collaborators (other beans) automatically for your bean by
inspecting the contents of the <code>ApplicationContext</code>. Autowiring has the following
advantages:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Autowiring can significantly reduce the need to specify properties or constructor
arguments. (Other mechanisms such as a bean template
<a href="#beans-child-bean-definitions">discussed elsewhere in this chapter</a> are also valuable
in this regard.)</p>
</li>
<li>
<p>Autowiring can update a configuration as your objects evolve. For example, if you need
to add a dependency to a class, that dependency can be satisfied automatically without
you needing to modify the configuration. Thus autowiring can be especially useful
during development, without negating the option of switching to explicit wiring when
the code base becomes more stable.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When using XML-based configuration metadata (see <a href="#beans-factory-collaborators">Dependency Injection</a>), you
can specify the autowire mode for a bean definition with the <code>autowire</code> attribute of the
<code>&lt;bean/&gt;</code> element. The autowiring functionality has four modes. You specify autowiring
per bean and can thus choose which ones to autowire. The following table describes the
four autowiring modes:</p>
</div>
<table id="beans-factory-autowiring-modes-tbl" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Autowiring modes</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Mode</th>
<th class="tableblock halign-left valign-top">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>no</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(Default) No autowiring. Bean references must be defined by <code>ref</code> elements. Changing
the default setting is not recommended for larger deployments, because specifying
collaborators explicitly gives greater control and clarity. To some extent, it
documents the structure of a system.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>byName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Autowiring by property name. Spring looks for a bean with the same name as the
property that needs to be autowired. For example, if a bean definition is set to
autowire by name and it contains a <code>master</code> property (that is, it has a
<code>setMaster(..)</code> method), Spring looks for a bean definition named <code>master</code> and uses
it to set the property.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>byType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Lets a property be autowired if exactly one bean of the property type exists in
the container. If more than one exists, a fatal exception is thrown, which indicates
that you may not use <code>byType</code> autowiring for that bean. If there are no matching
beans, nothing happens (the property is not set).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>constructor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Analogous to <code>byType</code> but applies to constructor arguments. If there is not exactly
one bean of the constructor argument type in the container, a fatal error is raised.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>With <code>byType</code> or <code>constructor</code> autowiring mode, you can wire arrays and
typed collections. In such cases, all autowire candidates within the container that
match the expected type are provided to satisfy the dependency. You can autowire
strongly-typed <code>Map</code> instances if the expected key type is <code>String</code>. An autowired <code>Map</code>
instance&#8217;s values consist of all bean instances that match the expected type, and the
<code>Map</code> instance&#8217;s keys contain the corresponding bean names.</p>
</div>
<div class="sect4">
<h5 id="beans-autowired-exceptions"><a class="anchor" href="#beans-autowired-exceptions"></a>Limitations and Disadvantages of Autowiring</h5>
<div class="paragraph">
<p>Autowiring works best when it is used consistently across a project. If autowiring is
not used in general, it might be confusing to developers to use it to wire only one or
two bean definitions.</p>
</div>
<div class="paragraph">
<p>Consider the limitations and disadvantages of autowiring:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Explicit dependencies in <code>property</code> and <code>constructor-arg</code> settings always override
autowiring. You cannot autowire simple properties such as primitives,
<code>Strings</code>, and <code>Classes</code> (and arrays of such simple properties). This limitation is
by-design.</p>
</li>
<li>
<p>Autowiring is less exact than explicit wiring. Although, as noted in the earlier table,
Spring is careful to avoid guessing in case of ambiguity that might have unexpected
results. The relationships between your Spring-managed objects are no longer
documented explicitly.</p>
</li>
<li>
<p>Wiring information may not be available to tools that may generate documentation from
a Spring container.</p>
</li>
<li>
<p>Multiple bean definitions within the container may match the type specified by the
setter method or constructor argument to be autowired. For arrays, collections, or
<code>Map</code> instances, this is not necessarily a problem. However, for dependencies that
expect a single value, this ambiguity is not arbitrarily resolved. If no unique bean
definition is available, an exception is thrown.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the latter scenario, you have several options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Abandon autowiring in favor of explicit wiring.</p>
</li>
<li>
<p>Avoid autowiring for a bean definition by setting its <code>autowire-candidate</code> attributes
to <code>false</code>, as described in the <a href="#beans-factory-autowire-candidate">next section</a>.</p>
</li>
<li>
<p>Designate a single bean definition as the primary candidate by setting the
<code>primary</code> attribute of its <code>&lt;bean/&gt;</code> element to <code>true</code>.</p>
</li>
<li>
<p>Implement the more fine-grained control available with annotation-based configuration,
as described in <a href="#beans-annotation-config">Annotation-based Container Configuration</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-autowire-candidate"><a class="anchor" href="#beans-factory-autowire-candidate"></a>Excluding a Bean from Autowiring</h5>
<div class="paragraph">
<p>On a per-bean basis, you can exclude a bean from autowiring. In Spring&#8217;s XML format, set
the <code>autowire-candidate</code> attribute of the <code>&lt;bean/&gt;</code> element to <code>false</code>. The container
makes that specific bean definition unavailable to the autowiring infrastructure
(including annotation style configurations such as <a href="#beans-autowired-annotation"><code>@Autowired</code></a>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>autowire-candidate</code> attribute is designed to only affect type-based autowiring.
It does not affect explicit references by name, which get resolved even if the
specified bean is not marked as an autowire candidate. As a consequence, autowiring
by name nevertheless injects a bean if the name matches.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also limit autowire candidates based on pattern-matching against bean names. The
top-level <code>&lt;beans/&gt;</code> element accepts one or more patterns within its
<code>default-autowire-candidates</code> attribute. For example, to limit autowire candidate status
to any bean whose name ends with <code>Repository</code>, provide a value of <code>*Repository</code>. To
provide multiple patterns, define them in a comma-separated list. An explicit value of
<code>true</code> or <code>false</code> for a bean definition&#8217;s <code>autowire-candidate</code> attribute always takes
precedence. For such beans, the pattern matching rules do not apply.</p>
</div>
<div class="paragraph">
<p>These techniques are useful for beans that you never want to be injected into other
beans by autowiring. It does not mean that an excluded bean cannot itself be configured by
using autowiring. Rather, the bean itself is not a candidate for autowiring other beans.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-method-injection"><a class="anchor" href="#beans-factory-method-injection"></a>1.4.6. Method Injection</h4>
<div class="paragraph">
<p>In most application scenarios, most beans in the container are
<a href="#beans-factory-scopes-singleton">singletons</a>. When a singleton bean needs to
collaborate with another singleton bean or a non-singleton bean needs to collaborate
with another non-singleton bean, you typically handle the dependency by defining one
bean as a property of the other. A problem arises when the bean lifecycles are
different. Suppose singleton bean A needs to use non-singleton (prototype) bean B,
perhaps on each method invocation on A. The container creates the singleton bean A only
once, and thus only gets one opportunity to set the properties. The container cannot
provide bean A with a new instance of bean B every time one is needed.</p>
</div>
<div class="paragraph">
<p>A solution is to forego some inversion of control. You can <a href="#beans-factory-aware">make
bean A aware of the container</a> by implementing the <code>ApplicationContextAware</code> interface,
and by <a href="#beans-factory-client">making a <code>getBean("B")</code> call to the container</a> ask for (a
typically new) bean B instance every time bean A needs it. The following example
shows this approach:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// a class that uses a stateful Command-style class to perform some processing
package fiona.apple;

// Spring-API imports
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class CommandManager implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    public Object process(Map commandState) {
        // grab a new instance of the appropriate Command
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    protected Command createCommand() {
        // notice the Spring API dependency!
        return this.applicationContext.getBean("command", Command.class);
    }

    public void setApplicationContext(
            ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// a class that uses a stateful Command-style class to perform some processing
package fiona.apple

// Spring-API imports
import org.springframework.context.ApplicationContext
import org.springframework.context.ApplicationContextAware

class CommandManager : ApplicationContextAware {

    private lateinit var applicationContext: ApplicationContext

    fun process(commandState: Map&lt;*, *&gt;): Any {
        // grab a new instance of the appropriate Command
        val command = createCommand()
        // set the state on the (hopefully brand new) Command instance
        command.state = commandState
        return command.execute()
    }

    // notice the Spring API dependency!
    protected fun createCommand() =
            applicationContext.getBean("command", Command::class.java)

    override fun setApplicationContext(applicationContext: ApplicationContext) {
        this.applicationContext = applicationContext
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding is not desirable, because the business code is aware of and coupled to the
Spring Framework. Method Injection, a somewhat advanced feature of the Spring IoC
container, lets you handle this use case cleanly.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>You can read more about the motivation for Method Injection in
<a href="https://spring.io/blog/2004/08/06/method-injection/">this blog entry</a>.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lookup-method-injection"><a class="anchor" href="#beans-factory-lookup-method-injection"></a>Lookup Method Injection</h5>
<div class="paragraph">
<p>Lookup method injection is the ability of the container to override methods on
container-managed beans and return the lookup result for another named bean in the
container. The lookup typically involves a prototype bean, as in the scenario described
in <a href="#beans-factory-method-injection">the preceding section</a>. The Spring Framework
implements this method injection by using bytecode generation from the CGLIB library to
dynamically generate a subclass that overrides the method.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p>For this dynamic subclassing to work, the class that the Spring bean container
subclasses cannot be <code>final</code>, and the method to be overridden cannot be <code>final</code>, either.</p>
</li>
<li>
<p>Unit-testing a class that has an <code>abstract</code> method requires you to subclass the class
yourself and to supply a stub implementation of the <code>abstract</code> method.</p>
</li>
<li>
<p>Concrete methods are also necessary for component scanning, which requires concrete
classes to pick up.</p>
</li>
<li>
<p>A further key limitation is that lookup methods do not work with factory methods and
in particular not with <code>@Bean</code> methods in configuration classes, since, in that case,
the container is not in charge of creating the instance and therefore cannot create
a runtime-generated subclass on the fly.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the case of the <code>CommandManager</code> class in the previous code snippet, the
Spring container dynamically overrides the implementation of the <code>createCommand()</code>
method. The <code>CommandManager</code> class does not have any Spring dependencies, as
the reworked example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package fiona.apple;

// no more Spring imports!

public abstract class CommandManager {

    public Object process(Object commandState) {
        // grab a new instance of the appropriate Command interface
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    // okay... but where is the implementation of this method?
    protected abstract Command createCommand();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package fiona.apple

// no more Spring imports!

abstract class CommandManager {

    fun process(commandState: Any): Any {
        // grab a new instance of the appropriate Command interface
        val command = createCommand()
        // set the state on the (hopefully brand new) Command instance
        command.state = commandState
        return command.execute()
    }

    // okay... but where is the implementation of this method?
    protected abstract fun createCommand(): Command
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the client class that contains the method to be injected (the <code>CommandManager</code> in this
case), the method to be injected requires a signature of the following form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(no-arguments);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the method is <code>abstract</code>, the dynamically-generated subclass implements the method.
Otherwise, the dynamically-generated subclass overrides the concrete method defined in
the original class. Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;
&lt;bean id="myCommand" class="fiona.apple.AsyncCommand" scope="prototype"&gt;
    &lt;!-- inject dependencies here as required --&gt;
&lt;/bean&gt;

&lt;!-- commandProcessor uses statefulCommandHelper --&gt;
&lt;bean id="commandManager" class="fiona.apple.CommandManager"&gt;
    &lt;lookup-method name="createCommand" bean="myCommand"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The bean identified as <code>commandManager</code> calls its own <code>createCommand()</code> method
whenever it needs a new instance of the <code>myCommand</code> bean. You must be careful to deploy
the <code>myCommand</code> bean as a prototype if that is actually what is needed. If it is
a <a href="#beans-factory-scopes-singleton">singleton</a>, the same instance of the <code>myCommand</code>
bean is returned each time.</p>
</div>
<div class="paragraph">
<p>Alternatively, within the annotation-based component model, you can declare a lookup
method through the <code>@Lookup</code> annotation, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public abstract class CommandManager {

    public Object process(Object commandState) {
        Command command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup("myCommand")
    protected abstract Command createCommand();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">abstract class CommandManager {

    fun process(commandState: Any): Any {
        val command = createCommand()
        command.state = commandState
        return command.execute()
    }

    @Lookup("myCommand")
    protected abstract fun createCommand(): Command
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or, more idiomatically, you can rely on the target bean getting resolved against the
declared return type of the lookup method:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public abstract class CommandManager {

    public Object process(Object commandState) {
        MyCommand command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup
    protected abstract MyCommand createCommand();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">abstract class CommandManager {

    fun process(commandState: Any): Any {
        val command = createCommand()
        command.state = commandState
        return command.execute()
    }

    @Lookup
    protected abstract fun createCommand(): Command
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that you should typically declare such annotated lookup methods with a concrete
stub implementation, in order for them to be compatible with Spring&#8217;s component
scanning rules where abstract classes get ignored by default. This limitation does not
apply to explicitly registered or explicitly imported bean classes.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Another way of accessing differently scoped target beans is an <code>ObjectFactory</code>/
<code>Provider</code> injection point. See <a href="#beans-factory-scopes-other-injection">Scoped Beans as Dependencies</a>.</p>
</div>
<div class="paragraph">
<p>You may also find the <code>ServiceLocatorFactoryBean</code> (in the
<code>org.springframework.beans.factory.config</code> package) to be useful.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-arbitrary-method-replacement"><a class="anchor" href="#beans-factory-arbitrary-method-replacement"></a>Arbitrary Method Replacement</h5>
<div class="paragraph">
<p>A less useful form of method injection than lookup method injection is the ability to
replace arbitrary methods in a managed bean with another method implementation. You
can safely skip the rest of this section until you actually need this functionality.</p>
</div>
<div class="paragraph">
<p>With XML-based configuration metadata, you can use the <code>replaced-method</code> element to
replace an existing method implementation with another, for a deployed bean. Consider
the following class, which has a method called <code>computeValue</code> that we want to override:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class MyValueCalculator {

    public String computeValue(String input) {
        // some real code...
    }

    // some other methods...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class MyValueCalculator {

    fun computeValue(input: String): String {
        // some real code...
    }

    // some other methods...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A class that implements the <code>org.springframework.beans.factory.support.MethodReplacer</code>
interface provides the new method definition, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">/**
 * meant to be used to override the existing computeValue(String)
 * implementation in MyValueCalculator
 */
public class ReplacementComputeValue implements MethodReplacer {

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
        // get the input value, work with it, and return a computed result
        String input = (String) args[0];
        ...
        return ...;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">/**
* meant to be used to override the existing computeValue(String)
* implementation in MyValueCalculator
*/
class ReplacementComputeValue : MethodReplacer {

    override fun reimplement(obj: Any, method: Method, args: Array&lt;out Any&gt;): Any {
        // get the input value, work with it, and return a computed result
        val input = args[0] as String;
        ...
        return ...;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The bean definition to deploy the original class and specify the method override would
resemble the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="myValueCalculator" class="x.y.z.MyValueCalculator"&gt;
    &lt;!-- arbitrary method replacement --&gt;
    &lt;replaced-method name="computeValue" replacer="replacementComputeValue"&gt;
        &lt;arg-type&gt;String&lt;/arg-type&gt;
    &lt;/replaced-method&gt;
&lt;/bean&gt;

&lt;bean id="replacementComputeValue" class="a.b.c.ReplacementComputeValue"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use one or more <code>&lt;arg-type/&gt;</code> elements within the <code>&lt;replaced-method/&gt;</code>
element to indicate the method signature of the method being overridden. The signature
for the arguments is necessary only if the method is overloaded and multiple variants
exist within the class. For convenience, the type string for an argument may be a
substring of the fully qualified type name. For example, the following all match
<code>java.lang.String</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">java.lang.String
String
Str</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because the number of arguments is often enough to distinguish between each possible
choice, this shortcut can save a lot of typing, by letting you type only the
shortest string that matches an argument type.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-factory-scopes"><a class="anchor" href="#beans-factory-scopes"></a>1.5. Bean Scopes</h3>
<div class="paragraph">
<p>When you create a bean definition, you create a recipe for creating actual instances
of the class defined by that bean definition. The idea that a bean definition is a
recipe is important, because it means that, as with a class, you can create many object
instances from a single recipe.</p>
</div>
<div class="paragraph">
<p>You can control not only the various dependencies and configuration values that are to
be plugged into an object that is created from a particular bean definition but also control
the scope of the objects created from a particular bean definition. This approach is
powerful and flexible, because you can choose the scope of the objects you create
through configuration instead of having to bake in the scope of an object at the Java
class level. Beans can be defined to be deployed in one of a number of scopes.
The Spring Framework supports six scopes, four of which are available only if
you use a web-aware <code>ApplicationContext</code>. You can also create
<a href="#beans-factory-scopes-custom">a custom scope.</a></p>
</div>
<div class="paragraph">
<p>The following table describes the supported scopes:</p>
</div>
<table id="beans-factory-scopes-tbl" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. Bean scopes</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Scope</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-singleton">singleton</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">(Default) Scopes a single bean definition to a single object instance for each Spring IoC
container.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-prototype">prototype</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Scopes a single bean definition to any number of object instances.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-request">request</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Scopes a single bean definition to the lifecycle of a single HTTP request. That is,
each HTTP request has its own instance of a bean created off the back of a single bean
definition. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-session">session</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Scopes a single bean definition to the lifecycle of an HTTP <code>Session</code>. Only valid in
the context of a web-aware Spring <code>ApplicationContext</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-scopes-application">application</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Scopes a single bean definition to the lifecycle of a <code>ServletContext</code>. Only valid in
the context of a web-aware Spring <code>ApplicationContext</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="web.html#websocket-stomp-websocket-scope">websocket</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Scopes a single bean definition to the lifecycle of a <code>WebSocket</code>. Only valid in
the context of a web-aware Spring <code>ApplicationContext</code>.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As of Spring 3.0, a thread scope is available but is not registered by default. For
more information, see the documentation for
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/context/support/SimpleThreadScope.html"><code>SimpleThreadScope</code></a>.
For instructions on how to register this or any other custom scope, see
<a href="#beans-factory-scopes-custom-using">Using a Custom Scope</a>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-singleton"><a class="anchor" href="#beans-factory-scopes-singleton"></a>1.5.1. The Singleton Scope</h4>
<div class="paragraph">
<p>Only one shared instance of a singleton bean is managed, and all requests for beans
with an ID or IDs that match that bean definition result in that one specific bean
instance being returned by the Spring container.</p>
</div>
<div class="paragraph">
<p>To put it another way, when you define a bean definition and it is scoped as a
singleton, the Spring IoC container creates exactly one instance of the object
defined by that bean definition. This single instance is stored in a cache of such
singleton beans, and all subsequent requests and references for that named bean
return the cached object. The following image shows how the singleton scope works:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/singleton.png" alt="singleton">
</div>
</div>
<div class="paragraph">
<p>Spring&#8217;s concept of a singleton bean differs from the singleton pattern as defined in
the Gang of Four (GoF) patterns book. The GoF singleton hard-codes the scope of an
object such that one and only one instance of a particular class is created per
ClassLoader. The scope of the Spring singleton is best described as being per-container
and per-bean. This means that, if you define one bean for a particular class in a
single Spring container, the Spring container creates one and only one instance
of the class defined by that bean definition. The singleton scope is the default scope
in Spring. To define a bean as a singleton in XML, you can define a bean as shown in the
following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="accountService" class="com.something.DefaultAccountService"/&gt;

&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;
&lt;bean id="accountService" class="com.something.DefaultAccountService" scope="singleton"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-prototype"><a class="anchor" href="#beans-factory-scopes-prototype"></a>1.5.2. The Prototype Scope</h4>
<div class="paragraph">
<p>The non-singleton prototype scope of bean deployment results in the creation of a new
bean instance every time a request for that specific bean is made. That is, the bean
is injected into another bean or you request it through a <code>getBean()</code> method call on the
container. As a rule, you should use the prototype scope for all stateful beans and the
singleton scope for stateless beans.</p>
</div>
<div class="paragraph">
<p>The following diagram illustrates the Spring prototype scope:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/prototype.png" alt="prototype">
</div>
</div>
<div class="paragraph">
<p>(A data access object
(DAO) is not typically configured as a prototype, because a typical DAO does not hold
any conversational state. It was easier for us to reuse the core of the
singleton diagram.)</p>
</div>
<div class="paragraph">
<p>The following example defines a bean as a prototype in XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="accountService" class="com.something.DefaultAccountService" scope="prototype"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In contrast to the other scopes, Spring does not manage the complete lifecycle of a
prototype bean. The container instantiates, configures, and otherwise assembles a
prototype object and hands it to the client, with no further record of that prototype
instance. Thus, although initialization lifecycle callback methods are called on all
objects regardless of scope, in the case of prototypes, configured destruction
lifecycle callbacks are not called. The client code must clean up prototype-scoped
objects and release expensive resources that the prototype beans hold. To get
the Spring container to release resources held by prototype-scoped beans, try using a
custom <a href="#beans-factory-extension-bpp">bean post-processor</a>, which holds a reference to
beans that need to be cleaned up.</p>
</div>
<div class="paragraph">
<p>In some respects, the Spring container&#8217;s role in regard to a prototype-scoped bean is a
replacement for the Java <code>new</code> operator. All lifecycle management past that point must
be handled by the client. (For details on the lifecycle of a bean in the Spring
container, see <a href="#beans-factory-lifecycle">Lifecycle Callbacks</a>.)</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-sing-prot-interaction"><a class="anchor" href="#beans-factory-scopes-sing-prot-interaction"></a>1.5.3. Singleton Beans with Prototype-bean Dependencies</h4>
<div class="paragraph">
<p>When you use singleton-scoped beans with dependencies on prototype beans, be aware that
dependencies are resolved at instantiation time. Thus, if you dependency-inject a
prototype-scoped bean into a singleton-scoped bean, a new prototype bean is instantiated
and then dependency-injected into the singleton bean. The prototype instance is the sole
instance that is ever supplied to the singleton-scoped bean.</p>
</div>
<div class="paragraph">
<p>However, suppose you want the singleton-scoped bean to acquire a new instance of the
prototype-scoped bean repeatedly at runtime. You cannot dependency-inject a
prototype-scoped bean into your singleton bean, because that injection occurs only
once, when the Spring container instantiates the singleton bean and resolves
and injects its dependencies. If you need a new instance of a prototype bean at
runtime more than once, see <a href="#beans-factory-method-injection">Method Injection</a></p>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-other"><a class="anchor" href="#beans-factory-scopes-other"></a>1.5.4. Request, Session, Application, and WebSocket Scopes</h4>
<div class="paragraph">
<p>The <code>request</code>, <code>session</code>, <code>application</code>, and <code>websocket</code> scopes are available only
if you use a web-aware Spring <code>ApplicationContext</code> implementation (such as
<code>XmlWebApplicationContext</code>). If you use these scopes with regular Spring IoC containers,
such as the <code>ClassPathXmlApplicationContext</code>, an <code>IllegalStateException</code> that complains
about an unknown bean scope is thrown.</p>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-other-web-configuration"><a class="anchor" href="#beans-factory-scopes-other-web-configuration"></a>Initial Web Configuration</h5>
<div class="paragraph">
<p>To support the scoping of beans at the <code>request</code>, <code>session</code>, <code>application</code>, and
<code>websocket</code> levels (web-scoped beans), some minor initial configuration is
required before you define your beans. (This initial setup is not required
for the standard scopes: <code>singleton</code> and <code>prototype</code>.)</p>
</div>
<div class="paragraph">
<p>How you accomplish this initial setup depends on your particular Servlet environment.</p>
</div>
<div class="paragraph">
<p>If you access scoped beans within Spring Web MVC, in effect, within a request that is
processed by the Spring <code>DispatcherServlet</code>, no special setup is necessary.
<code>DispatcherServlet</code> already exposes all relevant state.</p>
</div>
<div class="paragraph">
<p>If you use a Servlet 2.5 web container, with requests processed outside of Spring&#8217;s
<code>DispatcherServlet</code> (for example, when using JSF or Struts), you need to register the
<code>org.springframework.web.context.request.RequestContextListener</code> <code>ServletRequestListener</code>.
For Servlet 3.0+, this can be done programmatically by using the <code>WebApplicationInitializer</code>
interface. Alternatively, or for older containers, add the following declaration to
your web application&#8217;s <code>web.xml</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;web-app&gt;
    ...
    &lt;listener&gt;
        &lt;listener-class&gt;
            org.springframework.web.context.request.RequestContextListener
        &lt;/listener-class&gt;
    &lt;/listener&gt;
    ...
&lt;/web-app&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, if there are issues with your listener setup, consider using Spring&#8217;s
<code>RequestContextFilter</code>. The filter mapping depends on the surrounding web
application configuration, so you have to change it as appropriate. The following listing
shows the filter part of a web application:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;web-app&gt;
    ...
    &lt;filter&gt;
        &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.RequestContextFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    ...
&lt;/web-app&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DispatcherServlet</code>, <code>RequestContextListener</code>, and <code>RequestContextFilter</code> all do exactly
the same thing, namely bind the HTTP request object to the <code>Thread</code> that is servicing
that request. This makes beans that are request- and session-scoped available further
down the call chain.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-request"><a class="anchor" href="#beans-factory-scopes-request"></a>Request scope</h5>
<div class="paragraph">
<p>Consider the following XML configuration for a bean definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="loginAction" class="com.something.LoginAction" scope="request"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Spring container creates a new instance of the <code>LoginAction</code> bean by using the
<code>loginAction</code> bean definition for each and every HTTP request. That is, the
<code>loginAction</code> bean is scoped at the HTTP request level. You can change the internal
state of the instance that is created as much as you want, because other instances
created from the same <code>loginAction</code> bean definition do not see these changes in state.
They are particular to an individual request. When the request completes processing, the
bean that is scoped to the request is discarded.</p>
</div>
<div class="paragraph">
<p>When using annotation-driven components or Java configuration, the <code>@RequestScope</code> annotation
can be used to assign a component to the <code>request</code> scope. The following example shows how
to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@RequestScope
@Component
public class LoginAction {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@RequestScope
@Component
class LoginAction {
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-session"><a class="anchor" href="#beans-factory-scopes-session"></a>Session Scope</h5>
<div class="paragraph">
<p>Consider the following XML configuration for a bean definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="userPreferences" class="com.something.UserPreferences" scope="session"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Spring container creates a new instance of the <code>UserPreferences</code> bean by using the
<code>userPreferences</code> bean definition for the lifetime of a single HTTP <code>Session</code>. In other
words, the <code>userPreferences</code> bean is effectively scoped at the HTTP <code>Session</code> level. As
with request-scoped beans, you can change the internal state of the instance that is
created as much as you want, knowing that other HTTP <code>Session</code> instances that are also
using instances created from the same <code>userPreferences</code> bean definition do not see these
changes in state, because they are particular to an individual HTTP <code>Session</code>. When the
HTTP <code>Session</code> is eventually discarded, the bean that is scoped to that particular HTTP
<code>Session</code> is also discarded.</p>
</div>
<div class="paragraph">
<p>When using annotation-driven components or Java configuration, you can use the
<code>@SessionScope</code> annotation to assign a component to the <code>session</code> scope.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@SessionScope
@Component
public class UserPreferences {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@SessionScope
@Component
class UserPreferences {
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-application"><a class="anchor" href="#beans-factory-scopes-application"></a>Application Scope</h5>
<div class="paragraph">
<p>Consider the following XML configuration for a bean definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="appPreferences" class="com.something.AppPreferences" scope="application"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Spring container creates a new instance of the <code>AppPreferences</code> bean by using the
<code>appPreferences</code> bean definition once for the entire web application. That is, the
<code>appPreferences</code> bean is scoped at the <code>ServletContext</code> level and stored as a regular
<code>ServletContext</code> attribute. This is somewhat similar to a Spring singleton bean but
differs in two important ways: It is a singleton per <code>ServletContext</code>, not per Spring
'ApplicationContext' (for which there may be several in any given web application),
and it is actually exposed and therefore visible as a <code>ServletContext</code> attribute.</p>
</div>
<div class="paragraph">
<p>When using annotation-driven components or Java configuration, you can use the
<code>@ApplicationScope</code> annotation to assign a component to the <code>application</code> scope. The
following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@ApplicationScope
@Component
public class AppPreferences {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@ApplicationScope
@Component
class AppPreferences {
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-other-injection"><a class="anchor" href="#beans-factory-scopes-other-injection"></a>Scoped Beans as Dependencies</h5>
<div class="paragraph">
<p>The Spring IoC container manages not only the instantiation of your objects (beans),
but also the wiring up of collaborators (or dependencies). If you want to inject (for
example) an HTTP request-scoped bean into another bean of a longer-lived scope, you may
choose to inject an AOP proxy in place of the scoped bean. That is, you need to inject
a proxy object that exposes the same public interface as the scoped object but that can
also retrieve the real target object from the relevant scope (such as an HTTP request)
and delegate method calls onto the real object.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You may also use <code>&lt;aop:scoped-proxy/&gt;</code> between beans that are scoped as <code>singleton</code>,
with the reference then going through an intermediate proxy that is serializable
and therefore able to re-obtain the target singleton bean on deserialization.</p>
</div>
<div class="paragraph">
<p>When declaring <code>&lt;aop:scoped-proxy/&gt;</code> against a bean of scope <code>prototype</code>, every method
call on the shared proxy leads to the creation of a new target instance to which the
call is then being forwarded.</p>
</div>
<div class="paragraph">
<p>Also, scoped proxies are not the only way to access beans from shorter scopes in a
lifecycle-safe fashion. You may also declare your injection point (that is, the
constructor or setter argument or autowired field) as <code>ObjectFactory&lt;MyTargetBean&gt;</code>,
allowing for a <code>getObject()</code> call to retrieve the current instance on demand every
time it is needed&#8201;&#8212;&#8201;without holding on to the instance or storing it separately.</p>
</div>
<div class="paragraph">
<p>As an extended variant, you may declare <code>ObjectProvider&lt;MyTargetBean&gt;</code>, which delivers
several additional access variants, including <code>getIfAvailable</code> and <code>getIfUnique</code>.</p>
</div>
<div class="paragraph">
<p>The JSR-330 variant of this is called <code>Provider</code> and is used with a <code>Provider&lt;MyTargetBean&gt;</code>
declaration and a corresponding <code>get()</code> call for every retrieval attempt.
See <a href="#beans-standard-annotations">here</a> for more details on JSR-330 overall.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The configuration in the following example is only one line, but it is important to
understand the &#8220;why&#8221; as well as the &#8220;how&#8221; behind it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;!-- an HTTP Session-scoped bean exposed as a proxy --&gt;
    &lt;bean id="userPreferences" class="com.something.UserPreferences" scope="session"&gt;
        &lt;!-- instructs the container to proxy the surrounding bean --&gt;
        &lt;aop:scoped-proxy/&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;/bean&gt;

    &lt;!-- a singleton-scoped bean injected with a proxy to the above bean --&gt;
    &lt;bean id="userService" class="com.something.SimpleUserService"&gt;
        &lt;!-- a reference to the proxied userPreferences bean --&gt;
        &lt;property name="userPreferences" ref="userPreferences"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The line that defines the proxy.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To create such a proxy, you insert a child <code>&lt;aop:scoped-proxy/&gt;</code> element into a scoped
bean definition (see <a href="#beans-factory-scopes-other-injection-proxies">Choosing the Type of Proxy to Create</a> and
<a href="#xsd-schemas">XML Schema-based configuration</a>).
Why do definitions of beans scoped at the <code>request</code>, <code>session</code> and custom-scope
levels require the <code>&lt;aop:scoped-proxy/&gt;</code> element?
Consider the following singleton bean definition and contrast it with
what you need to define for the aforementioned scopes (note that the following
<code>userPreferences</code> bean definition as it stands is incomplete):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="userPreferences" class="com.something.UserPreferences" scope="session"/&gt;

&lt;bean id="userManager" class="com.something.UserManager"&gt;
    &lt;property name="userPreferences" ref="userPreferences"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the singleton bean (<code>userManager</code>) is injected with a reference
to the HTTP <code>Session</code>-scoped bean (<code>userPreferences</code>). The salient point here is that the
<code>userManager</code> bean is a singleton: it is instantiated exactly once per
container, and its dependencies (in this case only one, the <code>userPreferences</code> bean) are
also injected only once. This means that the <code>userManager</code> bean operates only on the
exact same <code>userPreferences</code> object (that is, the one with which it was originally injected.</p>
</div>
<div class="paragraph">
<p>This is not the behavior you want when injecting a shorter-lived scoped bean into a
longer-lived scoped bean (for example, injecting an HTTP <code>Session</code>-scoped collaborating
bean as a dependency into singleton bean). Rather, you need a single <code>userManager</code>
object, and, for the lifetime of an HTTP <code>Session</code>, you need a <code>userPreferences</code> object
that is specific to the HTTP <code>Session</code>. Thus, the container creates an object that
exposes the exact same public interface as the <code>UserPreferences</code> class (ideally an
object that is a <code>UserPreferences</code> instance), which can fetch the real
<code>UserPreferences</code> object from the scoping mechanism (HTTP request, <code>Session</code>, and so
forth). The container injects this proxy object into the <code>userManager</code> bean, which is
unaware that this <code>UserPreferences</code> reference is a proxy. In this example, when a
<code>UserManager</code> instance invokes a method on the dependency-injected <code>UserPreferences</code>
object, it is actually invoking a method on the proxy. The proxy then fetches the real
<code>UserPreferences</code> object from (in this case) the HTTP <code>Session</code> and delegates the
method invocation onto the retrieved real <code>UserPreferences</code> object.</p>
</div>
<div class="paragraph">
<p>Thus, you need the following (correct and complete) configuration when injecting
<code>request-</code> and <code>session-scoped</code> beans into collaborating objects, as the following example
shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="userPreferences" class="com.something.UserPreferences" scope="session"&gt;
    &lt;aop:scoped-proxy/&gt;
&lt;/bean&gt;

&lt;bean id="userManager" class="com.something.UserManager"&gt;
    &lt;property name="userPreferences" ref="userPreferences"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="beans-factory-scopes-other-injection-proxies"><a class="anchor" href="#beans-factory-scopes-other-injection-proxies"></a>Choosing the Type of Proxy to Create</h6>
<div class="paragraph">
<p>By default, when the Spring container creates a proxy for a bean that is marked up with
the <code>&lt;aop:scoped-proxy/&gt;</code> element, a CGLIB-based class proxy is created.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>CGLIB proxies intercept only public method calls! Do not call non-public methods
on such a proxy. They are not delegated to the actual scoped target object.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Alternatively, you can configure the Spring container to create standard JDK
interface-based proxies for such scoped beans, by specifying <code>false</code> for the value of
the <code>proxy-target-class</code> attribute of the <code>&lt;aop:scoped-proxy/&gt;</code> element. Using JDK
interface-based proxies means that you do not need additional libraries in your
application classpath to affect such proxying. However, it also means that the class of
the scoped bean must implement at least one interface and that all collaborators
into which the scoped bean is injected must reference the bean through one of its
interfaces. The following example shows a proxy based on an interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- DefaultUserPreferences implements the UserPreferences interface --&gt;
&lt;bean id="userPreferences" class="com.stuff.DefaultUserPreferences" scope="session"&gt;
    &lt;aop:scoped-proxy proxy-target-class="false"/&gt;
&lt;/bean&gt;

&lt;bean id="userManager" class="com.stuff.UserManager"&gt;
    &lt;property name="userPreferences" ref="userPreferences"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For more detailed information about choosing class-based or interface-based proxying,
see <a href="#aop-proxying">Proxying Mechanisms</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-scopes-custom"><a class="anchor" href="#beans-factory-scopes-custom"></a>1.5.5. Custom Scopes</h4>
<div class="paragraph">
<p>The bean scoping mechanism is extensible. You can define your own
scopes or even redefine existing scopes, although the latter is considered bad practice
and you cannot override the built-in <code>singleton</code> and <code>prototype</code> scopes.</p>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-custom-creating"><a class="anchor" href="#beans-factory-scopes-custom-creating"></a>Creating a Custom Scope</h5>
<div class="paragraph">
<p>To integrate your custom scopes into the Spring container, you need to implement the
<code>org.springframework.beans.factory.config.Scope</code> interface, which is described in this
section. For an idea of how to implement your own scopes, see the <code>Scope</code>
implementations that are supplied with the Spring Framework itself and the
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/beans/factory/config/Scope.html"><code>Scope</code></a> javadoc,
which explains the methods you need to implement in more detail.</p>
</div>
<div class="paragraph">
<p>The <code>Scope</code> interface has four methods to get objects from the scope, remove them from
the scope, and let them be destroyed.</p>
</div>
<div class="paragraph">
<p>The session scope implementation, for example, returns the session-scoped bean (if it
does not exist, the method returns a new instance of the bean, after having bound it to
the session for future reference). The following method returns the object from the
underlying scope:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Object get(String name, ObjectFactory&lt;?&gt; objectFactory)</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun get(name: String, objectFactory: ObjectFactory&lt;*&gt;): Any</code></pre>
</div>
</div>
<div class="paragraph">
<p>The session scope implementation, for example, removes the session-scoped bean from the
underlying session. The object should be returned, but you can return <code>null</code> if the
object with the specified name is not found. The following method removes the object from
the underlying scope:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Object remove(String name)</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun remove(name: String): Any</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following method registers a callback that the scope should invoke when it is
destroyed or when the specified object in the scope is destroyed:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">void registerDestructionCallback(String name, Runnable destructionCallback)</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun registerDestructionCallback(name: String, destructionCallback: Runnable)</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/beans/factory/config/Scope.html#registerDestructionCallback">javadoc</a>
or a Spring scope implementation for more information on destruction callbacks.</p>
</div>
<div class="paragraph">
<p>The following method obtains the conversation identifier for the underlying scope:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">String getConversationId()</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun getConversationId(): String</code></pre>
</div>
</div>
<div class="paragraph">
<p>This identifier is different for each scope. For a session scoped implementation, this
identifier can be the session identifier.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-scopes-custom-using"><a class="anchor" href="#beans-factory-scopes-custom-using"></a>Using a Custom Scope</h5>
<div class="paragraph">
<p>After you write and test one or more custom <code>Scope</code> implementations, you need to make
the Spring container aware of your new scopes. The following method is the central
method to register a new <code>Scope</code> with the Spring container:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">void registerScope(String scopeName, Scope scope);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun registerScope(scopeName: String, scope: Scope)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This method is declared on the <code>ConfigurableBeanFactory</code> interface, which is available
through the <code>BeanFactory</code> property on most of the concrete <code>ApplicationContext</code>
implementations that ship with Spring.</p>
</div>
<div class="paragraph">
<p>The first argument to the <code>registerScope(..)</code> method is the unique name associated with
a scope. Examples of such names in the Spring container itself are <code>singleton</code> and
<code>prototype</code>. The second argument to the <code>registerScope(..)</code> method is an actual instance
of the custom <code>Scope</code> implementation that you wish to register and use.</p>
</div>
<div class="paragraph">
<p>Suppose that you write your custom <code>Scope</code> implementation, and then register it as shown
in the next example.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The next example uses <code>SimpleThreadScope</code>, which is included with Spring but is not
registered by default. The instructions would be the same for your own custom <code>Scope</code>
implementations.
</td>
</tr>
</table>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Scope threadScope = new SimpleThreadScope();
beanFactory.registerScope("thread", threadScope);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val threadScope = SimpleThreadScope()
beanFactory.registerScope("thread", threadScope)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can then create bean definitions that adhere to the scoping rules of your custom
<code>Scope</code>, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="..." class="..." scope="thread"&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>With a custom <code>Scope</code> implementation, you are not limited to programmatic registration
of the scope. You can also do the <code>Scope</code> registration declaratively, by using the
<code>CustomScopeConfigurer</code> class, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;bean class="org.springframework.beans.factory.config.CustomScopeConfigurer"&gt;
        &lt;property name="scopes"&gt;
            &lt;map&gt;
                &lt;entry key="thread"&gt;
                    &lt;bean class="org.springframework.context.support.SimpleThreadScope"/&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="thing2" class="x.y.Thing2" scope="thread"&gt;
        &lt;property name="name" value="Rick"/&gt;
        &lt;aop:scoped-proxy/&gt;
    &lt;/bean&gt;

    &lt;bean id="thing1" class="x.y.Thing1"&gt;
        &lt;property name="thing2" ref="thing2"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When you place <code>&lt;aop:scoped-proxy/&gt;</code> within a <code>&lt;bean&gt;</code> declaration for a
<code>FactoryBean</code> implementation, it is the factory bean itself that is scoped, not the object
returned from <code>getObject()</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-factory-nature"><a class="anchor" href="#beans-factory-nature"></a>1.6. Customizing the Nature of a Bean</h3>
<div class="paragraph">
<p>The Spring Framework provides a number of interfaces you can use to customize the nature
of a bean. This section groups them as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#beans-factory-lifecycle">Lifecycle Callbacks</a></p>
</li>
<li>
<p><a href="#beans-factory-aware"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></p>
</li>
<li>
<p><a href="#aware-list">Other <code>Aware</code> Interfaces</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="beans-factory-lifecycle"><a class="anchor" href="#beans-factory-lifecycle"></a>1.6.1. Lifecycle Callbacks</h4>
<div class="paragraph">
<p>To interact with the container&#8217;s management of the bean lifecycle, you can implement
the Spring <code>InitializingBean</code> and <code>DisposableBean</code> interfaces. The container calls
<code>afterPropertiesSet()</code> for the former and <code>destroy()</code> for the latter to let the bean
perform certain actions upon initialization and destruction of your beans.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The JSR-250 <code>@PostConstruct</code> and <code>@PreDestroy</code> annotations are generally considered best
practice for receiving lifecycle callbacks in a modern Spring application. Using these
annotations means that your beans are not coupled to Spring-specific interfaces.
For details, see <a href="#beans-postconstruct-and-predestroy-annotations">Using <code>@PostConstruct</code> and <code>@PreDestroy</code></a>.</p>
</div>
<div class="paragraph">
<p>If you do not want to use the JSR-250 annotations but you still want to remove
coupling, consider <code>init-method</code> and <code>destroy-method</code> bean definition metadata.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Internally, the Spring Framework uses <code>BeanPostProcessor</code> implementations to process any
callback interfaces it can find and call the appropriate methods. If you need custom
features or other lifecycle behavior Spring does not by default offer, you can
implement a <code>BeanPostProcessor</code> yourself. For more information, see
<a href="#beans-factory-extension">Container Extension Points</a>.</p>
</div>
<div class="paragraph">
<p>In addition to the initialization and destruction callbacks, Spring-managed objects may
also implement the <code>Lifecycle</code> interface so that those objects can participate in the
startup and shutdown process, as driven by the container&#8217;s own lifecycle.</p>
</div>
<div class="paragraph">
<p>The lifecycle callback interfaces are described in this section.</p>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-initializingbean"><a class="anchor" href="#beans-factory-lifecycle-initializingbean"></a>Initialization Callbacks</h5>
<div class="paragraph">
<p>The <code>org.springframework.beans.factory.InitializingBean</code> interface lets a bean
perform initialization work after the container has set all necessary properties on the
bean. The <code>InitializingBean</code> interface specifies a single method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">void afterPropertiesSet() throws Exception;</code></pre>
</div>
</div>
<div class="paragraph">
<p>We recommend that you do not use the <code>InitializingBean</code> interface, because it
unnecessarily couples the code to Spring. Alternatively, we suggest using
the <a href="#beans-postconstruct-and-predestroy-annotations"><code>@PostConstruct</code></a> annotation or
specifying a POJO initialization method. In the case of XML-based configuration metadata,
you can use the <code>init-method</code> attribute to specify the name of the method that has a void
no-argument signature. With Java configuration, you can use the <code>initMethod</code> attribute of
<code>@Bean</code>. See <a href="#beans-java-lifecycle-callbacks">Receiving Lifecycle Callbacks</a>. Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/&gt;</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class ExampleBean {

    public void init() {
        // do some initialization work
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class ExampleBean {

    fun init() {
        // do some initialization work
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example has almost exactly the same effect as the following example
(which consists of two listings):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="exampleInitBean" class="examples.AnotherExampleBean"/&gt;</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class AnotherExampleBean implements InitializingBean {

    @Override
    public void afterPropertiesSet() {
        // do some initialization work
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class AnotherExampleBean : InitializingBean {

    override fun afterPropertiesSet() {
        // do some initialization work
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, the first of the two preceding examples does not couple the code to Spring.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-disposablebean"><a class="anchor" href="#beans-factory-lifecycle-disposablebean"></a>Destruction Callbacks</h5>
<div class="paragraph">
<p>Implementing the <code>org.springframework.beans.factory.DisposableBean</code> interface lets a
bean get a callback when the container that contains it is destroyed. The
<code>DisposableBean</code> interface specifies a single method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">void destroy() throws Exception;</code></pre>
</div>
</div>
<div class="paragraph">
<p>We recommend that you do not use the <code>DisposableBean</code> callback interface, because it
unnecessarily couples the code to Spring. Alternatively, we suggest using
the <a href="#beans-postconstruct-and-predestroy-annotations"><code>@PreDestroy</code></a> annotation or
specifying a generic method that is supported by bean definitions. With XML-based
configuration metadata, you can use the <code>destroy-method</code> attribute on the <code>&lt;bean/&gt;</code>.
With Java configuration, you can use the <code>destroyMethod</code> attribute of <code>@Bean</code>. See
<a href="#beans-java-lifecycle-callbacks">Receiving Lifecycle Callbacks</a>. Consider the following definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/&gt;</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class ExampleBean {

    public void cleanup() {
        // do some destruction work (like releasing pooled connections)
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class ExampleBean {

    fun cleanup() {
        // do some destruction work (like releasing pooled connections)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding definition has almost exactly the same effect as the following definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="exampleInitBean" class="examples.AnotherExampleBean"/&gt;</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class AnotherExampleBean implements DisposableBean {

    @Override
    public void destroy() {
        // do some destruction work (like releasing pooled connections)
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class AnotherExampleBean : DisposableBean {

    override fun destroy() {
        // do some destruction work (like releasing pooled connections)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, the first of the two preceding definitions does not couple the code to Spring.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can assign the <code>destroy-method</code> attribute of a <code>&lt;bean&gt;</code> element a special
<code>(inferred)</code> value, which instructs Spring to automatically detect a public <code>close</code> or
<code>shutdown</code> method on the specific bean class. (Any class that implements
<code>java.lang.AutoCloseable</code> or <code>java.io.Closeable</code> would therefore match.) You can also set
this special <code>(inferred)</code> value on the <code>default-destroy-method</code> attribute of a
<code>&lt;beans&gt;</code> element to apply this behavior to an entire set of beans (see
<a href="#beans-factory-lifecycle-default-init-destroy-methods">Default Initialization and Destroy Methods</a>). Note that this is the
default behavior with Java configuration.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-default-init-destroy-methods"><a class="anchor" href="#beans-factory-lifecycle-default-init-destroy-methods"></a>Default Initialization and Destroy Methods</h5>
<div class="paragraph">
<p>When you write initialization and destroy method callbacks that do not use the
Spring-specific <code>InitializingBean</code> and <code>DisposableBean</code> callback interfaces, you
typically write methods with names such as <code>init()</code>, <code>initialize()</code>, <code>dispose()</code>, and so
on. Ideally, the names of such lifecycle callback methods are standardized across a
project so that all developers use the same method names and ensure consistency.</p>
</div>
<div class="paragraph">
<p>You can configure the Spring container to &#8220;look&#8221; for named initialization and destroy
callback method names on every bean. This means that you, as an application
developer, can write your application classes and use an initialization callback called
<code>init()</code>, without having to configure an <code>init-method="init"</code> attribute with each bean
definition. The Spring IoC container calls that method when the bean is created (and in
accordance with the standard lifecycle callback contract <a href="#beans-factory-lifecycle">described previously</a>). This feature also enforces a consistent naming convention for
initialization and destroy method callbacks.</p>
</div>
<div class="paragraph">
<p>Suppose that your initialization callback methods are named <code>init()</code> and your destroy
callback methods are named <code>destroy()</code>. Your class then resembles the class in the
following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class DefaultBlogService implements BlogService {

    private BlogDao blogDao;

    public void setBlogDao(BlogDao blogDao) {
        this.blogDao = blogDao;
    }

    // this is (unsurprisingly) the initialization callback method
    public void init() {
        if (this.blogDao == null) {
            throw new IllegalStateException("The [blogDao] property must be set.");
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class DefaultBlogService : BlogService {

    private var blogDao: BlogDao? = null

    // this is (unsurprisingly) the initialization callback method
    fun init() {
        if (blogDao == null) {
            throw IllegalStateException("The [blogDao] property must be set.")
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You could then use that class in a bean resembling the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans default-init-method="init"&gt;

    &lt;bean id="blogService" class="com.something.DefaultBlogService"&gt;
        &lt;property name="blogDao" ref="blogDao" /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The presence of the <code>default-init-method</code> attribute on the top-level <code>&lt;beans/&gt;</code> element
attribute causes the Spring IoC container to recognize a method called <code>init</code> on the bean
class as the initialization method callback. When a bean is created and assembled, if the
bean class has such a method, it is invoked at the appropriate time.</p>
</div>
<div class="paragraph">
<p>You can configure destroy method callbacks similarly (in XML, that is) by using the
<code>default-destroy-method</code> attribute on the top-level <code>&lt;beans/&gt;</code> element.</p>
</div>
<div class="paragraph">
<p>Where existing bean classes already have callback methods that are named at variance
with the convention, you can override the default by specifying (in XML, that is) the
method name by using the <code>init-method</code> and <code>destroy-method</code> attributes of the <code>&lt;bean/&gt;</code>
itself.</p>
</div>
<div class="paragraph">
<p>The Spring container guarantees that a configured initialization callback is called
immediately after a bean is supplied with all dependencies. Thus, the initialization
callback is called on the raw bean reference, which means that AOP interceptors and so
forth are not yet applied to the bean. A target bean is fully created first and
then an AOP proxy (for example) with its interceptor chain is applied. If the target
bean and the proxy are defined separately, your code can even interact with the raw
target bean, bypassing the proxy. Hence, it would be inconsistent to apply the
interceptors to the <code>init</code> method, because doing so would couple the lifecycle of the
target bean to its proxy or interceptors and leave strange semantics when your code
interacts directly with the raw target bean.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-combined-effects"><a class="anchor" href="#beans-factory-lifecycle-combined-effects"></a>Combining Lifecycle Mechanisms</h5>
<div class="paragraph">
<p>As of Spring 2.5, you have three options for controlling bean lifecycle behavior:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="#beans-factory-lifecycle-initializingbean"><code>InitializingBean</code></a> and
<a href="#beans-factory-lifecycle-disposablebean"><code>DisposableBean</code></a> callback interfaces</p>
</li>
<li>
<p>Custom <code>init()</code> and <code>destroy()</code> methods</p>
</li>
<li>
<p>The <a href="#beans-postconstruct-and-predestroy-annotations"><code>@PostConstruct</code> and <code>@PreDestroy</code>
annotations</a>. You can combine these mechanisms to control a given bean.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If multiple lifecycle mechanisms are configured for a bean and each mechanism is
configured with a different method name, then each configured method is run in the
order listed after this note. However, if the same method name is configured&#8201;&#8212;&#8201;for example,
<code>init()</code> for an initialization method&#8201;&#8212;&#8201;for more than one of these lifecycle mechanisms,
that method is run once, as explained in the
<a href="#beans-factory-lifecycle-default-init-destroy-methods">preceding section</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Multiple lifecycle mechanisms configured for the same bean, with different
initialization methods, are called as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Methods annotated with <code>@PostConstruct</code></p>
</li>
<li>
<p><code>afterPropertiesSet()</code> as defined by the <code>InitializingBean</code> callback interface</p>
</li>
<li>
<p>A custom configured <code>init()</code> method</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Destroy methods are called in the same order:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Methods annotated with <code>@PreDestroy</code></p>
</li>
<li>
<p><code>destroy()</code> as defined by the <code>DisposableBean</code> callback interface</p>
</li>
<li>
<p>A custom configured <code>destroy()</code> method</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-lifecycle-processor"><a class="anchor" href="#beans-factory-lifecycle-processor"></a>Startup and Shutdown Callbacks</h5>
<div class="paragraph">
<p>The <code>Lifecycle</code> interface defines the essential methods for any object that has its own
lifecycle requirements (such as starting and stopping some background process):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface Lifecycle {

    void start();

    void stop();

    boolean isRunning();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any Spring-managed object may implement the <code>Lifecycle</code> interface. Then, when the
<code>ApplicationContext</code> itself receives start and stop signals (for example, for a stop/restart
scenario at runtime), it cascades those calls to all <code>Lifecycle</code> implementations
defined within that context. It does this by delegating to a <code>LifecycleProcessor</code>, shown
in the following listing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface LifecycleProcessor extends Lifecycle {

    void onRefresh();

    void onClose();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that the <code>LifecycleProcessor</code> is itself an extension of the <code>Lifecycle</code>
interface. It also adds two other methods for reacting to the context being refreshed
and closed.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Note that the regular <code>org.springframework.context.Lifecycle</code> interface is a plain
contract for explicit start and stop notifications and does not imply auto-startup at context
refresh time. For fine-grained control over auto-startup of a specific bean (including startup phases),
consider implementing <code>org.springframework.context.SmartLifecycle</code> instead.</p>
</div>
<div class="paragraph">
<p>Also, please note that stop notifications are not guaranteed to come before destruction.
On regular shutdown, all <code>Lifecycle</code> beans first receive a stop notification before
the general destruction callbacks are being propagated. However, on hot refresh during a
context&#8217;s lifetime or on stopped refresh attempts, only destroy methods are called.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The order of startup and shutdown invocations can be important. If a &#8220;depends-on&#8221;
relationship exists between any two objects, the dependent side starts after its
dependency, and it stops before its dependency. However, at times, the direct
dependencies are unknown. You may only know that objects of a certain type should start
prior to objects of another type. In those cases, the <code>SmartLifecycle</code> interface defines
another option, namely the <code>getPhase()</code> method as defined on its super-interface,
<code>Phased</code>. The following listing shows the definition of the <code>Phased</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface Phased {

    int getPhase();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following listing shows the definition of the <code>SmartLifecycle</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface SmartLifecycle extends Lifecycle, Phased {

    boolean isAutoStartup();

    void stop(Runnable callback);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When starting, the objects with the lowest phase start first. When stopping, the
reverse order is followed. Therefore, an object that implements <code>SmartLifecycle</code> and
whose <code>getPhase()</code> method returns <code>Integer.MIN_VALUE</code> would be among the first to start
and the last to stop. At the other end of the spectrum, a phase value of
<code>Integer.MAX_VALUE</code> would indicate that the object should be started last and stopped
first (likely because it depends on other processes to be running). When considering the
phase value, it is also important to know that the default phase for any &#8220;normal&#8221;
<code>Lifecycle</code> object that does not implement <code>SmartLifecycle</code> is <code>0</code>. Therefore, any
negative phase value indicates that an object should start before those standard
components (and stop after them). The reverse is true for any positive phase value.</p>
</div>
<div class="paragraph">
<p>The stop method defined by <code>SmartLifecycle</code> accepts a callback. Any
implementation must invoke that callback&#8217;s <code>run()</code> method after that implementation&#8217;s
shutdown process is complete. That enables asynchronous shutdown where necessary, since
the default implementation of the <code>LifecycleProcessor</code> interface,
<code>DefaultLifecycleProcessor</code>, waits up to its timeout value for the group of objects
within each phase to invoke that callback. The default per-phase timeout is 30 seconds.
You can override the default lifecycle processor instance by defining a bean named
<code>lifecycleProcessor</code> within the context. If you want only to modify the timeout,
defining the following would suffice:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="lifecycleProcessor" class="org.springframework.context.support.DefaultLifecycleProcessor"&gt;
    &lt;!-- timeout value in milliseconds --&gt;
    &lt;property name="timeoutPerShutdownPhase" value="10000"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>As mentioned earlier, the <code>LifecycleProcessor</code> interface defines callback methods for the
refreshing and closing of the context as well. The latter drives the shutdown
process as if <code>stop()</code> had been called explicitly, but it happens when the context is
closing. The 'refresh' callback, on the other hand, enables another feature of
<code>SmartLifecycle</code> beans. When the context is refreshed (after all objects have been
instantiated and initialized), that callback is invoked. At that point, the
default lifecycle processor checks the boolean value returned by each
<code>SmartLifecycle</code> object&#8217;s <code>isAutoStartup()</code> method. If <code>true</code>, that object is
started at that point rather than waiting for an explicit invocation of the context&#8217;s or
its own <code>start()</code> method (unlike the context refresh, the context start does not happen
automatically for a standard context implementation). The <code>phase</code> value and any
&#8220;depends-on&#8221; relationships determine the startup order as described earlier.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-shutdown"><a class="anchor" href="#beans-factory-shutdown"></a>Shutting Down the Spring IoC Container Gracefully in Non-Web Applications</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This section applies only to non-web applications. Spring&#8217;s web-based
<code>ApplicationContext</code> implementations already have code in place to gracefully shut down
the Spring IoC container when the relevant web application is shut down.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you use Spring&#8217;s IoC container in a non-web application environment (for
example, in a rich client desktop environment), register a shutdown hook with the
JVM. Doing so ensures a graceful shutdown and calls the relevant destroy methods on your
singleton beans so that all resources are released. You must still configure
and implement these destroy callbacks correctly.</p>
</div>
<div class="paragraph">
<p>To register a shutdown hook, call the <code>registerShutdownHook()</code> method that is
declared on the <code>ConfigurableApplicationContext</code> interface, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");

        // add a shutdown hook for the above context...
        ctx.registerShutdownHook();

        // app runs here...

        // main method exits, hook is called prior to the app shutting down...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.context.support.ClassPathXmlApplicationContext

fun main() {
    val ctx = ClassPathXmlApplicationContext("beans.xml")

    // add a shutdown hook for the above context...
    ctx.registerShutdownHook()

    // app runs here...

    // main method exits, hook is called prior to the app shutting down...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-aware"><a class="anchor" href="#beans-factory-aware"></a>1.6.2. <code>ApplicationContextAware</code> and <code>BeanNameAware</code></h4>
<div class="paragraph">
<p>When an <code>ApplicationContext</code> creates an object instance that implements the
<code>org.springframework.context.ApplicationContextAware</code> interface, the instance is provided
with a reference to that <code>ApplicationContext</code>. The following listing shows the definition
of the <code>ApplicationContextAware</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface ApplicationContextAware {

    void setApplicationContext(ApplicationContext applicationContext) throws BeansException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thus, beans can programmatically manipulate the <code>ApplicationContext</code> that created them,
through the <code>ApplicationContext</code> interface or by casting the reference to a known
subclass of this interface (such as <code>ConfigurableApplicationContext</code>, which exposes
additional functionality). One use would be the programmatic retrieval of other beans.
Sometimes this capability is useful. However, in general, you should avoid it, because
it couples the code to Spring and does not follow the Inversion of Control style,
where collaborators are provided to beans as properties. Other methods of the
<code>ApplicationContext</code> provide access to file resources, publishing application events,
and accessing a <code>MessageSource</code>. These additional features are described in
<a href="#context-introduction">Additional Capabilities of the <code>ApplicationContext</code></a>.</p>
</div>
<div class="paragraph">
<p>Autowiring is another alternative to obtain a reference to the
<code>ApplicationContext</code>. The <em>traditional</em> <code>constructor</code> and <code>byType</code> autowiring modes
(as described in <a href="#beans-factory-autowire">Autowiring Collaborators</a>) can provide a dependency of type
<code>ApplicationContext</code> for a constructor argument or a setter method parameter,
respectively. For more flexibility, including the ability to autowire fields and
multiple parameter methods, use the annotation-based autowiring features. If you do,
the <code>ApplicationContext</code> is autowired into a field, constructor argument, or method
parameter that expects the <code>ApplicationContext</code> type if the field, constructor, or
method in question carries the <code>@Autowired</code> annotation. For more information, see
<a href="#beans-autowired-annotation">Using <code>@Autowired</code></a>.</p>
</div>
<div class="paragraph">
<p>When an <code>ApplicationContext</code> creates a class that implements the
<code>org.springframework.beans.factory.BeanNameAware</code> interface, the class is provided with
a reference to the name defined in its associated object definition. The following listing
shows the definition of the BeanNameAware interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface BeanNameAware {

    void setBeanName(String name) throws BeansException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The callback is invoked after population of normal bean properties but before an
initialization callback such as <code>InitializingBean</code>, <code>afterPropertiesSet</code>, or a custom
init-method.</p>
</div>
</div>
<div class="sect3">
<h4 id="aware-list"><a class="anchor" href="#aware-list"></a>1.6.3. Other <code>Aware</code> Interfaces</h4>
<div class="paragraph">
<p>Besides <code>ApplicationContextAware</code> and <code>BeanNameAware</code> (discussed <a href="#beans-factory-aware">earlier</a>),
Spring offers a wide range of <code>Aware</code> callback interfaces that let beans indicate to the container
that they require a certain infrastructure dependency. As a general rule, the name indicates the
dependency type. The following table summarizes the most important <code>Aware</code> interfaces:</p>
</div>
<table id="beans-factory-nature-aware-list" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. Aware interfaces</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Injected Dependency</th>
<th class="tableblock halign-left valign-top">Explained in&#8230;&#8203;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ApplicationContextAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Declaring <code>ApplicationContext</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-aware"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ApplicationEventPublisherAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Event publisher of the enclosing <code>ApplicationContext</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#context-introduction">Additional Capabilities of the <code>ApplicationContext</code></a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BeanClassLoaderAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Class loader used to load the bean classes.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-class">Instantiating Beans</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BeanFactoryAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Declaring <code>BeanFactory</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-aware"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BeanNameAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name of the declaring bean.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#beans-factory-aware"><code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LoadTimeWeaverAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defined weaver for processing class definition at load time.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#aop-aj-ltw">Load-time Weaving with AspectJ in the Spring Framework</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>MessageSourceAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Configured strategy for resolving messages (with support for parametrization and
internationalization).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#context-introduction">Additional Capabilities of the <code>ApplicationContext</code></a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotificationPublisherAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring JMX notification publisher.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="integration.html#jmx-notifications">Notifications</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ResourceLoaderAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Configured loader for low-level access to resources.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#resources">Resources</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServletConfigAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current <code>ServletConfig</code> the container runs in. Valid only in a web-aware Spring
<code>ApplicationContext</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="web.html#mvc">Spring MVC</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServletContextAware</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current <code>ServletContext</code> the container runs in. Valid only in a web-aware Spring
<code>ApplicationContext</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="web.html#mvc">Spring MVC</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Note again that using these interfaces ties your code to the Spring API and does not
follow the Inversion of Control style. As a result, we recommend them for infrastructure
beans that require programmatic access to the container.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-child-bean-definitions"><a class="anchor" href="#beans-child-bean-definitions"></a>1.7. Bean Definition Inheritance</h3>
<div class="paragraph">
<p>A bean definition can contain a lot of configuration information, including constructor
arguments, property values, and container-specific information, such as the initialization
method, a static factory method name, and so on. A child bean definition inherits
configuration data from a parent definition. The child definition can override some
values or add others as needed. Using parent and child bean definitions can save a lot
of typing. Effectively, this is a form of templating.</p>
</div>
<div class="paragraph">
<p>If you work with an <code>ApplicationContext</code> interface programmatically, child bean
definitions are represented by the <code>ChildBeanDefinition</code> class. Most users do not work
with them on this level. Instead, they configure bean definitions declaratively in a class
such as the <code>ClassPathXmlApplicationContext</code>. When you use XML-based configuration
metadata, you can indicate a child bean definition by using the <code>parent</code> attribute,
specifying the parent bean as the value of this attribute. The following example shows how
to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="inheritedTestBean" abstract="true"
        class="org.springframework.beans.TestBean"&gt;
    &lt;property name="name" value="parent"/&gt;
    &lt;property name="age" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="inheritsWithDifferentClass"
        class="org.springframework.beans.DerivedTestBean"
        parent="inheritedTestBean" init-method="initialize"&gt;  <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;property name="name" value="override"/&gt;
    &lt;!-- the age property value of 1 will be inherited from parent --&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Note the <code>parent</code> attribute.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A child bean definition uses the bean class from the parent definition if none is
specified but can also override it. In the latter case, the child bean class must be
compatible with the parent (that is, it must accept the parent&#8217;s property values).</p>
</div>
<div class="paragraph">
<p>A child bean definition inherits scope, constructor argument values, property values, and
method overrides from the parent, with the option to add new values. Any scope, initialization
method, destroy method, or <code>static</code> factory method settings that you specify
override the corresponding parent settings.</p>
</div>
<div class="paragraph">
<p>The remaining settings are always taken from the child definition: depends on,
autowire mode, dependency check, singleton, and lazy init.</p>
</div>
<div class="paragraph">
<p>The preceding example explicitly marks the parent bean definition as abstract by using
the <code>abstract</code> attribute. If the parent definition does not specify a class, explicitly
marking the parent bean definition as <code>abstract</code> is required, as the following example
shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="inheritedTestBeanWithoutClass" abstract="true"&gt;
    &lt;property name="name" value="parent"/&gt;
    &lt;property name="age" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="inheritsWithClass" class="org.springframework.beans.DerivedTestBean"
        parent="inheritedTestBeanWithoutClass" init-method="initialize"&gt;
    &lt;property name="name" value="override"/&gt;
    &lt;!-- age will inherit the value of 1 from the parent bean definition--&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The parent bean cannot be instantiated on its own because it is incomplete, and it is
also explicitly marked as <code>abstract</code>. When a definition is <code>abstract</code>, it is
usable only as a pure template bean definition that serves as a parent definition for
child definitions. Trying to use such an <code>abstract</code> parent bean on its own, by referring
to it as a ref property of another bean or doing an explicit <code>getBean()</code> call with the
parent bean ID returns an error. Similarly, the container&#8217;s internal
<code>preInstantiateSingletons()</code> method ignores bean definitions that are defined as
abstract.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>ApplicationContext</code> pre-instantiates all singletons by default. Therefore, it is
important (at least for singleton beans) that if you have a (parent) bean definition
which you intend to use only as a template, and this definition specifies a class, you
must make sure to set the <em>abstract</em> attribute to <em>true</em>, otherwise the application
context will actually (attempt to) pre-instantiate the <code>abstract</code> bean.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="beans-factory-extension"><a class="anchor" href="#beans-factory-extension"></a>1.8. Container Extension Points</h3>
<div class="paragraph">
<p>Typically, an application developer does not need to subclass <code>ApplicationContext</code>
implementation classes. Instead, the Spring IoC container can be extended by plugging in
implementations of special integration interfaces. The next few sections describe these
integration interfaces.</p>
</div>
<div class="sect3">
<h4 id="beans-factory-extension-bpp"><a class="anchor" href="#beans-factory-extension-bpp"></a>1.8.1. Customizing Beans by Using a <code>BeanPostProcessor</code></h4>
<div class="paragraph">
<p>The <code>BeanPostProcessor</code> interface defines callback methods that you can implement to
provide your own (or override the container&#8217;s default) instantiation logic, dependency
resolution logic, and so forth. If you want to implement some custom logic after the
Spring container finishes instantiating, configuring, and initializing a bean, you can
plug in one or more custom <code>BeanPostProcessor</code> implementations.</p>
</div>
<div class="paragraph">
<p>You can configure multiple <code>BeanPostProcessor</code> instances, and you can control the order
in which these <code>BeanPostProcessor</code> instances run by setting the <code>order</code> property.
You can set this property only if the <code>BeanPostProcessor</code> implements the <code>Ordered</code>
interface. If you write your own <code>BeanPostProcessor</code>, you should consider implementing
the <code>Ordered</code> interface, too. For further details, see the javadoc of the
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/beans/factory/config/BeanPostProcessor.html"><code>BeanPostProcessor</code></a>
and <a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/core/Ordered.html"><code>Ordered</code></a> interfaces. See also the note
on <a href="#beans-factory-programmatically-registering-beanpostprocessors">programmatic
registration of <code>BeanPostProcessor</code> instances</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>BeanPostProcessor</code> instances operate on bean (or object) instances. That is,
the Spring IoC container instantiates a bean instance and then <code>BeanPostProcessor</code>
instances do their work.</p>
</div>
<div class="paragraph">
<p><code>BeanPostProcessor</code> instances are scoped per-container. This is relevant only if you
use container hierarchies. If you define a <code>BeanPostProcessor</code> in one container,
it post-processes only the beans in that container. In other words, beans that are
defined in one container are not post-processed by a <code>BeanPostProcessor</code> defined in
another container, even if both containers are part of the same hierarchy.</p>
</div>
<div class="paragraph">
<p>To change the actual bean definition (that is, the blueprint that defines the bean),
you instead need to use a <code>BeanFactoryPostProcessor</code>, as described in
<a href="#beans-factory-extension-factory-postprocessors">Customizing Configuration Metadata with a <code>BeanFactoryPostProcessor</code></a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>org.springframework.beans.factory.config.BeanPostProcessor</code> interface consists of
exactly two callback methods. When such a class is registered as a post-processor with
the container, for each bean instance that is created by the container, the
post-processor gets a callback from the container both before container
initialization methods (such as <code>InitializingBean.afterPropertiesSet()</code> or any
declared <code>init</code> method) are called, and after any bean initialization callbacks.
The post-processor can take any action with the bean instance, including ignoring the
callback completely. A bean post-processor typically checks for callback interfaces,
or it may wrap a bean with a proxy. Some Spring AOP infrastructure classes are
implemented as bean post-processors in order to provide proxy-wrapping logic.</p>
</div>
<div class="paragraph">
<p>An <code>ApplicationContext</code> automatically detects any beans that are defined in the
configuration metadata that implements the <code>BeanPostProcessor</code> interface. The
<code>ApplicationContext</code> registers these beans as post-processors so that they can be called
later, upon bean creation. Bean post-processors can be deployed in the container in the
same fashion as any other beans.</p>
</div>
<div class="paragraph">
<p>Note that, when declaring a <code>BeanPostProcessor</code> by using an <code>@Bean</code> factory method on a
configuration class, the return type of the factory method should be the implementation
class itself or at least the <code>org.springframework.beans.factory.config.BeanPostProcessor</code>
interface, clearly indicating the post-processor nature of that bean. Otherwise, the
<code>ApplicationContext</code> cannot autodetect it by type before fully creating it.
Since a <code>BeanPostProcessor</code> needs to be instantiated early in order to apply to the
initialization of other beans in the context, this early type detection is critical.</p>
</div>
<div id="beans-factory-programmatically-registering-beanpostprocessors" class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Programmatically registering <code>BeanPostProcessor</code> instances</div>
While the recommended approach for <code>BeanPostProcessor</code> registration is through
<code>ApplicationContext</code> auto-detection (as described earlier), you can register them
programmatically against a <code>ConfigurableBeanFactory</code> by using the <code>addBeanPostProcessor</code>
method. This can be useful when you need to evaluate conditional logic before
registration or even for copying bean post processors across contexts in a hierarchy.
Note, however, that <code>BeanPostProcessor</code> instances added programmatically do not respect
the <code>Ordered</code> interface. Here, it is the order of registration that dictates the order
of execution. Note also that <code>BeanPostProcessor</code> instances registered programmatically
are always processed before those registered through auto-detection, regardless of any
explicit ordering.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title"><code>BeanPostProcessor</code> instances and AOP auto-proxying</div>
<div class="paragraph">
<p>Classes that implement the <code>BeanPostProcessor</code> interface are special and are treated
differently by the container. All <code>BeanPostProcessor</code> instances and beans that they
directly reference are instantiated on startup, as part of the special startup phase
of the <code>ApplicationContext</code>. Next, all <code>BeanPostProcessor</code> instances are registered
in a sorted fashion and applied to all further beans in the container. Because AOP
auto-proxying is implemented as a <code>BeanPostProcessor</code> itself, neither <code>BeanPostProcessor</code>
instances nor the beans they directly reference are eligible for auto-proxying and,
thus, do not have aspects woven into them.</p>
</div>
<div class="paragraph">
<p>For any such bean, you should see an informational log message: <code>Bean someBean is not
eligible for getting processed by all BeanPostProcessor interfaces (for example: not
eligible for auto-proxying)</code>.</p>
</div>
<div class="paragraph">
<p>If you have beans wired into your <code>BeanPostProcessor</code> by using autowiring or
<code>@Resource</code> (which may fall back to autowiring), Spring might access unexpected beans
when searching for type-matching dependency candidates and, therefore, make them
ineligible for auto-proxying or other kinds of bean post-processing. For example, if you
have a dependency annotated with <code>@Resource</code> where the field or setter name does not
directly correspond to the declared name of a bean and no name attribute is used,
Spring accesses other beans for matching them by type.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following examples show how to write, register, and use <code>BeanPostProcessor</code> instances
in an <code>ApplicationContext</code>.</p>
</div>
<div class="sect4">
<h5 id="beans-factory-extension-bpp-examples-hw"><a class="anchor" href="#beans-factory-extension-bpp-examples-hw"></a>Example: Hello World, <code>BeanPostProcessor</code>-style</h5>
<div class="paragraph">
<p>This first example illustrates basic usage. The example shows a custom
<code>BeanPostProcessor</code> implementation that invokes the <code>toString()</code> method of each bean as
it is created by the container and prints the resulting string to the system console.</p>
</div>
<div class="paragraph">
<p>The following listing shows the custom <code>BeanPostProcessor</code> implementation class definition:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package scripting;

import org.springframework.beans.factory.config.BeanPostProcessor;

public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor {

    // simply return the instantiated bean as-is
    public Object postProcessBeforeInitialization(Object bean, String beanName) {
        return bean; // we could potentially return any object reference here...
    }

    public Object postProcessAfterInitialization(Object bean, String beanName) {
        System.out.println("Bean '" + beanName + "' created : " + bean.toString());
        return bean;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.beans.factory.config.BeanPostProcessor

class InstantiationTracingBeanPostProcessor : BeanPostProcessor {

    // simply return the instantiated bean as-is
    override fun postProcessBeforeInitialization(bean: Any, beanName: String): Any? {
        return bean // we could potentially return any object reference here...
    }

    override fun postProcessAfterInitialization(bean: Any, beanName: String): Any? {
        println("Bean '$beanName' created : $bean")
        return bean
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following <code>beans</code> element uses the <code>InstantiationTracingBeanPostProcessor</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:lang="http://www.springframework.org/schema/lang"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/lang
        https://www.springframework.org/schema/lang/spring-lang.xsd"&gt;

    &lt;lang:groovy id="messenger"
            script-source="classpath:org/springframework/scripting/groovy/Messenger.groovy"&gt;
        &lt;lang:property name="message" value="Fiona Apple Is Just So Dreamy."/&gt;
    &lt;/lang:groovy&gt;

    &lt;!--
    when the above bean (messenger) is instantiated, this custom
    BeanPostProcessor implementation will output the fact to the system console
    --&gt;
    &lt;bean class="scripting.InstantiationTracingBeanPostProcessor"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice how the <code>InstantiationTracingBeanPostProcessor</code> is merely defined. It does not
even have a name, and, because it is a bean, it can be dependency-injected as you would any
other bean. (The preceding configuration also defines a bean that is backed by a Groovy
script. The Spring dynamic language support is detailed in the chapter entitled
<a href="languages.html#dynamic-language">Dynamic Language Support</a>.)</p>
</div>
<div class="paragraph">
<p>The following Java application runs the preceding code and configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.scripting.Messenger;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("scripting/beans.xml");
        Messenger messenger = ctx.getBean("messenger", Messenger.class);
        System.out.println(messenger);
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.beans.factory.getBean

fun main() {
    val ctx = ClassPathXmlApplicationContext("scripting/beans.xml")
    val messenger = ctx.getBean&lt;Messenger&gt;("messenger")
    println(messenger)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output of the preceding application resembles the following:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Bean 'messenger' created : <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="67081500491417150e09000115060a021008150c491404150e17130e09004900150808111e4920150808111e2a0214140209000215275550555e5156">[email&#160;protected]</a>
<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="84ebf6e3aaf7f4f6edeae3e2f6e5e9e1f3ebf6efaaf7e7f6edf4f0edeae3aae3f6ebebf2fdaac3f6ebebf2fdc9e1f7f7e1eae3e1f6c4b6b3b6bdb2b5">[email&#160;protected]</a></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-extension-bpp-examples-aabpp"><a class="anchor" href="#beans-factory-extension-bpp-examples-aabpp"></a>Example: The <code>AutowiredAnnotationBeanPostProcessor</code></h5>
<div class="paragraph">
<p>Using callback interfaces or annotations in conjunction with a custom <code>BeanPostProcessor</code>
implementation is a common means of extending the Spring IoC container. An example is
Spring&#8217;s <code>AutowiredAnnotationBeanPostProcessor</code>&#8201;&#8212;&#8201;a <code>BeanPostProcessor</code> implementation
that ships with the Spring distribution and autowires annotated fields, setter methods,
and arbitrary config methods.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-extension-factory-postprocessors"><a class="anchor" href="#beans-factory-extension-factory-postprocessors"></a>1.8.2. Customizing Configuration Metadata with a <code>BeanFactoryPostProcessor</code></h4>
<div class="paragraph">
<p>The next extension point that we look at is the
<code>org.springframework.beans.factory.config.BeanFactoryPostProcessor</code>. The semantics of
this interface are similar to those of the <code>BeanPostProcessor</code>, with one major
difference: <code>BeanFactoryPostProcessor</code> operates on the bean configuration metadata.
That is, the Spring IoC container lets a <code>BeanFactoryPostProcessor</code> read the
configuration metadata and potentially change it <em>before</em> the container instantiates
any beans other than <code>BeanFactoryPostProcessor</code> instances.</p>
</div>
<div class="paragraph">
<p>You can configure multiple <code>BeanFactoryPostProcessor</code> instances, and you can control the order in
which these <code>BeanFactoryPostProcessor</code> instances run by setting the <code>order</code> property.
However, you can only set this property if the <code>BeanFactoryPostProcessor</code> implements the
<code>Ordered</code> interface. If you write your own <code>BeanFactoryPostProcessor</code>, you should
consider implementing the <code>Ordered</code> interface, too. See the javadoc of the
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/beans/factory/config/BeanFactoryPostProcessor.html"><code>BeanFactoryPostProcessor</code></a>
and <a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/core/Ordered.html"><code>Ordered</code></a> interfaces for more details.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you want to change the actual bean instances (that is, the objects that are created
from the configuration metadata), then you instead need to use a <code>BeanPostProcessor</code>
(described earlier in <a href="#beans-factory-extension-bpp">Customizing Beans by Using a <code>BeanPostProcessor</code></a>). While it is technically possible
to work with bean instances within a <code>BeanFactoryPostProcessor</code> (for example, by using
<code>BeanFactory.getBean()</code>), doing so causes premature bean instantiation, violating the
standard container lifecycle. This may cause negative side effects, such as bypassing
bean post processing.</p>
</div>
<div class="paragraph">
<p>Also, <code>BeanFactoryPostProcessor</code> instances are scoped per-container. This is only relevant
if you use container hierarchies. If you define a <code>BeanFactoryPostProcessor</code> in one
container, it is applied only to the bean definitions in that container. Bean definitions
in one container are not post-processed by <code>BeanFactoryPostProcessor</code> instances in another
container, even if both containers are part of the same hierarchy.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A bean factory post-processor is automatically run when it is declared inside an
<code>ApplicationContext</code>, in order to apply changes to the configuration metadata that
define the container. Spring includes a number of predefined bean factory
post-processors, such as <code>PropertyOverrideConfigurer</code> and
<code>PropertySourcesPlaceholderConfigurer</code>. You can also use a custom <code>BeanFactoryPostProcessor</code>&#8201;&#8212;&#8201;for example, to register custom property editors.</p>
</div>
<div class="paragraph">
<p>An <code>ApplicationContext</code> automatically detects any beans that are deployed into it that
implement the <code>BeanFactoryPostProcessor</code> interface. It uses these beans as bean factory
post-processors, at the appropriate time. You can deploy these post-processor beans as
you would any other bean.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As with <code>BeanPostProcessor</code>s , you typically do not want to configure
<code>BeanFactoryPostProcessor</code>s for lazy initialization. If no other bean references a
<code>Bean(Factory)PostProcessor</code>, that post-processor will not get instantiated at all.
Thus, marking it for lazy initialization will be ignored, and the
<code>Bean(Factory)PostProcessor</code> will be instantiated eagerly even if you set the
<code>default-lazy-init</code> attribute to <code>true</code> on the declaration of your <code>&lt;beans /&gt;</code> element.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="beans-factory-placeholderconfigurer"><a class="anchor" href="#beans-factory-placeholderconfigurer"></a>Example: The Class Name Substitution <code>PropertySourcesPlaceholderConfigurer</code></h5>
<div class="paragraph">
<p>You can use the <code>PropertySourcesPlaceholderConfigurer</code> to externalize property values
from a bean definition in a separate file by using the standard Java <code>Properties</code> format.
Doing so enables the person deploying an application to customize environment-specific
properties, such as database URLs and passwords, without the complexity or risk of
modifying the main XML definition file or files for the container.</p>
</div>
<div class="paragraph">
<p>Consider the following XML-based configuration metadata fragment, where a <code>DataSource</code>
with placeholder values is defined:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer"&gt;
    &lt;property name="locations" value="classpath:com/something/jdbc.properties"/&gt;
&lt;/bean&gt;

&lt;bean id="dataSource" destroy-method="close"
        class="org.apache.commons.dbcp.BasicDataSource"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example shows properties configured from an external <code>Properties</code> file. At runtime,
a <code>PropertySourcesPlaceholderConfigurer</code> is applied to the metadata that replaces some
properties of the DataSource. The values to replace are specified as placeholders of the
form <code>${property-name}</code>, which follows the Ant and log4j and JSP EL style.</p>
</div>
<div class="paragraph">
<p>The actual values come from another file in the standard Java <code>Properties</code> format:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root</pre>
</div>
</div>
<div class="paragraph">
<p>Therefore, the <code>${jdbc.username}</code> string is replaced at runtime with the value, 'sa', and
the same applies for other placeholder values that match keys in the properties file.
The <code>PropertySourcesPlaceholderConfigurer</code> checks for placeholders in most properties and
attributes of a bean definition. Furthermore, you can customize the placeholder prefix and suffix.</p>
</div>
<div class="paragraph">
<p>With the <code>context</code> namespace introduced in Spring 2.5, you can configure property placeholders
with a dedicated configuration element. You can provide one or more locations as a
comma-separated list in the <code>location</code> attribute, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;context:property-placeholder location="classpath:com/something/jdbc.properties"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>PropertySourcesPlaceholderConfigurer</code> not only looks for properties in the <code>Properties</code>
file you specify. By default, if it cannot find a property in the specified properties files,
it checks against Spring <code>Environment</code> properties and regular Java <code>System</code> properties.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can use the <code>PropertySourcesPlaceholderConfigurer</code> to substitute class names, which
is sometimes useful when you have to pick a particular implementation class at runtime.
The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean class="org.springframework.beans.factory.config.PropertySourcesPlaceholderConfigurer"&gt;
    &lt;property name="locations"&gt;
        &lt;value&gt;classpath:com/something/strategy.properties&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="properties"&gt;
        &lt;value&gt;custom.strategy.class=com.something.DefaultStrategy&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="serviceStrategy" class="${custom.strategy.class}"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the class cannot be resolved at runtime to a valid class, resolution of the bean
fails when it is about to be created, which is during the <code>preInstantiateSingletons()</code>
phase of an <code>ApplicationContext</code> for a non-lazy-init bean.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-factory-overrideconfigurer"><a class="anchor" href="#beans-factory-overrideconfigurer"></a>Example: The <code>PropertyOverrideConfigurer</code></h5>
<div class="paragraph">
<p>The <code>PropertyOverrideConfigurer</code>, another bean factory post-processor, resembles the
<code>PropertySourcesPlaceholderConfigurer</code>, but unlike the latter, the original definitions
can have default values or no values at all for bean properties. If an overriding
<code>Properties</code> file does not have an entry for a certain bean property, the default
context definition is used.</p>
</div>
<div class="paragraph">
<p>Note that the bean definition is not aware of being overridden, so it is not
immediately obvious from the XML definition file that the override configurer is being
used. In case of multiple <code>PropertyOverrideConfigurer</code> instances that define different
values for the same bean property, the last one wins, due to the overriding mechanism.</p>
</div>
<div class="paragraph">
<p>Properties file configuration lines take the following format:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>beanName.property=value</pre>
</div>
</div>
<div class="paragraph">
<p>The following listing shows an example of the format:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>dataSource.driverClassName=com.mysql.jdbc.Driver
dataSource.url=jdbc:mysql:mydb</pre>
</div>
</div>
<div class="paragraph">
<p>This example file can be used with a container definition that contains a bean called
<code>dataSource</code> that has <code>driver</code> and <code>url</code> properties.</p>
</div>
<div class="paragraph">
<p>Compound property names are also supported, as long as every component of the path
except the final property being overridden is already non-null (presumably initialized
by the constructors). In the following example, the <code>sammy</code> property of the <code>bob</code> property of the <code>fred</code> property of the <code>tom</code> bean
is set to the scalar value <code>123</code>:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>tom.fred.bob.sammy=123</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Specified override values are always literal values. They are not translated into
bean references. This convention also applies when the original value in the XML bean
definition specifies a bean reference.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>With the <code>context</code> namespace introduced in Spring 2.5, it is possible to configure
property overriding with a dedicated configuration element, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;context:property-override location="classpath:override.properties"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-factory-extension-factorybean"><a class="anchor" href="#beans-factory-extension-factorybean"></a>1.8.3. Customizing Instantiation Logic with a <code>FactoryBean</code></h4>
<div class="paragraph">
<p>You can implement the <code>org.springframework.beans.factory.FactoryBean</code> interface for objects that
are themselves factories.</p>
</div>
<div class="paragraph">
<p>The <code>FactoryBean</code> interface is a point of pluggability into the Spring IoC container&#8217;s
instantiation logic. If you have complex initialization code that is better expressed in
Java as opposed to a (potentially) verbose amount of XML, you can create your own
<code>FactoryBean</code>, write the complex initialization inside that class, and then plug your
custom <code>FactoryBean</code> into the container.</p>
</div>
<div class="paragraph">
<p>The <code>FactoryBean&lt;T&gt;</code> interface provides three methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>T getObject()</code>: Returns an instance of the object this factory creates. The
instance can possibly be shared, depending on whether this factory returns singletons
or prototypes.</p>
</li>
<li>
<p><code>boolean isSingleton()</code>: Returns <code>true</code> if this <code>FactoryBean</code> returns singletons or
<code>false</code> otherwise. The default implementation of this method returns <code>true</code>.</p>
</li>
<li>
<p><code>Class&lt;?&gt; getObjectType()</code>: Returns the object type returned by the <code>getObject()</code> method
or <code>null</code> if the type is not known in advance.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>FactoryBean</code> concept and interface are used in a number of places within the Spring
Framework. More than 50 implementations of the <code>FactoryBean</code> interface ship with Spring
itself.</p>
</div>
<div class="paragraph">
<p>When you need to ask a container for an actual <code>FactoryBean</code> instance itself instead of
the bean it produces, prefix the bean&#8217;s <code>id</code> with the ampersand symbol (<code>&amp;</code>) when
calling the <code>getBean()</code> method of the <code>ApplicationContext</code>. So, for a given <code>FactoryBean</code>
with an <code>id</code> of <code>myBean</code>, invoking <code>getBean("myBean")</code> on the container returns the
product of the <code>FactoryBean</code>, whereas invoking <code>getBean("&amp;myBean")</code> returns the
<code>FactoryBean</code> instance itself.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-annotation-config"><a class="anchor" href="#beans-annotation-config"></a>1.9. Annotation-based Container Configuration</h3>
<div class="sidebarblock">
<div class="content">
<div class="title">Are annotations better than XML for configuring Spring?</div>
<div class="paragraph">
<p>The introduction of annotation-based configuration raised the question of whether this
approach is &#8220;better&#8221; than XML. The short answer is &#8220;it depends.&#8221; The long answer is
that each approach has its pros and cons, and, usually, it is up to the developer to
decide which strategy suits them better. Due to the way they are defined, annotations
provide a lot of context in their declaration, leading to shorter and more concise
configuration. However, XML excels at wiring up components without touching their source
code or recompiling them. Some developers prefer having the wiring close to the source
while others argue that annotated classes are no longer POJOs and, furthermore, that the
configuration becomes decentralized and harder to control.</p>
</div>
<div class="paragraph">
<p>No matter the choice, Spring can accommodate both styles and even mix them together.
It is worth pointing out that through its <a href="#beans-java">JavaConfig</a> option, Spring lets
annotations be used in a non-invasive way, without touching the target components
source code and that, in terms of tooling, all configuration styles are supported by the
<a href="https://spring.io/tools">Spring Tools for Eclipse</a>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>An alternative to XML setup is provided by annotation-based configuration, which relies on
the bytecode metadata for wiring up components instead of angle-bracket declarations.
Instead of using XML to describe a bean wiring, the developer moves the configuration
into the component class itself by using annotations on the relevant class, method, or
field declaration. As mentioned in <a href="#beans-factory-extension-bpp-examples-aabpp">Example: The <code>AutowiredAnnotationBeanPostProcessor</code></a>, using
a <code>BeanPostProcessor</code> in conjunction with annotations is a common means of extending the
Spring IoC container. For example, Spring 2.0 introduced the possibility of enforcing
required properties with the <a href="#beans-required-annotation"><code>@Required</code></a> annotation. Spring
2.5 made it possible to follow that same general approach to drive Spring&#8217;s dependency
injection. Essentially, the <code>@Autowired</code> annotation provides the same capabilities as
described in <a href="#beans-factory-autowire">Autowiring Collaborators</a> but with more fine-grained control and wider
applicability. Spring 2.5 also added support for JSR-250 annotations, such as
<code>@PostConstruct</code> and <code>@PreDestroy</code>. Spring 3.0 added support for JSR-330 (Dependency
Injection for Java) annotations contained in the <code>javax.inject</code> package such as <code>@Inject</code>
and <code>@Named</code>. Details about those annotations can be found in the
<a href="#beans-standard-annotations">relevant section</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Annotation injection is performed before XML injection. Thus, the XML configuration
overrides the annotations for properties wired through both approaches.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As always, you can register the post-processors as individual bean definitions, but they
can also be implicitly registered by including the following tag in an XML-based Spring
configuration (notice the inclusion of the <code>context</code> namespace):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;context:annotation-config/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>&lt;context:annotation-config/&gt;</code> element implicitly registers the following post-processors:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/context/annotation/ConfigurationClassPostProcessor.html"><code>ConfigurationClassPostProcessor</code></a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html"><code>AutowiredAnnotationBeanPostProcessor</code></a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html"><code>CommonAnnotationBeanPostProcessor</code></a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html"><code>PersistenceAnnotationBeanPostProcessor</code></a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/context/event/EventListenerMethodProcessor.html"><code>EventListenerMethodProcessor</code></a></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>&lt;context:annotation-config/&gt;</code> only looks for annotations on beans in the same
application context in which it is defined. This means that, if you put
<code>&lt;context:annotation-config/&gt;</code> in a <code>WebApplicationContext</code> for a <code>DispatcherServlet</code>,
it only checks for <code>@Autowired</code> beans in your controllers, and not your services. See
<a href="web.html#mvc-servlet">The DispatcherServlet</a> for more information.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-required-annotation"><a class="anchor" href="#beans-required-annotation"></a>1.9.1. @Required</h4>
<div class="paragraph">
<p>The <code>@Required</code> annotation applies to bean property setter methods, as in the following
example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Required
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">    class SimpleMovieLister {

    @Required
    lateinit var movieFinder: MovieFinder

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This annotation indicates that the affected bean property must be populated at
configuration time, through an explicit property value in a bean definition or through
autowiring. The container throws an exception if the affected bean property has not been
populated. This allows for eager and explicit failure, avoiding <code>NullPointerException</code>
instances or the like later on. We still recommend that you put assertions into the
bean class itself (for example, into an init method). Doing so enforces those required
references and values even when you use the class outside of a container.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html"><code>RequiredAnnotationBeanPostProcessor</code></a>
must be registered as a bean to enable support for the <code>@Required</code> annotation.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>@Required</code> annotation and <code>RequiredAnnotationBeanPostProcessor</code> are formally
deprecated as of Spring Framework 5.1, in favor of using constructor injection for
required settings (or a custom implementation of <code>InitializingBean.afterPropertiesSet()</code>
or a custom <code>@PostConstruct</code> method along with bean property setter methods).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-autowired-annotation"><a class="anchor" href="#beans-autowired-annotation"></a>1.9.2. Using <code>@Autowired</code></h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>JSR 330&#8217;s <code>@Inject</code> annotation can be used in place of Spring&#8217;s <code>@Autowired</code> annotation in the
examples included in this section. See <a href="#beans-standard-annotations">here</a> for more details.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can apply the <code>@Autowired</code> annotation to constructors, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class MovieRecommender {

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class MovieRecommender @Autowired constructor(
    private val customerPreferenceDao: CustomerPreferenceDao)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As of Spring Framework 4.3, an <code>@Autowired</code> annotation on such a constructor is no longer
necessary if the target bean defines only one constructor to begin with. However, if
several constructors are available and there is no primary/default constructor, at least
one of the constructors must be annotated with <code>@Autowired</code> in order to instruct the
container which one to use. See the discussion on
<a href="#beans-autowired-annotation-constructor-resolution">constructor resolution</a> for details.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also apply the <code>@Autowired</code> annotation to <em>traditional</em> setter methods,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class SimpleMovieLister {

    @Autowired
    lateinit var movieFinder: MovieFinder

    // ...

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also apply the annotation to methods with arbitrary names and multiple
arguments, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class MovieRecommender {

    private MovieCatalog movieCatalog;

    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(MovieCatalog movieCatalog,
            CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class MovieRecommender {

    private lateinit var movieCatalog: MovieCatalog

    private lateinit var customerPreferenceDao: CustomerPreferenceDao

    @Autowired
    fun prepare(movieCatalog: MovieCatalog,
                customerPreferenceDao: CustomerPreferenceDao) {
        this.movieCatalog = movieCatalog
        this.customerPreferenceDao = customerPreferenceDao
    }

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can apply <code>@Autowired</code> to fields as well and even mix it with constructors, as the
following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class MovieRecommender {

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    private MovieCatalog movieCatalog;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class MovieRecommender @Autowired constructor(
    private val customerPreferenceDao: CustomerPreferenceDao) {

    @Autowired
    private lateinit var movieCatalog: MovieCatalog

    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Make sure that your target components (for example, <code>MovieCatalog</code> or <code>CustomerPreferenceDao</code>)
are consistently declared by the type that you use for your <code>@Autowired</code>-annotated
injection points. Otherwise, injection may fail due to a "no type match found" error at runtime.</p>
</div>
<div class="paragraph">
<p>For XML-defined beans or component classes found via classpath scanning, the container
usually knows the concrete type up front. However, for <code>@Bean</code> factory methods, you need
to make sure that the declared return type is sufficiently expressive. For components
that implement several interfaces or for components potentially referred to by their
implementation type, consider declaring the most specific return type on your factory
method (at least as specific as required by the injection points referring to your bean).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also instruct Spring to provide all beans of a particular type from the
<code>ApplicationContext</code> by adding the <code>@Autowired</code> annotation to a field or method that
expects an array of that type, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class MovieRecommender {

    @Autowired
    private MovieCatalog[] movieCatalogs;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class MovieRecommender {

    @Autowired
    private lateinit var movieCatalogs: Array&lt;MovieCatalog&gt;

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same applies for typed collections, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class MovieRecommender {

    private Set&lt;MovieCatalog&gt; movieCatalogs;

    @Autowired
    public void setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class MovieRecommender {

    @Autowired
    lateinit var movieCatalogs: Set&lt;MovieCatalog&gt;

    // ...
}</code></pre>
</div>
</div>
<div id="beans-factory-ordered" class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Your target beans can implement the <code>org.springframework.core.Ordered</code> interface or use
the <code>@Order</code> or standard <code>@Priority</code> annotation if you want items in the array or list
to be sorted in a specific order. Otherwise, their order follows the registration
order of the corresponding target bean definitions in the container.</p>
</div>
<div class="paragraph">
<p>You can declare the <code>@Order</code> annotation at the target class level and on <code>@Bean</code> methods,
potentially for individual bean definitions (in case of multiple definitions that
use the same bean class). <code>@Order</code> values may influence priorities at injection points,
but be aware that they do not influence singleton startup order, which is an
orthogonal concern determined by dependency relationships and <code>@DependsOn</code> declarations.</p>
</div>
<div class="paragraph">
<p>Note that the standard <code>javax.annotation.Priority</code> annotation is not available at the
<code>@Bean</code> level, since it cannot be declared on methods. Its semantics can be modeled
through <code>@Order</code> values in combination with <code>@Primary</code> on a single bean for each type.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Even typed <code>Map</code> instances can be autowired as long as the expected key type is <code>String</code>.
The map values contain all beans of the expected type, and the keys contain the
corresponding bean names, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class MovieRecommender {

    private Map&lt;String, MovieCatalog&gt; movieCatalogs;

    @Autowired
    public void setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class MovieRecommender {

    @Autowired
    lateinit var movieCatalogs: Map&lt;String, MovieCatalog&gt;

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, autowiring fails when no matching candidate beans are available for a given
injection point. In the case of a declared array, collection, or map, at least one
matching element is expected.</p>
</div>
<div class="paragraph">
<p>The default behavior is to treat annotated methods and fields as indicating required
dependencies. You can change this behavior as demonstrated in the following example,
enabling the framework to skip a non-satisfiable injection point through marking it as
non-required (i.e., by setting the <code>required</code> attribute in <code>@Autowired</code> to <code>false</code>):</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired(required = false)
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class SimpleMovieLister {

    @Autowired(required = false)
    var movieFinder: MovieFinder? = null

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A non-required method will not be called at all if its dependency (or one of its
dependencies, in case of multiple arguments) is not available. A non-required field will
not get populated at all in such cases, leaving its default value in place.</p>
</div>
<div id="beans-autowired-annotation-constructor-resolution" class="paragraph">
<p>Injected constructor and factory method arguments are a special case since the <code>required</code>
attribute in <code>@Autowired</code> has a somewhat different meaning due to Spring&#8217;s constructor
resolution algorithm that may potentially deal with multiple constructors. Constructor
and factory method arguments are effectively required by default but with a few special
rules in a single-constructor scenario, such as multi-element injection points (arrays,
collections, maps) resolving to empty instances if no matching beans are available. This
allows for a common implementation pattern where all dependencies can be declared in a
unique multi-argument constructor — for example, declared as a single public constructor
without an <code>@Autowired</code> annotation.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Only one constructor of any given bean class may declare <code>@Autowired</code> with the <code>required</code>
attribute set to <code>true</code>, indicating <em>the</em> constructor to autowire when used as a Spring
bean. As a consequence, if the <code>required</code> attribute is left at its default value <code>true</code>,
only a single constructor may be annotated with <code>@Autowired</code>. If multiple constructors
declare the annotation, they will all have to declare <code>required=false</code> in order to be
considered as candidates for autowiring (analogous to <code>autowire=constructor</code> in XML).
The constructor with the greatest number of dependencies that can be satisfied by matching
beans in the Spring container will be chosen. If none of the candidates can be satisfied,
then a primary/default constructor (if present) will be used. Similarly, if a class
declares multiple constructors but none of them is annotated with <code>@Autowired</code>, then a
primary/default constructor (if present) will be used. If a class only declares a single
constructor to begin with, it will always be used, even if not annotated. Note that an
annotated constructor does not have to be public.</p>
</div>
<div class="paragraph">
<p>The <code>required</code> attribute of <code>@Autowired</code> is recommended over the deprecated <code>@Required</code>
annotation on setter methods. Setting the <code>required</code> attribute to <code>false</code> indicates that
the property is not required for autowiring purposes, and the property is ignored if it
cannot be autowired. <code>@Required</code>, on the other hand, is stronger in that it enforces the
property to be set by any means supported by the container, and if no value is defined,
a corresponding exception is raised.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Alternatively, you can express the non-required nature of a particular dependency
through Java 8&#8217;s <code>java.util.Optional</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class SimpleMovieLister {

    @Autowired
    public void setMovieFinder(Optional&lt;MovieFinder&gt; movieFinder) {
        ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As of Spring Framework 5.0, you can also use a <code>@Nullable</code> annotation (of any kind
in any package&#8201;&#8212;&#8201;for example, <code>javax.annotation.Nullable</code> from JSR-305) or just leverage
Kotlin builtin null-safety support:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class SimpleMovieLister {

    @Autowired
    public void setMovieFinder(@Nullable MovieFinder movieFinder) {
        ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class SimpleMovieLister {

    @Autowired
    var movieFinder: MovieFinder? = null

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also use <code>@Autowired</code> for interfaces that are well-known resolvable
dependencies: <code>BeanFactory</code>, <code>ApplicationContext</code>, <code>Environment</code>, <code>ResourceLoader</code>,
<code>ApplicationEventPublisher</code>, and <code>MessageSource</code>. These interfaces and their extended
interfaces, such as <code>ConfigurableApplicationContext</code> or <code>ResourcePatternResolver</code>, are
automatically resolved, with no special setup necessary. The following example autowires
an <code>ApplicationContext</code> object:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class MovieRecommender {

    @Autowired
    private ApplicationContext context;

    public MovieRecommender() {
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class MovieRecommender {

    @Autowired
    lateinit var context: ApplicationContext

    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>@Autowired</code>, <code>@Inject</code>, <code>@Value</code>, and <code>@Resource</code> annotations are handled by Spring
<code>BeanPostProcessor</code> implementations. This means that you cannot apply these annotations
within your own <code>BeanPostProcessor</code> or <code>BeanFactoryPostProcessor</code> types (if any).
These types must be 'wired up' explicitly by using XML or a Spring <code>@Bean</code> method.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-autowired-annotation-primary"><a class="anchor" href="#beans-autowired-annotation-primary"></a>1.9.3. Fine-tuning Annotation-based Autowiring with <code>@Primary</code></h4>
<div class="paragraph">
<p>Because autowiring by type may lead to multiple candidates, it is often necessary to have
more control over the selection process. One way to accomplish this is with Spring&#8217;s
<code>@Primary</code> annotation. <code>@Primary</code> indicates that a particular bean should be given
preference when multiple beans are candidates to be autowired to a single-valued
dependency. If exactly one primary bean exists among the candidates, it becomes the
autowired value.</p>
</div>
<div class="paragraph">
<p>Consider the following configuration that defines <code>firstMovieCatalog</code> as the
primary <code>MovieCatalog</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class MovieConfiguration {

    @Bean
    @Primary
    public MovieCatalog firstMovieCatalog() { ... }

    @Bean
    public MovieCatalog secondMovieCatalog() { ... }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
class MovieConfiguration {

    @Bean
    @Primary
    fun firstMovieCatalog(): MovieCatalog { ... }

    @Bean
    fun secondMovieCatalog(): MovieCatalog { ... }

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the preceding configuration, the following <code>MovieRecommender</code> is autowired with the
<code>firstMovieCatalog</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class MovieRecommender {

    @Autowired
    private MovieCatalog movieCatalog;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class MovieRecommender {

    @Autowired
    private lateinit var movieCatalog: MovieCatalog

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The corresponding bean definitions follow:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class="example.SimpleMovieCatalog" primary="true"&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean id="movieRecommender" class="example.MovieRecommender"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-autowired-annotation-qualifiers"><a class="anchor" href="#beans-autowired-annotation-qualifiers"></a>1.9.4. Fine-tuning Annotation-based Autowiring with Qualifiers</h4>
<div class="paragraph">
<p><code>@Primary</code> is an effective way to use autowiring by type with several instances when one
primary candidate can be determined. When you need more control over the selection process,
you can use Spring&#8217;s <code>@Qualifier</code> annotation. You can associate qualifier values
with specific arguments, narrowing the set of type matches so that a specific bean is
chosen for each argument. In the simplest case, this can be a plain descriptive value, as
shown in the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class MovieRecommender {

    @Autowired
    @Qualifier("main")
    private MovieCatalog movieCatalog;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class MovieRecommender {

    @Autowired
    @Qualifier("main")
    private lateinit var movieCatalog: MovieCatalog

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also specify the <code>@Qualifier</code> annotation on individual constructor arguments or
method parameters, as shown in the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class MovieRecommender {

    private MovieCatalog movieCatalog;

    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(@Qualifier("main") MovieCatalog movieCatalog,
            CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class MovieRecommender {

    private lateinit var movieCatalog: MovieCatalog

    private lateinit var customerPreferenceDao: CustomerPreferenceDao

    @Autowired
    fun prepare(@Qualifier("main") movieCatalog: MovieCatalog,
                customerPreferenceDao: CustomerPreferenceDao) {
        this.movieCatalog = movieCatalog
        this.customerPreferenceDao = customerPreferenceDao
    }

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows corresponding bean definitions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;qualifier value="main"/&gt; <i class="conum" data-value="1"></i><b>(1)</b>

        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;qualifier value="action"/&gt; <i class="conum" data-value="2"></i><b>(2)</b>

        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean id="movieRecommender" class="example.MovieRecommender"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The bean with the <code>main</code> qualifier value is wired with the constructor argument that
is qualified with the same value.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The bean with the <code>action</code> qualifier value is wired with the constructor argument that
is qualified with the same value.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For a fallback match, the bean name is considered a default qualifier value. Thus, you
can define the bean with an <code>id</code> of <code>main</code> instead of the nested qualifier element, leading
to the same matching result. However, although you can use this convention to refer to
specific beans by name, <code>@Autowired</code> is fundamentally about type-driven injection with
optional semantic qualifiers. This means that qualifier values, even with the bean name
fallback, always have narrowing semantics within the set of type matches. They do not
semantically express a reference to a unique bean <code>id</code>. Good qualifier values are <code>main</code>
or <code>EMEA</code> or <code>persistent</code>, expressing characteristics of a specific component that are
independent from the bean <code>id</code>, which may be auto-generated in case of an anonymous bean
definition such as the one in the preceding example.</p>
</div>
<div class="paragraph">
<p>Qualifiers also apply to typed collections, as discussed earlier&#8201;&#8212;&#8201;for example, to
<code>Set&lt;MovieCatalog&gt;</code>. In this case, all matching beans, according to the declared
qualifiers, are injected as a collection. This implies that qualifiers do not have to be
unique. Rather, they constitute filtering criteria. For example, you can define
multiple <code>MovieCatalog</code> beans with the same qualifier value &#8220;action&#8221;, all of which are
injected into a <code>Set&lt;MovieCatalog&gt;</code> annotated with <code>@Qualifier("action")</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Letting qualifier values select against target bean names, within the type-matching
candidates, does not require a <code>@Qualifier</code> annotation at the injection point.
If there is no other resolution indicator (such as a qualifier or a primary marker),
for a non-unique dependency situation, Spring matches the injection point name
(that is, the field name or parameter name) against the target bean names and choose the
same-named candidate, if any.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>That said, if you intend to express annotation-driven injection by name, do not
primarily use <code>@Autowired</code>, even if it is capable of selecting by bean name among
type-matching candidates. Instead, use the JSR-250 <code>@Resource</code> annotation, which is
semantically defined to identify a specific target component by its unique name, with
the declared type being irrelevant for the matching process. <code>@Autowired</code> has rather
different semantics: After selecting candidate beans by type, the specified <code>String</code>
qualifier value is considered within those type-selected candidates only (for example,
matching an <code>account</code> qualifier against beans marked with the same qualifier label).</p>
</div>
<div class="paragraph">
<p>For beans that are themselves defined as a collection, <code>Map</code>, or array type, <code>@Resource</code>
is a fine solution, referring to the specific collection or array bean by unique name.
That said, as of 4.3, collection, you can match <code>Map</code>, and array types through Spring&#8217;s
<code>@Autowired</code> type matching algorithm as well, as long as the element type information
is preserved in <code>@Bean</code> return type signatures or collection inheritance hierarchies.
In this case, you can use qualifier values to select among same-typed collections,
as outlined in the previous paragraph.</p>
</div>
<div class="paragraph">
<p>As of 4.3, <code>@Autowired</code> also considers self references for injection (that is, references
back to the bean that is currently injected). Note that self injection is a fallback.
Regular dependencies on other components always have precedence. In that sense, self
references do not participate in regular candidate selection and are therefore in
particular never primary. On the contrary, they always end up as lowest precedence.
In practice, you should use self references as a last resort only (for example, for
calling other methods on the same instance through the bean&#8217;s transactional proxy).
Consider factoring out the affected methods to a separate delegate bean in such a scenario.
Alternatively, you can use <code>@Resource</code>, which may obtain a proxy back to the current bean
by its unique name.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Trying to inject the results from <code>@Bean</code> methods on the same configuration class is
effectively a self-reference scenario as well. Either lazily resolve such references
in the method signature where it is actually needed (as opposed to an autowired field
in the configuration class) or declare the affected <code>@Bean</code> methods as <code>static</code>,
decoupling them from the containing configuration class instance and its lifecycle.
Otherwise, such beans are only considered in the fallback phase, with matching beans
on other configuration classes selected as primary candidates instead (if available).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>@Autowired</code> applies to fields, constructors, and multi-argument methods, allowing for
narrowing through qualifier annotations at the parameter level. In contrast, <code>@Resource</code>
is supported only for fields and bean property setter methods with a single argument.
As a consequence, you should stick with qualifiers if your injection target is a
constructor or a multi-argument method.</p>
</div>
<div class="paragraph">
<p>You can create your own custom qualifier annotations. To do so, define an annotation and
provide the <code>@Qualifier</code> annotation within your definition, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Genre {

    String value();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Target(AnnotationTarget.FIELD, AnnotationTarget.VALUE_PARAMETER)
@Retention(AnnotationRetention.RUNTIME)
@Qualifier
annotation class Genre(val value: String)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then you can provide the custom qualifier on autowired fields and parameters, as the
following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class MovieRecommender {

    @Autowired
    @Genre("Action")
    private MovieCatalog actionCatalog;

    private MovieCatalog comedyCatalog;

    @Autowired
    public void setComedyCatalog(@Genre("Comedy") MovieCatalog comedyCatalog) {
        this.comedyCatalog = comedyCatalog;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class MovieRecommender {

    @Autowired
    @Genre("Action")
    private lateinit var actionCatalog: MovieCatalog

    private lateinit var comedyCatalog: MovieCatalog

    @Autowired
    fun setComedyCatalog(@Genre("Comedy") comedyCatalog: MovieCatalog) {
        this.comedyCatalog = comedyCatalog
    }

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, you can provide the information for the candidate bean definitions. You can add
<code>&lt;qualifier/&gt;</code> tags as sub-elements of the <code>&lt;bean/&gt;</code> tag and then specify the <code>type</code> and
<code>value</code> to match your custom qualifier annotations. The type is matched against the
fully-qualified class name of the annotation. Alternately, as a convenience if no risk of
conflicting names exists, you can use the short class name. The following example
demonstrates both approaches:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;qualifier type="Genre" value="Action"/&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;qualifier type="example.Genre" value="Comedy"/&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean id="movieRecommender" class="example.MovieRecommender"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In <a href="#beans-classpath-scanning">Classpath Scanning and Managed Components</a>, you can see an annotation-based alternative to
providing the qualifier metadata in XML. Specifically, see <a href="#beans-scanning-qualifiers">Providing Qualifier Metadata with Annotations</a>.</p>
</div>
<div class="paragraph">
<p>In some cases, using an annotation without a value may suffice. This can be
useful when the annotation serves a more generic purpose and can be applied across
several different types of dependencies. For example, you may provide an offline
catalog that can be searched when no Internet connection is available. First, define
the simple annotation, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Offline {

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Target(AnnotationTarget.FIELD, AnnotationTarget.VALUE_PARAMETER)
@Retention(AnnotationRetention.RUNTIME)
@Qualifier
annotation class Offline</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then add the annotation to the field or property to be autowired, as shown in the
following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class MovieRecommender {

    @Autowired
    @Offline <i class="conum" data-value="1"></i><b>(1)</b>
    private MovieCatalog offlineCatalog;

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This line adds the <code>@Offline</code> annotation.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class MovieRecommender {

    @Autowired
    @Offline <i class="conum" data-value="1"></i><b>(1)</b>
    private lateinit var offlineCatalog: MovieCatalog

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This line adds the <code>@Offline</code> annotation.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Now the bean definition only needs a qualifier <code>type</code>, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean class="example.SimpleMovieCatalog"&gt;
    &lt;qualifier type="Offline"/&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;!-- inject any dependencies required by this bean --&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This element specifies the qualifier.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also define custom qualifier annotations that accept named attributes in
addition to or instead of the simple <code>value</code> attribute. If multiple attribute values are
then specified on a field or parameter to be autowired, a bean definition must match
all such attribute values to be considered an autowire candidate. As an example,
consider the following annotation definition:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface MovieQualifier {

    String genre();

    Format format();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Target(AnnotationTarget.FIELD, AnnotationTarget.VALUE_PARAMETER)
@Retention(AnnotationRetention.RUNTIME)
@Qualifier
annotation class MovieQualifier(val genre: String, val format: Format)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case <code>Format</code> is an enum, defined as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public enum Format {
    VHS, DVD, BLURAY
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">enum class Format {
    VHS, DVD, BLURAY
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The fields to be autowired are annotated with the custom qualifier and include values
for both attributes: <code>genre</code> and <code>format</code>, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class MovieRecommender {

    @Autowired
    @MovieQualifier(format=Format.VHS, genre="Action")
    private MovieCatalog actionVhsCatalog;

    @Autowired
    @MovieQualifier(format=Format.VHS, genre="Comedy")
    private MovieCatalog comedyVhsCatalog;

    @Autowired
    @MovieQualifier(format=Format.DVD, genre="Action")
    private MovieCatalog actionDvdCatalog;

    @Autowired
    @MovieQualifier(format=Format.BLURAY, genre="Comedy")
    private MovieCatalog comedyBluRayCatalog;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class MovieRecommender {

    @Autowired
    @MovieQualifier(format = Format.VHS, genre = "Action")
    private lateinit var actionVhsCatalog: MovieCatalog

    @Autowired
    @MovieQualifier(format = Format.VHS, genre = "Comedy")
    private lateinit var comedyVhsCatalog: MovieCatalog

    @Autowired
    @MovieQualifier(format = Format.DVD, genre = "Action")
    private lateinit var actionDvdCatalog: MovieCatalog

    @Autowired
    @MovieQualifier(format = Format.BLURAY, genre = "Comedy")
    private lateinit var comedyBluRayCatalog: MovieCatalog

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, the bean definitions should contain matching qualifier values. This example
also demonstrates that you can use bean meta attributes instead of the
<code>&lt;qualifier/&gt;</code> elements. If available, the <code>&lt;qualifier/&gt;</code> element and its attributes take
precedence, but the autowiring mechanism falls back on the values provided within the
<code>&lt;meta/&gt;</code> tags if no such qualifier is present, as in the last two bean definitions in
the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;qualifier type="MovieQualifier"&gt;
            &lt;attribute key="format" value="VHS"/&gt;
            &lt;attribute key="genre" value="Action"/&gt;
        &lt;/qualifier&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;qualifier type="MovieQualifier"&gt;
            &lt;attribute key="format" value="VHS"/&gt;
            &lt;attribute key="genre" value="Comedy"/&gt;
        &lt;/qualifier&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;meta key="format" value="DVD"/&gt;
        &lt;meta key="genre" value="Action"/&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;meta key="format" value="BLURAY"/&gt;
        &lt;meta key="genre" value="Comedy"/&gt;
        &lt;!-- inject any dependencies required by this bean --&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-generics-as-qualifiers"><a class="anchor" href="#beans-generics-as-qualifiers"></a>1.9.5. Using Generics as Autowiring Qualifiers</h4>
<div class="paragraph">
<p>In addition to the <code>@Qualifier</code> annotation, you can use Java generic types
as an implicit form of qualification. For example, suppose you have the following
configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class MyConfiguration {

    @Bean
    public StringStore stringStore() {
        return new StringStore();
    }

    @Bean
    public IntegerStore integerStore() {
        return new IntegerStore();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
class MyConfiguration {

    @Bean
    fun stringStore() = StringStore()

    @Bean
    fun integerStore() = IntegerStore()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assuming that the preceding beans implement a generic interface, (that is, <code>Store&lt;String&gt;</code> and
<code>Store&lt;Integer&gt;</code>), you can <code>@Autowire</code> the <code>Store</code> interface and the generic is
used as a qualifier, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Autowired
private Store&lt;String&gt; s1; // &lt;String&gt; qualifier, injects the stringStore bean

@Autowired
private Store&lt;Integer&gt; s2; // &lt;Integer&gt; qualifier, injects the integerStore bean</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Autowired
private lateinit var s1: Store&lt;String&gt; // &lt;String&gt; qualifier, injects the stringStore bean

@Autowired
private lateinit var s2: Store&lt;Integer&gt; // &lt;Integer&gt; qualifier, injects the integerStore bean</code></pre>
</div>
</div>
<div class="paragraph">
<p>Generic qualifiers also apply when autowiring lists, <code>Map</code> instances and arrays. The
following example autowires a generic <code>List</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// Inject all Store beans as long as they have an &lt;Integer&gt; generic
// Store&lt;String&gt; beans will not appear in this list
@Autowired
private List&lt;Store&lt;Integer&gt;&gt; s;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Inject all Store beans as long as they have an &lt;Integer&gt; generic
// Store&lt;String&gt; beans will not appear in this list
@Autowired
private lateinit var s: List&lt;Store&lt;Integer&gt;&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-custom-autowire-configurer"><a class="anchor" href="#beans-custom-autowire-configurer"></a>1.9.6. Using <code>CustomAutowireConfigurer</code></h4>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.html"><code>CustomAutowireConfigurer</code></a>
is a <code>BeanFactoryPostProcessor</code> that lets you register your own custom qualifier
annotation types, even if they are not annotated with Spring&#8217;s <code>@Qualifier</code> annotation.
The following example shows how to use <code>CustomAutowireConfigurer</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="customAutowireConfigurer"
        class="org.springframework.beans.factory.annotation.CustomAutowireConfigurer"&gt;
    &lt;property name="customQualifierTypes"&gt;
        &lt;set&gt;
            &lt;value&gt;example.CustomQualifier&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>AutowireCandidateResolver</code> determines autowire candidates by:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>autowire-candidate</code> value of each bean definition</p>
</li>
<li>
<p>Any <code>default-autowire-candidates</code> patterns available on the <code>&lt;beans/&gt;</code> element</p>
</li>
<li>
<p>The presence of <code>@Qualifier</code> annotations and any custom annotations registered
with the <code>CustomAutowireConfigurer</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When multiple beans qualify as autowire candidates, the determination of a &#8220;primary&#8221; is
as follows: If exactly one bean definition among the candidates has a <code>primary</code>
attribute set to <code>true</code>, it is selected.</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-resource-annotation"><a class="anchor" href="#beans-resource-annotation"></a>1.9.7. Injection with <code>@Resource</code></h4>
<div class="paragraph">
<p>Spring also supports injection by using the JSR-250 <code>@Resource</code> annotation
(<code>javax.annotation.Resource</code>) on fields or bean property setter methods.
This is a common pattern in Java EE: for example, in JSF-managed beans and JAX-WS
endpoints. Spring supports this pattern for Spring-managed objects as well.</p>
</div>
<div class="paragraph">
<p><code>@Resource</code> takes a name attribute. By default, Spring interprets that value as
the bean name to be injected. In other words, it follows by-name semantics,
as demonstrated in the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Resource(name="myMovieFinder") <i class="conum" data-value="1"></i><b>(1)</b>
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This line injects a <code>@Resource</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class SimpleMovieLister {

    @Resource(name="myMovieFinder") <i class="conum" data-value="1"></i><b>(1)</b>
    private lateinit var movieFinder:MovieFinder
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This line injects a <code>@Resource</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If no name is explicitly specified, the default name is derived from the field name or
setter method. In case of a field, it takes the field name. In case of a setter method,
it takes the bean property name. The following example is going to have the bean
named <code>movieFinder</code> injected into its setter method:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Resource
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class SimpleMovieLister {

    @Resource
    private lateinit var movieFinder: MovieFinder

}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The name provided with the annotation is resolved as a bean name by the
<code>ApplicationContext</code> of which the <code>CommonAnnotationBeanPostProcessor</code> is aware.
The names can be resolved through JNDI if you configure Spring&#8217;s
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/jndi/support/SimpleJndiBeanFactory.html"><code>SimpleJndiBeanFactory</code></a>
explicitly. However, we recommend that you rely on the default behavior and
use Spring&#8217;s JNDI lookup capabilities to preserve the level of indirection.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the exclusive case of <code>@Resource</code> usage with no explicit name specified, and similar
to <code>@Autowired</code>, <code>@Resource</code> finds a primary type match instead of a specific named bean
and resolves well known resolvable dependencies: the <code>BeanFactory</code>,
<code>ApplicationContext</code>, <code>ResourceLoader</code>, <code>ApplicationEventPublisher</code>, and <code>MessageSource</code>
interfaces.</p>
</div>
<div class="paragraph">
<p>Thus, in the following example, the <code>customerPreferenceDao</code> field first looks for a bean
named "customerPreferenceDao" and then falls back to a primary type match for the type
<code>CustomerPreferenceDao</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class MovieRecommender {

    @Resource
    private CustomerPreferenceDao customerPreferenceDao;

    @Resource
    private ApplicationContext context; <i class="conum" data-value="1"></i><b>(1)</b>

    public MovieRecommender() {
    }

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>context</code> field is injected based on the known resolvable dependency type:
<code>ApplicationContext</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class MovieRecommender {

    @Resource
    private lateinit var customerPreferenceDao: CustomerPreferenceDao


    @Resource
    private lateinit var context: ApplicationContext <i class="conum" data-value="1"></i><b>(1)</b>

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>context</code> field is injected based on the known resolvable dependency type:
<code>ApplicationContext</code>.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-value-annotations"><a class="anchor" href="#beans-value-annotations"></a>1.9.8. Using <code>@Value</code></h4>
<div class="paragraph">
<p><code>@Value</code> is typically used to inject externalized properties:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value("${catalog.name}") String catalog) {
        this.catalog = catalog;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Component
class MovieRecommender(@Value("\${catalog.name}") private val catalog: String)</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the following configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@PropertySource("classpath:application.properties")
public class AppConfig { }</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@PropertySource("classpath:application.properties")
class AppConfig</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the following <code>application.properties</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">catalog.name=MovieCatalog</code></pre>
</div>
</div>
<div class="paragraph">
<p>In that case, the <code>catalog</code> parameter and field will be equal to the <code>MovieCatalog</code> value.</p>
</div>
<div class="paragraph">
<p>A default lenient embedded value resolver is provided by Spring. It will try to resolve the
property value and if it cannot be resolved, the property name (for example <code>${catalog.name}</code>)
will be injected as the value. If you want to maintain strict control over nonexistent
values, you should declare a <code>PropertySourcesPlaceholderConfigurer</code> bean, as the following
example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class AppConfig {

     @Bean
     public static PropertySourcesPlaceholderConfigurer propertyPlaceholderConfigurer() {
           return new PropertySourcesPlaceholderConfigurer();
     }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
class AppConfig {

    @Bean
    fun propertyPlaceholderConfigurer() = PropertySourcesPlaceholderConfigurer()
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When configuring a <code>PropertySourcesPlaceholderConfigurer</code> using JavaConfig, the
<code>@Bean</code> method must be <code>static</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Using the above configuration ensures Spring initialization failure if any <code>${}</code>
placeholder could not be resolved. It is also possible to use methods like
<code>setPlaceholderPrefix</code>, <code>setPlaceholderSuffix</code>, or <code>setValueSeparator</code> to customize
placeholders.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Boot configures by default a <code>PropertySourcesPlaceholderConfigurer</code> bean that
will get properties from <code>application.properties</code> and <code>application.yml</code> files.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Built-in converter support provided by Spring allows simple type conversion (to <code>Integer</code>
or <code>int</code> for example) to be automatically handled. Multiple comma-separated values can be
automatically converted to String array without extra effort.</p>
</div>
<div class="paragraph">
<p>It is possible to provide a default value as following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value("${catalog.name:defaultCatalog}") String catalog) {
        this.catalog = catalog;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Component
class MovieRecommender(@Value("\${catalog.name:defaultCatalog}") private val catalog: String)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A Spring <code>BeanPostProcessor</code> uses a <code>ConversionService</code> behind the scene to handle the
process for converting the String value in <code>@Value</code> to the target type. If you want to
provide conversion support for your own custom type, you can provide your own
<code>ConversionService</code> bean instance as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class AppConfig {

    @Bean
    public ConversionService conversionService() {
        DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService();
        conversionService.addConverter(new MyCustomConverter());
        return conversionService;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
class AppConfig {

    @Bean
    fun conversionService(): ConversionService {
            return DefaultFormattingConversionService().apply {
            addConverter(MyCustomConverter())
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When <code>@Value</code> contains a <a href="#expressions"><code>SpEL</code> expression</a> the value will be dynamically
computed at runtime as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Component
public class MovieRecommender {

    private final String catalog;

    public MovieRecommender(@Value("#{systemProperties['user.catalog'] + 'Catalog' }") String catalog) {
        this.catalog = catalog;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Component
class MovieRecommender(
    @Value("#{systemProperties['user.catalog'] + 'Catalog' }") private val catalog: String)</code></pre>
</div>
</div>
<div class="paragraph">
<p>SpEL also enables the use of more complex data structures:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Component
public class MovieRecommender {

    private final Map&lt;String, Integer&gt; countOfMoviesPerCatalog;

    public MovieRecommender(
            @Value("#{{'Thriller': 100, 'Comedy': 300}}") Map&lt;String, Integer&gt; countOfMoviesPerCatalog) {
        this.countOfMoviesPerCatalog = countOfMoviesPerCatalog;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Component
class MovieRecommender(
    @Value("#{{'Thriller': 100, 'Comedy': 300}}") private val countOfMoviesPerCatalog: Map&lt;String, Int&gt;)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-postconstruct-and-predestroy-annotations"><a class="anchor" href="#beans-postconstruct-and-predestroy-annotations"></a>1.9.9. Using <code>@PostConstruct</code> and <code>@PreDestroy</code></h4>
<div class="paragraph">
<p>The <code>CommonAnnotationBeanPostProcessor</code> not only recognizes the <code>@Resource</code> annotation
but also the JSR-250 lifecycle annotations: <code>javax.annotation.PostConstruct</code> and
<code>javax.annotation.PreDestroy</code>. Introduced in Spring 2.5, the support for these
annotations offers an alternative to the lifecycle callback mechanism described in
<a href="#beans-factory-lifecycle-initializingbean">initialization callbacks</a> and
<a href="#beans-factory-lifecycle-disposablebean">destruction callbacks</a>. Provided that the
<code>CommonAnnotationBeanPostProcessor</code> is registered within the Spring <code>ApplicationContext</code>,
a method carrying one of these annotations is invoked at the same point in the lifecycle
as the corresponding Spring lifecycle interface method or explicitly declared callback
method. In the following example, the cache is pre-populated upon initialization and
cleared upon destruction:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class CachingMovieLister {

    @PostConstruct
    public void populateMovieCache() {
        // populates the movie cache upon initialization...
    }

    @PreDestroy
    public void clearMovieCache() {
        // clears the movie cache upon destruction...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class CachingMovieLister {

    @PostConstruct
    fun populateMovieCache() {
        // populates the movie cache upon initialization...
    }

    @PreDestroy
    fun clearMovieCache() {
        // clears the movie cache upon destruction...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For details about the effects of combining various lifecycle mechanisms, see
<a href="#beans-factory-lifecycle-combined-effects">Combining Lifecycle Mechanisms</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Like <code>@Resource</code>, the <code>@PostConstruct</code> and <code>@PreDestroy</code> annotation types were a part
of the standard Java libraries from JDK 6 to 8. However, the entire <code>javax.annotation</code>
package got separated from the core Java modules in JDK 9 and eventually removed in
JDK 11. If needed, the <code>javax.annotation-api</code> artifact needs to be obtained via Maven
Central now, simply to be added to the application&#8217;s classpath like any other library.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-classpath-scanning"><a class="anchor" href="#beans-classpath-scanning"></a>1.10. Classpath Scanning and Managed Components</h3>
<div class="paragraph">
<p>Most examples in this chapter use XML to specify the configuration metadata that produces
each <code>BeanDefinition</code> within the Spring container. The previous section
(<a href="#beans-annotation-config">Annotation-based Container Configuration</a>) demonstrates how to provide a lot of the configuration
metadata through source-level annotations. Even in those examples, however, the &#8220;base&#8221;
bean definitions are explicitly defined in the XML file, while the annotations drive only
the dependency injection. This section describes an option for implicitly detecting the
candidate components by scanning the classpath. Candidate components are classes that
match against a filter criteria and have a corresponding bean definition registered with
the container. This removes the need to use XML to perform bean registration. Instead, you
can use annotations (for example, <code>@Component</code>), AspectJ type expressions, or your own
custom filter criteria to select which classes have bean definitions registered with
the container.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Starting with Spring 3.0, many features provided by the Spring JavaConfig project are
part of the core Spring Framework. This allows you to define beans using Java rather
than using the traditional XML files. Take a look at the <code>@Configuration</code>, <code>@Bean</code>,
<code>@Import</code>, and <code>@DependsOn</code> annotations for examples of how to use these new features.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-stereotype-annotations"><a class="anchor" href="#beans-stereotype-annotations"></a>1.10.1. <code>@Component</code> and Further Stereotype Annotations</h4>
<div class="paragraph">
<p>The <code>@Repository</code> annotation is a marker for any class that fulfills the role or
stereotype of a repository (also known as Data Access Object or DAO). Among the uses
of this marker is the automatic translation of exceptions, as described in
<a href="data-access.html#orm-exception-translation">Exception Translation</a>.</p>
</div>
<div class="paragraph">
<p>Spring provides further stereotype annotations: <code>@Component</code>, <code>@Service</code>, and
<code>@Controller</code>. <code>@Component</code> is a generic stereotype for any Spring-managed component.
<code>@Repository</code>, <code>@Service</code>, and <code>@Controller</code> are specializations of <code>@Component</code> for
more specific use cases (in the persistence, service, and presentation
layers, respectively). Therefore, you can annotate your component classes with
<code>@Component</code>, but, by annotating them with <code>@Repository</code>, <code>@Service</code>, or <code>@Controller</code>
instead, your classes are more properly suited for processing by tools or associating
with aspects. For example, these stereotype annotations make ideal targets for
pointcuts. <code>@Repository</code>, <code>@Service</code>, and <code>@Controller</code> can also
carry additional semantics in future releases of the Spring Framework. Thus, if you are
choosing between using <code>@Component</code> or <code>@Service</code> for your service layer, <code>@Service</code> is
clearly the better choice. Similarly, as stated earlier, <code>@Repository</code> is already
supported as a marker for automatic exception translation in your persistence layer.</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-meta-annotations"><a class="anchor" href="#beans-meta-annotations"></a>1.10.2. Using Meta-annotations and Composed Annotations</h4>
<div class="paragraph">
<p>Many of the annotations provided by Spring can be used as meta-annotations in your
own code. A meta-annotation is an annotation that can be applied to another annotation.
For example, the <code>@Service</code> annotation mentioned <a href="#beans-stereotype-annotations">earlier</a>
is meta-annotated with <code>@Component</code>, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component <i class="conum" data-value="1"></i><b>(1)</b>
public @interface Service {

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>Component</code> causes <code>@Service</code> to be treated in the same way as <code>@Component</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Target(AnnotationTarget.TYPE)
@Retention(AnnotationRetention.RUNTIME)
@MustBeDocumented
@Component <i class="conum" data-value="1"></i><b>(1)</b>
annotation class Service {

    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>Component</code> causes <code>@Service</code> to be treated in the same way as <code>@Component</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also combine meta-annotations to create &#8220;composed annotations&#8221;. For example,
the <code>@RestController</code> annotation from Spring MVC is composed of <code>@Controller</code> and
<code>@ResponseBody</code>.</p>
</div>
<div class="paragraph">
<p>In addition, composed annotations can optionally redeclare attributes from
meta-annotations to allow customization. This can be particularly useful when you
want to only expose a subset of the meta-annotation&#8217;s attributes. For example, Spring&#8217;s
<code>@SessionScope</code> annotation hardcodes the scope name to <code>session</code> but still allows
customization of the <code>proxyMode</code>. The following listing shows the definition of the
<code>SessionScope</code> annotation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Scope(WebApplicationContext.SCOPE_SESSION)
public @interface SessionScope {

    /**
     * Alias for {@link Scope#proxyMode}.
     * &lt;p&gt;Defaults to {@link ScopedProxyMode#TARGET_CLASS}.
     */
    @AliasFor(annotation = Scope.class)
    ScopedProxyMode proxyMode() default ScopedProxyMode.TARGET_CLASS;

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Target(AnnotationTarget.TYPE, AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
@MustBeDocumented
@Scope(WebApplicationContext.SCOPE_SESSION)
annotation class SessionScope(
        @get:AliasFor(annotation = Scope::class)
        val proxyMode: ScopedProxyMode = ScopedProxyMode.TARGET_CLASS
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can then use <code>@SessionScope</code> without declaring the <code>proxyMode</code> as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Service
@SessionScope
public class SessionScopedService {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Service
@SessionScope
class SessionScopedService {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also override the value for the <code>proxyMode</code>, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Service
@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)
public class SessionScopedUserService implements UserService {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Service
@SessionScope(proxyMode = ScopedProxyMode.INTERFACES)
class SessionScopedUserService : UserService {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For further details, see the
<a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model">Spring Annotation Programming Model</a>
wiki page.</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-autodetection"><a class="anchor" href="#beans-scanning-autodetection"></a>1.10.3. Automatically Detecting Classes and Registering Bean Definitions</h4>
<div class="paragraph">
<p>Spring can automatically detect stereotyped classes and register corresponding
<code>BeanDefinition</code> instances with the <code>ApplicationContext</code>. For example, the following two classes
are eligible for such autodetection:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Service
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Service
class SimpleMovieLister(private val movieFinder: MovieFinder)</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Repository
public class JpaMovieFinder implements MovieFinder {
    // implementation elided for clarity
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Repository
class JpaMovieFinder : MovieFinder {
    // implementation elided for clarity
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To autodetect these classes and register the corresponding beans, you need to add
<code>@ComponentScan</code> to your <code>@Configuration</code> class, where the <code>basePackages</code> attribute
is a common parent package for the two classes. (Alternatively, you can specify a
comma- or semicolon- or space-separated list that includes the parent package of each class.)</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@ComponentScan(basePackages = "org.example")
public class AppConfig  {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@ComponentScan(basePackages = ["org.example"])
class AppConfig  {
    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For brevity, the preceding example could have used the <code>value</code> attribute of the
annotation (that is, <code>@ComponentScan("org.example")</code>).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following alternative uses XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;context:component-scan base-package="org.example"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The use of <code>&lt;context:component-scan&gt;</code> implicitly enables the functionality of
<code>&lt;context:annotation-config&gt;</code>. There is usually no need to include the
<code>&lt;context:annotation-config&gt;</code> element when using <code>&lt;context:component-scan&gt;</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The scanning of classpath packages requires the presence of corresponding directory
entries in the classpath. When you build JARs with Ant, make sure that you do not
activate the files-only switch of the JAR task. Also, classpath directories may not be
exposed based on security policies in some environments&#8201;&#8212;&#8201;for example, standalone apps on
JDK 1.7.0_45 and higher (which requires 'Trusted-Library' setup in your manifests&#8201;&#8212;&#8201;see
<a href="https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources" class="bare">https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources</a>).</p>
</div>
<div class="paragraph">
<p>On JDK 9&#8217;s module path (Jigsaw), Spring&#8217;s classpath scanning generally works as expected.
However, make sure that your component classes are exported in your <code>module-info</code>
descriptors. If you expect Spring to invoke non-public members of your classes, make
sure that they are 'opened' (that is, that they use an <code>opens</code> declaration instead of an
<code>exports</code> declaration in your <code>module-info</code> descriptor).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Furthermore, the <code>AutowiredAnnotationBeanPostProcessor</code> and
<code>CommonAnnotationBeanPostProcessor</code> are both implicitly included when you use the
component-scan element. That means that the two components are autodetected and
wired together&#8201;&#8212;&#8201;all without any bean configuration metadata provided in XML.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can disable the registration of <code>AutowiredAnnotationBeanPostProcessor</code> and
<code>CommonAnnotationBeanPostProcessor</code> by including the <code>annotation-config</code> attribute
with a value of <code>false</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-filters"><a class="anchor" href="#beans-scanning-filters"></a>1.10.4. Using Filters to Customize Scanning</h4>
<div class="paragraph">
<p>By default, classes annotated with <code>@Component</code>, <code>@Repository</code>, <code>@Service</code>, <code>@Controller</code>,
<code>@Configuration</code>, or a custom annotation that itself is annotated with <code>@Component</code> are
the only detected candidate components. However, you can modify and extend this behavior
by applying custom filters. Add them as <code>includeFilters</code> or <code>excludeFilters</code> attributes of
the <code>@ComponentScan</code> annotation (or as <code>&lt;context:include-filter /&gt;</code> or
<code>&lt;context:exclude-filter /&gt;</code> child elements of the <code>&lt;context:component-scan&gt;</code> element in
XML configuration). Each filter element requires the <code>type</code> and <code>expression</code> attributes.
The following table describes the filtering options:</p>
</div>
<table id="beans-scanning-filters-tbl" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 5. Filter Types</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Filter Type</th>
<th class="tableblock halign-left valign-top">Example Expression</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">annotation (default)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example.SomeAnnotation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An annotation to be <em>present</em> or <em>meta-present</em> at the type level in target components.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">assignable</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example.SomeClass</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A class (or interface) that the target components are assignable to (extend or implement).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">aspectj</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example..*Service+</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An AspectJ type expression to be matched by the target components.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">regex</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org\.example\.Default.*</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A regex expression to be matched by the target components' class names.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">custom</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.example.MyTypeFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A custom implementation of the <code>org.springframework.core.type.TypeFilter</code> interface.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The following example shows the configuration ignoring all <code>@Repository</code> annotations
and using &#8220;stub&#8221; repositories instead:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@ComponentScan(basePackages = "org.example",
        includeFilters = @Filter(type = FilterType.REGEX, pattern = ".*Stub.*Repository"),
        excludeFilters = @Filter(Repository.class))
public class AppConfig {
    ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@ComponentScan(basePackages = "org.example",
        includeFilters = [Filter(type = FilterType.REGEX, pattern = [".*Stub.*Repository"])],
        excludeFilters = [Filter(Repository::class)])
class AppConfig {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following listing shows the equivalent XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;context:component-scan base-package="org.example"&gt;
        &lt;context:include-filter type="regex"
                expression=".*Stub.*Repository"/&gt;
        &lt;context:exclude-filter type="annotation"
                expression="org.springframework.stereotype.Repository"/&gt;
    &lt;/context:component-scan&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can also disable the default filters by setting <code>useDefaultFilters=false</code> on the
annotation or by providing <code>use-default-filters="false"</code> as an attribute of the
<code>&lt;component-scan/&gt;</code> element. This effectively disables automatic detection of classes
annotated or meta-annotated with <code>@Component</code>, <code>@Repository</code>, <code>@Service</code>, <code>@Controller</code>,
<code>@RestController</code>, or <code>@Configuration</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-factorybeans-annotations"><a class="anchor" href="#beans-factorybeans-annotations"></a>1.10.5. Defining Bean Metadata within Components</h4>
<div class="paragraph">
<p>Spring components can also contribute bean definition metadata to the container. You can do
this with the same <code>@Bean</code> annotation used to define bean metadata within <code>@Configuration</code>
annotated classes. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Component
public class FactoryMethodComponent {

    @Bean
    @Qualifier("public")
    public TestBean publicInstance() {
        return new TestBean("publicInstance");
    }

    public void doWork() {
        // Component method implementation omitted
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Component
class FactoryMethodComponent {

    @Bean
    @Qualifier("public")
    fun publicInstance() = TestBean("publicInstance")

    fun doWork() {
        // Component method implementation omitted
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding class is a Spring component that has application-specific code in its
<code>doWork()</code> method. However, it also contributes a bean definition that has a factory
method referring to the method <code>publicInstance()</code>. The <code>@Bean</code> annotation identifies the
factory method and other bean definition properties, such as a qualifier value through
the <code>@Qualifier</code> annotation. Other method-level annotations that can be specified are
<code>@Scope</code>, <code>@Lazy</code>, and custom qualifier annotations.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
In addition to its role for component initialization, you can also place the <code>@Lazy</code> annotation
on injection points marked with <code>@Autowired</code> or <code>@Inject</code>. In this context, it
leads to the injection of a lazy-resolution proxy.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Autowired fields and methods are supported, as previously discussed, with additional
support for autowiring of <code>@Bean</code> methods. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Component
public class FactoryMethodComponent {

    private static int i;

    @Bean
    @Qualifier("public")
    public TestBean publicInstance() {
        return new TestBean("publicInstance");
    }

    // use of a custom qualifier and autowiring of method parameters
    @Bean
    protected TestBean protectedInstance(
            @Qualifier("public") TestBean spouse,
            @Value("#{privateInstance.age}") String country) {
        TestBean tb = new TestBean("protectedInstance", 1);
        tb.setSpouse(spouse);
        tb.setCountry(country);
        return tb;
    }

    @Bean
    private TestBean privateInstance() {
        return new TestBean("privateInstance", i++);
    }

    @Bean
    @RequestScope
    public TestBean requestScopedInstance() {
        return new TestBean("requestScopedInstance", 3);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Component
class FactoryMethodComponent {

    companion object {
        private var i: Int = 0
    }

    @Bean
    @Qualifier("public")
    fun publicInstance() = TestBean("publicInstance")

    // use of a custom qualifier and autowiring of method parameters
    @Bean
    protected fun protectedInstance(
            @Qualifier("public") spouse: TestBean,
            @Value("#{privateInstance.age}") country: String) = TestBean("protectedInstance", 1).apply {
        this.spouse = spouse
        this.country = country
    }

    @Bean
    private fun privateInstance() = TestBean("privateInstance", i++)

    @Bean
    @RequestScope
    fun requestScopedInstance() = TestBean("requestScopedInstance", 3)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example autowires the <code>String</code> method parameter <code>country</code> to the value of the <code>age</code>
property on another bean named <code>privateInstance</code>. A Spring Expression Language element
defines the value of the property through the notation <code>#{ &lt;expression&gt; }</code>. For <code>@Value</code>
annotations, an expression resolver is preconfigured to look for bean names when
resolving expression text.</p>
</div>
<div class="paragraph">
<p>As of Spring Framework 4.3, you may also declare a factory method parameter of type
<code>InjectionPoint</code> (or its more specific subclass: <code>DependencyDescriptor</code>) to
access the requesting injection point that triggers the creation of the current bean.
Note that this applies only to the actual creation of bean instances, not to the
injection of existing instances. As a consequence, this feature makes most sense for
beans of prototype scope. For other scopes, the factory method only ever sees the
injection point that triggered the creation of a new bean instance in the given scope
(for example, the dependency that triggered the creation of a lazy singleton bean).
You can use the provided injection point metadata with semantic care in such scenarios.
The following example shows how to use <code>InjectionPoint</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Component
public class FactoryMethodComponent {

    @Bean @Scope("prototype")
    public TestBean prototypeInstance(InjectionPoint injectionPoint) {
        return new TestBean("prototypeInstance for " + injectionPoint.getMember());
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Component
class FactoryMethodComponent {

    @Bean
    @Scope("prototype")
    fun prototypeInstance(injectionPoint: InjectionPoint) =
            TestBean("prototypeInstance for ${injectionPoint.member}")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@Bean</code> methods in a regular Spring component are processed differently than their
counterparts inside a Spring <code>@Configuration</code> class. The difference is that <code>@Component</code>
classes are not enhanced with CGLIB to intercept the invocation of methods and fields.
CGLIB proxying is the means by which invoking methods or fields within <code>@Bean</code> methods
in <code>@Configuration</code> classes creates bean metadata references to collaborating objects.
Such methods are not invoked with normal Java semantics but rather go through the
container in order to provide the usual lifecycle management and proxying of Spring
beans, even when referring to other beans through programmatic calls to <code>@Bean</code> methods.
In contrast, invoking a method or field in a <code>@Bean</code> method within a plain <code>@Component</code>
class has standard Java semantics, with no special CGLIB processing or other
constraints applying.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You may declare <code>@Bean</code> methods as <code>static</code>, allowing for them to be called without
creating their containing configuration class as an instance. This makes particular
sense when defining post-processor beans (for example, of type <code>BeanFactoryPostProcessor</code>
or <code>BeanPostProcessor</code>), since such beans get initialized early in the container
lifecycle and should avoid triggering other parts of the configuration at that point.</p>
</div>
<div class="paragraph">
<p>Calls to static <code>@Bean</code> methods never get intercepted by the container, not even within
<code>@Configuration</code> classes (as described earlier in this section), due to technical
limitations: CGLIB subclassing can override only non-static methods. As a consequence,
a direct call to another <code>@Bean</code> method has standard Java semantics, resulting
in an independent instance being returned straight from the factory method itself.</p>
</div>
<div class="paragraph">
<p>The Java language visibility of <code>@Bean</code> methods does not have an immediate impact on
the resulting bean definition in Spring&#8217;s container. You can freely declare your
factory methods as you see fit in non-<code>@Configuration</code> classes and also for static
methods anywhere. However, regular <code>@Bean</code> methods in <code>@Configuration</code> classes need
to be overridable&#8201;&#8212;&#8201;that is, they must not be declared as <code>private</code> or <code>final</code>.</p>
</div>
<div class="paragraph">
<p><code>@Bean</code> methods are also discovered on base classes of a given component or
configuration class, as well as on Java 8 default methods declared in interfaces
implemented by the component or configuration class. This allows for a lot of
flexibility in composing complex configuration arrangements, with even multiple
inheritance being possible through Java 8 default methods as of Spring 4.2.</p>
</div>
<div class="paragraph">
<p>Finally, a single class may hold multiple <code>@Bean</code> methods for the same
bean, as an arrangement of multiple factory methods to use depending on available
dependencies at runtime. This is the same algorithm as for choosing the &#8220;greediest&#8221;
constructor or factory method in other configuration scenarios: The variant with
the largest number of satisfiable dependencies is picked at construction time,
analogous to how the container selects between multiple <code>@Autowired</code> constructors.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-name-generator"><a class="anchor" href="#beans-scanning-name-generator"></a>1.10.6. Naming Autodetected Components</h4>
<div class="paragraph">
<p>When a component is autodetected as part of the scanning process, its bean name is
generated by the <code>BeanNameGenerator</code> strategy known to that scanner. By default, any
Spring stereotype annotation (<code>@Component</code>, <code>@Repository</code>, <code>@Service</code>, and
<code>@Controller</code>) that contains a name <code>value</code> thereby provides that name to the
corresponding bean definition.</p>
</div>
<div class="paragraph">
<p>If such an annotation contains no name <code>value</code> or for any other detected component
(such as those discovered by custom filters), the default bean name generator returns
the uncapitalized non-qualified class name. For example, if the following component
classes were detected, the names would be <code>myMovieLister</code> and <code>movieFinderImpl</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Service("myMovieLister")
public class SimpleMovieLister {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Service("myMovieLister")
class SimpleMovieLister {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Repository
public class MovieFinderImpl implements MovieFinder {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Repository
class MovieFinderImpl : MovieFinder {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you do not want to rely on the default bean-naming strategy, you can provide a custom
bean-naming strategy. First, implement the
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/beans/factory/support/BeanNameGenerator.html"><code>BeanNameGenerator</code></a>
interface, and be sure to include a default no-arg constructor. Then, provide the fully
qualified class name when configuring the scanner, as the following example annotation
and bean definition show.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you run into naming conflicts due to multiple autodetected components having the
same non-qualified class name (i.e., classes with identical names but residing in
different packages), you may need to configure a <code>BeanNameGenerator</code> that defaults to the
fully qualified class name for the generated bean name. As of Spring Framework 5.2.3, the
<code>FullyQualifiedAnnotationBeanNameGenerator</code> located in package
<code>org.springframework.context.annotation</code> can be used for such purposes.
</td>
</tr>
</table>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@ComponentScan(basePackages = "org.example", nameGenerator = MyNameGenerator.class)
public class AppConfig {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@ComponentScan(basePackages = ["org.example"], nameGenerator = MyNameGenerator::class)
class AppConfig {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;context:component-scan base-package="org.example"
        name-generator="org.example.MyNameGenerator" /&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>As a general rule, consider specifying the name with the annotation whenever other
components may be making explicit references to it. On the other hand, the
auto-generated names are adequate whenever the container is responsible for wiring.</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-scope-resolver"><a class="anchor" href="#beans-scanning-scope-resolver"></a>1.10.7. Providing a Scope for Autodetected Components</h4>
<div class="paragraph">
<p>As with Spring-managed components in general, the default and most common scope for
autodetected components is <code>singleton</code>. However, sometimes you need a different scope
that can be specified by the <code>@Scope</code> annotation. You can provide the name of the
scope within the annotation, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Scope("prototype")
@Repository
public class MovieFinderImpl implements MovieFinder {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Scope("prototype")
@Repository
class MovieFinderImpl : MovieFinder {
    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>@Scope</code> annotations are only introspected on the concrete bean class (for annotated
components) or the factory method (for <code>@Bean</code> methods). In contrast to XML bean
definitions, there is no notion of bean definition inheritance, and inheritance
hierarchies at the class level are irrelevant for metadata purposes.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For details on web-specific scopes such as &#8220;request&#8221; or &#8220;session&#8221; in a Spring context,
see <a href="#beans-factory-scopes-other">Request, Session, Application, and WebSocket Scopes</a>. As with the pre-built annotations for those scopes,
you may also compose your own scoping annotations by using Spring&#8217;s meta-annotation
approach: for example, a custom annotation meta-annotated with <code>@Scope("prototype")</code>,
possibly also declaring a custom scoped-proxy mode.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To provide a custom strategy for scope resolution rather than relying on the
annotation-based approach, you can implement the
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/context/annotation/ScopeMetadataResolver.html"><code>ScopeMetadataResolver</code></a>
interface. Be sure to include a default no-arg constructor. Then you can provide the
fully qualified class name when configuring the scanner, as the following example of both
an annotation and a bean definition shows:
</td>
</tr>
</table>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@ComponentScan(basePackages = "org.example", scopeResolver = MyScopeResolver.class)
public class AppConfig {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@ComponentScan(basePackages = ["org.example"], scopeResolver = MyScopeResolver::class)
class AppConfig {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;context:component-scan base-package="org.example" scope-resolver="org.example.MyScopeResolver"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>When using certain non-singleton scopes, it may be necessary to generate proxies for the
scoped objects. The reasoning is described in <a href="#beans-factory-scopes-other-injection">Scoped Beans as Dependencies</a>.
For this purpose, a scoped-proxy attribute is available on the component-scan
element. The three possible values are: <code>no</code>, <code>interfaces</code>, and <code>targetClass</code>. For example,
the following configuration results in standard JDK dynamic proxies:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@ComponentScan(basePackages = "org.example", scopedProxy = ScopedProxyMode.INTERFACES)
public class AppConfig {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@ComponentScan(basePackages = ["org.example"], scopedProxy = ScopedProxyMode.INTERFACES)
class AppConfig {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;context:component-scan base-package="org.example" scoped-proxy="interfaces"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-qualifiers"><a class="anchor" href="#beans-scanning-qualifiers"></a>1.10.8. Providing Qualifier Metadata with Annotations</h4>
<div class="paragraph">
<p>The <code>@Qualifier</code> annotation is discussed in <a href="#beans-autowired-annotation-qualifiers">Fine-tuning Annotation-based Autowiring with Qualifiers</a>.
The examples in that section demonstrate the use of the <code>@Qualifier</code> annotation and
custom qualifier annotations to provide fine-grained control when you resolve autowire
candidates. Because those examples were based on XML bean definitions, the qualifier
metadata was provided on the candidate bean definitions by using the <code>qualifier</code> or <code>meta</code>
child elements of the <code>bean</code> element in the XML. When relying upon classpath scanning for
auto-detection of components, you can provide the qualifier metadata with type-level
annotations on the candidate class. The following three examples demonstrate this
technique:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Component
@Qualifier("Action")
public class ActionMovieCatalog implements MovieCatalog {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Component
@Qualifier("Action")
class ActionMovieCatalog : MovieCatalog</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Component
@Genre("Action")
public class ActionMovieCatalog implements MovieCatalog {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Component
@Genre("Action")
class ActionMovieCatalog : MovieCatalog {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Component
@Offline
public class CachingMovieCatalog implements MovieCatalog {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Component
@Offline
class CachingMovieCatalog : MovieCatalog {
    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As with most annotation-based alternatives, keep in mind that the annotation metadata is
bound to the class definition itself, while the use of XML allows for multiple beans
of the same type to provide variations in their qualifier metadata, because that
metadata is provided per-instance rather than per-class.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-scanning-index"><a class="anchor" href="#beans-scanning-index"></a>1.10.9. Generating an Index of Candidate Components</h4>
<div class="paragraph">
<p>While classpath scanning is very fast, it is possible to improve the startup performance
of large applications by creating a static list of candidates at compilation time. In this
mode, all modules that are targets of component scanning must use this mechanism.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Your existing <code>@ComponentScan</code> or <code>&lt;context:component-scan/&gt;</code> directives must remain
unchanged to request the context to scan candidates in certain packages. When the
<code>ApplicationContext</code> detects such an index, it automatically uses it rather than scanning
the classpath.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To generate the index, add an additional dependency to each module that contains
components that are targets for component scan directives. The following example shows
how to do so with Maven:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context-indexer&lt;/artifactId&gt;
        &lt;version&gt;5.3.7&lt;/version&gt;
        &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>With Gradle 4.5 and earlier, the dependency should be declared in the <code>compileOnly</code>
configuration, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">dependencies {
    compileOnly "org.springframework:spring-context-indexer:5.3.7"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With Gradle 4.6 and later, the dependency should be declared in the <code>annotationProcessor</code>
configuration, as shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">dependencies {
    annotationProcessor "org.springframework:spring-context-indexer:{spring-version}"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>spring-context-indexer</code> artifact generates a <code>META-INF/spring.components</code> file that
is included in the jar file.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When working with this mode in your IDE, the <code>spring-context-indexer</code> must be
registered as an annotation processor to make sure the index is up-to-date when
candidate components are updated.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
The index is enabled automatically when a <code>META-INF/spring.components</code> file is found
on the classpath. If an index is partially available for some libraries (or use cases)
but could not be built for the whole application, you can fall back to a regular classpath
arrangement (as though no index were present at all) by setting <code>spring.index.ignore</code> to
<code>true</code>, either as a JVM system property or via the
<a href="appendix.html#appendix-spring-properties"><code>SpringProperties</code></a> mechanism.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-standard-annotations"><a class="anchor" href="#beans-standard-annotations"></a>1.11. Using JSR 330 Standard Annotations</h3>
<div class="paragraph">
<p>Starting with Spring 3.0, Spring offers support for JSR-330 standard annotations
(Dependency Injection). Those annotations are scanned in the same way as the Spring
annotations. To use them, you need to have the relevant jars in your classpath.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you use Maven, the <code>javax.inject</code> artifact is available in the standard Maven
repository (
<a href="https://repo1.maven.org/maven2/javax/inject/javax.inject/1/">https://repo1.maven.org/maven2/javax/inject/javax.inject/1/</a>).
You can add the following dependency to your file pom.xml:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;dependency&gt;
    &lt;groupId&gt;javax.inject&lt;/groupId&gt;
    &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;
    &lt;version&gt;1&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="beans-inject-named"><a class="anchor" href="#beans-inject-named"></a>1.11.1. Dependency Injection with <code>@Inject</code> and <code>@Named</code></h4>
<div class="paragraph">
<p>Instead of <code>@Autowired</code>, you can use <code>@javax.inject.Inject</code> as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import javax.inject.Inject;

public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    public void listMovies() {
        this.movieFinder.findMovies(...);
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import javax.inject.Inject

class SimpleMovieLister {

    @Inject
    lateinit var movieFinder: MovieFinder


    fun listMovies() {
        movieFinder.findMovies(...)
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As with <code>@Autowired</code>, you can use <code>@Inject</code> at the field level, method level
and constructor-argument level. Furthermore, you may declare your injection point as a
<code>Provider</code>, allowing for on-demand access to beans of shorter scopes or lazy access to
other beans through a <code>Provider.get()</code> call. The following example offers a variant of the
preceding example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import javax.inject.Inject;
import javax.inject.Provider;

public class SimpleMovieLister {

    private Provider&lt;MovieFinder&gt; movieFinder;

    @Inject
    public void setMovieFinder(Provider&lt;MovieFinder&gt; movieFinder) {
        this.movieFinder = movieFinder;
    }

    public void listMovies() {
        this.movieFinder.get().findMovies(...);
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import javax.inject.Inject

class SimpleMovieLister {

    @Inject
    lateinit var movieFinder: MovieFinder


    fun listMovies() {
        movieFinder.findMovies(...)
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you would like to use a qualified name for the dependency that should be injected,
you should use the <code>@Named</code> annotation, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import javax.inject.Inject;
import javax.inject.Named;

public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(@Named("main") MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import javax.inject.Inject
import javax.inject.Named

class SimpleMovieLister {

    private lateinit var movieFinder: MovieFinder

    @Inject
    fun setMovieFinder(@Named("main") movieFinder: MovieFinder) {
        this.movieFinder = movieFinder
    }

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As with <code>@Autowired</code>, <code>@Inject</code> can also be used with <code>java.util.Optional</code> or
<code>@Nullable</code>. This is even more applicable here, since <code>@Inject</code> does not have
a <code>required</code> attribute. The following pair of examples show how to use <code>@Inject</code> and
<code>@Nullable</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class SimpleMovieLister {

    @Inject
    public void setMovieFinder(Optional&lt;MovieFinder&gt; movieFinder) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class SimpleMovieLister {

    @Inject
    public void setMovieFinder(@Nullable MovieFinder movieFinder) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class SimpleMovieLister {

    @Inject
    var movieFinder: MovieFinder? = null
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-named"><a class="anchor" href="#beans-named"></a>1.11.2. <code>@Named</code> and <code>@ManagedBean</code>: Standard Equivalents to the <code>@Component</code> Annotation</h4>
<div class="paragraph">
<p>Instead of <code>@Component</code>, you can use <code>@javax.inject.Named</code> or <code>javax.annotation.ManagedBean</code>,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import javax.inject.Inject;
import javax.inject.Named;

@Named("movieListener")  // @ManagedBean("movieListener") could be used as well
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import javax.inject.Inject
import javax.inject.Named

@Named("movieListener")  // @ManagedBean("movieListener") could be used as well
class SimpleMovieLister {

    @Inject
    lateinit var movieFinder: MovieFinder

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is very common to use <code>@Component</code> without specifying a name for the component.
<code>@Named</code> can be used in a similar fashion, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import javax.inject.Inject;
import javax.inject.Named;

@Named
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Inject
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import javax.inject.Inject
import javax.inject.Named

@Named
class SimpleMovieLister {

    @Inject
    lateinit var movieFinder: MovieFinder

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you use <code>@Named</code> or <code>@ManagedBean</code>, you can use component scanning in the
exact same way as when you use Spring annotations, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@ComponentScan(basePackages = "org.example")
public class AppConfig  {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@ComponentScan(basePackages = ["org.example"])
class AppConfig  {
    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In contrast to <code>@Component</code>, the JSR-330 <code>@Named</code> and the JSR-250 <code>ManagedBean</code>
annotations are not composable. You should use Spring&#8217;s stereotype model for building
custom component annotations.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-standard-annotations-limitations"><a class="anchor" href="#beans-standard-annotations-limitations"></a>1.11.3. Limitations of JSR-330 Standard Annotations</h4>
<div class="paragraph">
<p>When you work with standard annotations, you should know that some significant
features are not available, as the following table shows:</p>
</div>
<table id="annotations-comparison" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 6. Spring component model elements versus JSR-330 variants</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Spring</th>
<th class="tableblock halign-left valign-top">javax.inject.*</th>
<th class="tableblock halign-left valign-top">javax.inject restrictions / comments</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Autowired</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Inject</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Inject</code> has no 'required' attribute. Can be used with Java 8&#8217;s <code>Optional</code> instead.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Component</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Named / @ManagedBean</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSR-330 does not provide a composable model, only a way to identify named components.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Scope("singleton")</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Singleton</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The JSR-330 default scope is like Spring&#8217;s <code>prototype</code>. However, in order to keep it
consistent with Spring&#8217;s general defaults, a JSR-330 bean declared in the Spring
container is a <code>singleton</code> by default. In order to use a scope other than <code>singleton</code>,
you should use Spring&#8217;s <code>@Scope</code> annotation. <code>javax.inject</code> also provides a
<a href="https://download.oracle.com/javaee/6/api/javax/inject/Scope.html">@Scope</a> annotation.
Nevertheless, this one is only intended to be used for creating your own annotations.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Qualifier</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Qualifier / @Named</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.inject.Qualifier</code> is just a meta-annotation for building custom qualifiers.
Concrete <code>String</code> qualifiers (like Spring&#8217;s <code>@Qualifier</code> with a value) can be associated
through <code>javax.inject.Named</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no equivalent</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Required</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no equivalent</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">@Lazy</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no equivalent</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ObjectFactory</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Provider</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>javax.inject.Provider</code> is a direct alternative to Spring&#8217;s <code>ObjectFactory</code>,
only with a shorter <code>get()</code> method name. It can also be used in combination with
Spring&#8217;s <code>@Autowired</code> or with non-annotated constructors and setter methods.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="beans-java"><a class="anchor" href="#beans-java"></a>1.12. Java-based Container Configuration</h3>
<div class="paragraph">
<p>This section covers how to use annotations in your Java code to configure the Spring
container. It includes the following topics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#beans-java-basic-concepts">Basic Concepts: <code>@Bean</code> and <code>@Configuration</code></a></p>
</li>
<li>
<p><a href="#beans-java-instantiating-container">Instantiating the Spring Container by Using <code>AnnotationConfigApplicationContext</code></a></p>
</li>
<li>
<p><a href="#beans-java-bean-annotation">Using the <code>@Bean</code> Annotation</a></p>
</li>
<li>
<p><a href="#beans-java-configuration-annotation">Using the <code>@Configuration</code> annotation</a></p>
</li>
<li>
<p><a href="#beans-java-composing-configuration-classes">Composing Java-based Configurations</a></p>
</li>
<li>
<p><a href="#beans-definition-profiles">Bean Definition Profiles</a></p>
</li>
<li>
<p><a href="#beans-property-source-abstraction"><code>PropertySource</code> Abstraction</a></p>
</li>
<li>
<p><a href="#beans-using-propertysource">Using <code>@PropertySource</code></a></p>
</li>
<li>
<p><a href="#beans-placeholder-resolution-in-statements">Placeholder Resolution in Statements</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="beans-java-basic-concepts"><a class="anchor" href="#beans-java-basic-concepts"></a>1.12.1. Basic Concepts: <code>@Bean</code> and <code>@Configuration</code></h4>
<div class="paragraph">
<p>The central artifacts in Spring&#8217;s new Java-configuration support are
<code>@Configuration</code>-annotated classes and <code>@Bean</code>-annotated methods.</p>
</div>
<div class="paragraph">
<p>The <code>@Bean</code> annotation is used to indicate that a method instantiates, configures, and
initializes a new object to be managed by the Spring IoC container. For those familiar
with Spring&#8217;s <code>&lt;beans/&gt;</code> XML configuration, the <code>@Bean</code> annotation plays the same role as
the <code>&lt;bean/&gt;</code> element. You can use <code>@Bean</code>-annotated methods with any Spring
<code>@Component</code>. However, they are most often used with <code>@Configuration</code> beans.</p>
</div>
<div class="paragraph">
<p>Annotating a class with <code>@Configuration</code> indicates that its primary purpose is as a
source of bean definitions. Furthermore, <code>@Configuration</code> classes let inter-bean
dependencies be defined by calling other <code>@Bean</code> methods in the same class.
The simplest possible <code>@Configuration</code> class reads as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class AppConfig {

    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
class AppConfig {

    @Bean
    fun myService(): MyService {
        return MyServiceImpl()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding <code>AppConfig</code> class is equivalent to the following Spring <code>&lt;beans/&gt;</code> XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;bean id="myService" class="com.acme.services.MyServiceImpl"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Full @Configuration vs &#8220;lite&#8221; @Bean mode?</div>
<div class="paragraph">
<p>When <code>@Bean</code> methods are declared within classes that are not annotated with
<code>@Configuration</code>, they are referred to as being processed in a &#8220;lite&#8221; mode. Bean methods
declared in a <code>@Component</code> or even in a plain old class are considered to be &#8220;lite&#8221;,
with a different primary purpose of the containing class and a <code>@Bean</code> method
being a sort of bonus there. For example, service components may expose management views
to the container through an additional <code>@Bean</code> method on each applicable component class.
In such scenarios, <code>@Bean</code> methods are a general-purpose factory method mechanism.</p>
</div>
<div class="paragraph">
<p>Unlike full <code>@Configuration</code>, lite <code>@Bean</code> methods cannot declare inter-bean dependencies.
Instead, they operate on their containing component&#8217;s internal state and, optionally, on
arguments that they may declare. Such a <code>@Bean</code> method should therefore not invoke other
<code>@Bean</code> methods. Each such method is literally only a factory method for a particular
bean reference, without any special runtime semantics. The positive side-effect here is
that no CGLIB subclassing has to be applied at runtime, so there are no limitations in
terms of class design (that is, the containing class may be <code>final</code> and so forth).</p>
</div>
<div class="paragraph">
<p>In common scenarios, <code>@Bean</code> methods are to be declared within <code>@Configuration</code> classes,
ensuring that &#8220;full&#8221; mode is always used and that cross-method references therefore
get redirected to the container&#8217;s lifecycle management. This prevents the same
<code>@Bean</code> method from accidentally being invoked through a regular Java call, which helps
to reduce subtle bugs that can be hard to track down when operating in &#8220;lite&#8221; mode.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>@Bean</code> and <code>@Configuration</code> annotations are discussed in depth in the following sections.
First, however, we cover the various ways of creating a spring container using by
Java-based configuration.</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-java-instantiating-container"><a class="anchor" href="#beans-java-instantiating-container"></a>1.12.2. Instantiating the Spring Container by Using <code>AnnotationConfigApplicationContext</code></h4>
<div class="paragraph">
<p>The following sections document Spring&#8217;s <code>AnnotationConfigApplicationContext</code>, introduced in Spring
3.0. This versatile <code>ApplicationContext</code> implementation is capable of accepting not only
<code>@Configuration</code> classes as input but also plain <code>@Component</code> classes and classes
annotated with JSR-330 metadata.</p>
</div>
<div class="paragraph">
<p>When <code>@Configuration</code> classes are provided as input, the <code>@Configuration</code> class itself
is registered as a bean definition and all declared <code>@Bean</code> methods within the class
are also registered as bean definitions.</p>
</div>
<div class="paragraph">
<p>When <code>@Component</code> and JSR-330 classes are provided, they are registered as bean
definitions, and it is assumed that DI metadata such as <code>@Autowired</code> or <code>@Inject</code> are
used within those classes where necessary.</p>
</div>
<div class="sect4">
<h5 id="beans-java-instantiating-container-constructor"><a class="anchor" href="#beans-java-instantiating-container-constructor"></a>Simple Construction</h5>
<div class="paragraph">
<p>In much the same way that Spring XML files are used as input when instantiating a
<code>ClassPathXmlApplicationContext</code>, you can use <code>@Configuration</code> classes as input when
instantiating an <code>AnnotationConfigApplicationContext</code>. This allows for completely
XML-free usage of the Spring container, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.beans.factory.getBean

fun main() {
    val ctx = AnnotationConfigApplicationContext(AppConfig::class.java)
    val myService = ctx.getBean&lt;MyService&gt;()
    myService.doStuff()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As mentioned earlier, <code>AnnotationConfigApplicationContext</code> is not limited to working only
with <code>@Configuration</code> classes. Any <code>@Component</code> or JSR-330 annotated class may be supplied
as input to the constructor, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.beans.factory.getBean

fun main() {
    val ctx = AnnotationConfigApplicationContext(MyServiceImpl::class.java, Dependency1::class.java, Dependency2::class.java)
    val myService = ctx.getBean&lt;MyService&gt;()
    myService.doStuff()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding example assumes that <code>MyServiceImpl</code>, <code>Dependency1</code>, and <code>Dependency2</code> use Spring
dependency injection annotations such as <code>@Autowired</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-instantiating-container-register"><a class="anchor" href="#beans-java-instantiating-container-register"></a>Building the Container Programmatically by Using <code>register(Class&lt;?&gt;&#8230;&#8203;)</code></h5>
<div class="paragraph">
<p>You can instantiate an <code>AnnotationConfigApplicationContext</code> by using a no-arg constructor
and then configure it by using the <code>register()</code> method. This approach is particularly useful
when programmatically building an <code>AnnotationConfigApplicationContext</code>. The following
example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.register(AppConfig.class, OtherConfig.class);
    ctx.register(AdditionalConfig.class);
    ctx.refresh();
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.beans.factory.getBean

fun main() {
    val ctx = AnnotationConfigApplicationContext()
    ctx.register(AppConfig::class.java, OtherConfig::class.java)
    ctx.register(AdditionalConfig::class.java)
    ctx.refresh()
    val myService = ctx.getBean&lt;MyService&gt;()
    myService.doStuff()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-instantiating-container-scan"><a class="anchor" href="#beans-java-instantiating-container-scan"></a>Enabling Component Scanning with <code>scan(String&#8230;&#8203;)</code></h5>
<div class="paragraph">
<p>To enable component scanning, you can annotate your <code>@Configuration</code> class as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@ComponentScan(basePackages = "com.acme") <i class="conum" data-value="1"></i><b>(1)</b>
public class AppConfig  {
    ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This annotation enables component scanning.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@ComponentScan(basePackages = ["com.acme"]) <i class="conum" data-value="1"></i><b>(1)</b>
class AppConfig  {
    // ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This annotation enables component scanning.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Experienced Spring users may be familiar with the XML declaration equivalent from
Spring&#8217;s <code>context:</code> namespace, shown in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;context:component-scan base-package="com.acme"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the preceding example, the <code>com.acme</code> package is scanned to look for any
<code>@Component</code>-annotated classes, and those classes are registered as Spring bean
definitions within the container. <code>AnnotationConfigApplicationContext</code> exposes the
<code>scan(String&#8230;&#8203;)</code> method to allow for the same component-scanning functionality, as the
following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.scan("com.acme");
    ctx.refresh();
    MyService myService = ctx.getBean(MyService.class);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun main() {
    val ctx = AnnotationConfigApplicationContext()
    ctx.scan("com.acme")
    ctx.refresh()
    val myService = ctx.getBean&lt;MyService&gt;()
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Remember that <code>@Configuration</code> classes are <a href="#beans-meta-annotations">meta-annotated</a>
with <code>@Component</code>, so they are candidates for component-scanning. In the preceding example,
assuming that <code>AppConfig</code> is declared within the <code>com.acme</code> package (or any package
underneath), it is picked up during the call to <code>scan()</code>. Upon <code>refresh()</code>, all its <code>@Bean</code>
methods are processed and registered as bean definitions within the container.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-instantiating-container-web"><a class="anchor" href="#beans-java-instantiating-container-web"></a>Support for Web Applications with <code>AnnotationConfigWebApplicationContext</code></h5>
<div class="paragraph">
<p>A <code>WebApplicationContext</code> variant of <code>AnnotationConfigApplicationContext</code> is available
with <code>AnnotationConfigWebApplicationContext</code>. You can use this implementation when
configuring the Spring <code>ContextLoaderListener</code> servlet listener, Spring MVC
<code>DispatcherServlet</code>, and so forth. The following <code>web.xml</code> snippet configures a typical
Spring MVC web application (note the use of the <code>contextClass</code> context-param and
init-param):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;web-app&gt;
    &lt;!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext
        instead of the default XmlWebApplicationContext --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextClass&lt;/param-name&gt;
        &lt;param-value&gt;
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        &lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!-- Configuration locations must consist of one or more comma- or space-delimited
        fully-qualified @Configuration classes. Fully-qualified packages may also be
        specified for component-scanning --&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;com.acme.AppConfig&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!-- Bootstrap the root application context as usual using ContextLoaderListener --&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;

    &lt;!-- Declare a Spring MVC DispatcherServlet as usual --&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext
            instead of the default XmlWebApplicationContext --&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextClass&lt;/param-name&gt;
            &lt;param-value&gt;
                org.springframework.web.context.support.AnnotationConfigWebApplicationContext
            &lt;/param-value&gt;
        &lt;/init-param&gt;
        &lt;!-- Again, config locations must consist of one or more comma- or space-delimited
            and fully-qualified @Configuration classes --&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;com.acme.web.MvcConfig&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/servlet&gt;

    &lt;!-- map all requests for /app/* to the dispatcher servlet --&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-java-bean-annotation"><a class="anchor" href="#beans-java-bean-annotation"></a>1.12.3. Using the <code>@Bean</code> Annotation</h4>
<div class="paragraph">
<p><code>@Bean</code> is a method-level annotation and a direct analog of the XML <code>&lt;bean/&gt;</code> element.
The annotation supports some of the attributes offered by <code>&lt;bean/&gt;</code>, such as:
* <a href="#beans-factory-lifecycle-initializingbean">init-method</a>
* <a href="#beans-factory-lifecycle-disposablebean">destroy-method</a>
* <a href="#beans-factory-autowire">autowiring</a>
* <code>name</code>.</p>
</div>
<div class="paragraph">
<p>You can use the <code>@Bean</code> annotation in a <code>@Configuration</code>-annotated or in a
<code>@Component</code>-annotated class.</p>
</div>
<div class="sect4">
<h5 id="beans-java-declaring-a-bean"><a class="anchor" href="#beans-java-declaring-a-bean"></a>Declaring a Bean</h5>
<div class="paragraph">
<p>To declare a bean, you can annotate a method with the <code>@Bean</code> annotation. You use this
method to register a bean definition within an <code>ApplicationContext</code> of the type
specified as the method&#8217;s return value. By default, the bean name is the same as
the method name. The following example shows a <code>@Bean</code> method declaration:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class AppConfig {

    @Bean
    public TransferServiceImpl transferService() {
        return new TransferServiceImpl();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
class AppConfig {

    @Bean
    fun transferService() = TransferServiceImpl()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration is exactly equivalent to the following Spring XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;bean id="transferService" class="com.acme.TransferServiceImpl"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Both declarations make a bean named <code>transferService</code> available in the
<code>ApplicationContext</code>, bound to an object instance of type <code>TransferServiceImpl</code>, as the
following text image shows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>transferService -&gt; com.acme.TransferServiceImpl</pre>
</div>
</div>
<div class="paragraph">
<p>You can also declare your <code>@Bean</code> method with an interface (or base class)
return type, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class AppConfig {

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
class AppConfig {

    @Bean
    fun transferService(): TransferService {
        return TransferServiceImpl()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, this limits the visibility for advance type prediction to the specified
interface type (<code>TransferService</code>). Then, with the full type (<code>TransferServiceImpl</code>)
known to the container only once, the affected singleton bean has been instantiated.
Non-lazy singleton beans get instantiated according to their declaration order,
so you may see different type matching results depending on when another component
tries to match by a non-declared type (such as <code>@Autowired TransferServiceImpl</code>,
which resolves only once the <code>transferService</code> bean has been instantiated).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you consistently refer to your types by a declared service interface, your
<code>@Bean</code> return types may safely join that design decision. However, for components
that implement several interfaces or for components potentially referred to by their
implementation type, it is safer to declare the most specific return type possible
(at least as specific as required by the injection points that refer to your bean).
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-dependencies"><a class="anchor" href="#beans-java-dependencies"></a>Bean Dependencies</h5>
<div class="paragraph">
<p>A <code>@Bean</code>-annotated method can have an arbitrary number of parameters that describe the
dependencies required to build that bean. For instance, if our <code>TransferService</code>
requires an <code>AccountRepository</code>, we can materialize that dependency with a method
parameter, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class AppConfig {

    @Bean
    public TransferService transferService(AccountRepository accountRepository) {
        return new TransferServiceImpl(accountRepository);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
class AppConfig {

    @Bean
    fun transferService(accountRepository: AccountRepository): TransferService {
        return TransferServiceImpl(accountRepository)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The resolution mechanism is pretty much identical to constructor-based dependency
injection. See <a href="#beans-constructor-injection">the relevant section</a> for more details.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-lifecycle-callbacks"><a class="anchor" href="#beans-java-lifecycle-callbacks"></a>Receiving Lifecycle Callbacks</h5>
<div class="paragraph">
<p>Any classes defined with the <code>@Bean</code> annotation support the regular lifecycle callbacks
and can use the <code>@PostConstruct</code> and <code>@PreDestroy</code> annotations from JSR-250. See
<a href="#beans-postconstruct-and-predestroy-annotations">JSR-250 annotations</a> for further
details.</p>
</div>
<div class="paragraph">
<p>The regular Spring <a href="#beans-factory-nature">lifecycle</a> callbacks are fully supported as
well. If a bean implements <code>InitializingBean</code>, <code>DisposableBean</code>, or <code>Lifecycle</code>, their
respective methods are called by the container.</p>
</div>
<div class="paragraph">
<p>The standard set of <code>*Aware</code> interfaces (such as <a href="#beans-beanfactory">BeanFactoryAware</a>,
<a href="#beans-factory-aware">BeanNameAware</a>,
<a href="#context-functionality-messagesource">MessageSourceAware</a>,
<a href="#beans-factory-aware">ApplicationContextAware</a>, and so on) are also fully supported.</p>
</div>
<div class="paragraph">
<p>The <code>@Bean</code> annotation supports specifying arbitrary initialization and destruction
callback methods, much like Spring XML&#8217;s <code>init-method</code> and <code>destroy-method</code> attributes
on the <code>bean</code> element, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class BeanOne {

    public void init() {
        // initialization logic
    }
}

public class BeanTwo {

    public void cleanup() {
        // destruction logic
    }
}

@Configuration
public class AppConfig {

    @Bean(initMethod = "init")
    public BeanOne beanOne() {
        return new BeanOne();
    }

    @Bean(destroyMethod = "cleanup")
    public BeanTwo beanTwo() {
        return new BeanTwo();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class BeanOne {

    fun init() {
        // initialization logic
    }
}

class BeanTwo {

    fun cleanup() {
        // destruction logic
    }
}

@Configuration
class AppConfig {

    @Bean(initMethod = "init")
    fun beanOne() = BeanOne()

    @Bean(destroyMethod = "cleanup")
    fun beanTwo() = BeanTwo()
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>By default, beans defined with Java configuration that have a public <code>close</code> or <code>shutdown</code>
method are automatically enlisted with a destruction callback. If you have a public
<code>close</code> or <code>shutdown</code> method and you do not wish for it to be called when the container
shuts down, you can add <code>@Bean(destroyMethod="")</code> to your bean definition to disable the
default <code>(inferred)</code> mode.</p>
</div>
<div class="paragraph">
<p>You may want to do that by default for a resource that you acquire with JNDI, as its
lifecycle is managed outside the application. In particular, make sure to always do it
for a <code>DataSource</code>, as it is known to be problematic on Java EE application servers.</p>
</div>
<div class="paragraph">
<p>The following example shows how to prevent an automatic destruction callback for a
<code>DataSource</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean(destroyMethod="")
public DataSource dataSource() throws NamingException {
    return (DataSource) jndiTemplate.lookup("MyDS");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Bean(destroyMethod = "")
fun dataSource(): DataSource {
    return jndiTemplate.lookup("MyDS") as DataSource
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, with <code>@Bean</code> methods, you typically use programmatic JNDI lookups, either by
using Spring&#8217;s <code>JndiTemplate</code> or <code>JndiLocatorDelegate</code> helpers or straight JNDI
<code>InitialContext</code> usage but not the <code>JndiObjectFactoryBean</code> variant (which would force
you to declare the return type as the <code>FactoryBean</code> type instead of the actual target
type, making it harder to use for cross-reference calls in other <code>@Bean</code> methods that
intend to refer to the provided resource here).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the case of <code>BeanOne</code> from the example above the preceding note, it would be equally valid to call the <code>init()</code>
method directly during construction, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class AppConfig {

    @Bean
    public BeanOne beanOne() {
        BeanOne beanOne = new BeanOne();
        beanOne.init();
        return beanOne;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
class AppConfig {

    @Bean
    fun beanOne() = BeanOne().apply {
        init()
    }

    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When you work directly in Java, you can do anything you like with your objects and do
not always need to rely on the container lifecycle.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-specifying-bean-scope"><a class="anchor" href="#beans-java-specifying-bean-scope"></a>Specifying Bean Scope</h5>
<div class="paragraph">
<p>Spring includes the <code>@Scope</code> annotation so that you can specify the scope of a bean.</p>
</div>
<div class="sect5">
<h6 id="beans-java-available-scopes"><a class="anchor" href="#beans-java-available-scopes"></a>Using the <code>@Scope</code> Annotation</h6>
<div class="paragraph">
<p>You can specify that your beans defined with the <code>@Bean</code> annotation should have a
specific scope. You can use any of the standard scopes specified in the
<a href="#beans-factory-scopes">Bean Scopes</a> section.</p>
</div>
<div class="paragraph">
<p>The default scope is <code>singleton</code>, but you can override this with the <code>@Scope</code> annotation,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class MyConfiguration {

    @Bean
    @Scope("prototype")
    public Encryptor encryptor() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
class MyConfiguration {

    @Bean
    @Scope("prototype")
    fun encryptor(): Encryptor {
        // ...
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="beans-java-scoped-proxy"><a class="anchor" href="#beans-java-scoped-proxy"></a><code>@Scope</code> and <code>scoped-proxy</code></h6>
<div class="paragraph">
<p>Spring offers a convenient way of working with scoped dependencies through
<a href="#beans-factory-scopes-other-injection">scoped proxies</a>. The easiest way to create
such a proxy when using the XML configuration is the <code>&lt;aop:scoped-proxy/&gt;</code> element.
Configuring your beans in Java with a <code>@Scope</code> annotation offers equivalent support
with the <code>proxyMode</code> attribute. The default is <code>ScopedProxyMode.DEFAULT</code>, which
typically indicates that no scoped proxy should be created unless a different default
has been configured at the component-scan instruction level. You can specify
<code>ScopedProxyMode.TARGET_CLASS</code>, <code>ScopedProxyMode.INTERFACES</code> or <code>ScopedProxyMode.NO</code>.</p>
</div>
<div class="paragraph">
<p>If you port the scoped proxy example from the XML reference documentation (see
<a href="#beans-factory-scopes-other-injection">scoped proxies</a>) to our <code>@Bean</code> using Java,
it resembles the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// an HTTP Session-scoped bean exposed as a proxy
@Bean
@SessionScope
public UserPreferences userPreferences() {
    return new UserPreferences();
}

@Bean
public Service userService() {
    UserService service = new SimpleUserService();
    // a reference to the proxied userPreferences bean
    service.setUserPreferences(userPreferences());
    return service;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// an HTTP Session-scoped bean exposed as a proxy
@Bean
@SessionScope
fun userPreferences() = UserPreferences()

@Bean
fun userService(): Service {
    return SimpleUserService().apply {
        // a reference to the proxied userPreferences bean
        setUserPreferences(userPreferences()
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-customizing-bean-naming"><a class="anchor" href="#beans-java-customizing-bean-naming"></a>Customizing Bean Naming</h5>
<div class="paragraph">
<p>By default, configuration classes use a <code>@Bean</code> method&#8217;s name as the name of the
resulting bean. This functionality can be overridden, however, with the <code>name</code> attribute,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class AppConfig {

    @Bean(name = "myThing")
    public Thing thing() {
        return new Thing();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
class AppConfig {

    @Bean("myThing")
    fun thing() = Thing()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-bean-aliasing"><a class="anchor" href="#beans-java-bean-aliasing"></a>Bean Aliasing</h5>
<div class="paragraph">
<p>As discussed in <a href="#beans-beanname">Naming Beans</a>, it is sometimes desirable to give a single bean
multiple names, otherwise known as bean aliasing. The <code>name</code> attribute of the <code>@Bean</code>
annotation accepts a String array for this purpose. The following example shows how to set
a number of aliases for a bean:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class AppConfig {

    @Bean({"dataSource", "subsystemA-dataSource", "subsystemB-dataSource"})
    public DataSource dataSource() {
        // instantiate, configure and return DataSource bean...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
class AppConfig {

    @Bean("dataSource", "subsystemA-dataSource", "subsystemB-dataSource")
    fun dataSource(): DataSource {
        // instantiate, configure and return DataSource bean...
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-bean-description"><a class="anchor" href="#beans-java-bean-description"></a>Bean Description</h5>
<div class="paragraph">
<p>Sometimes, it is helpful to provide a more detailed textual description of a bean. This can
be particularly useful when beans are exposed (perhaps through JMX) for monitoring purposes.</p>
</div>
<div class="paragraph">
<p>To add a description to a <code>@Bean</code>, you can use the
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/context/annotation/Description.html"><code>@Description</code></a>
annotation, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class AppConfig {

    @Bean
    @Description("Provides a basic example of a bean")
    public Thing thing() {
        return new Thing();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
class AppConfig {

    @Bean
    @Description("Provides a basic example of a bean")
    fun thing() = Thing()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-java-configuration-annotation"><a class="anchor" href="#beans-java-configuration-annotation"></a>1.12.4. Using the <code>@Configuration</code> annotation</h4>
<div class="paragraph">
<p><code>@Configuration</code> is a class-level annotation indicating that an object is a source of
bean definitions. <code>@Configuration</code> classes declare beans through <code>@Bean</code> annotated
methods. Calls to <code>@Bean</code> methods on <code>@Configuration</code> classes can also be used to define
inter-bean dependencies. See <a href="#beans-java-basic-concepts">Basic Concepts: <code>@Bean</code> and <code>@Configuration</code></a> for a general introduction.</p>
</div>
<div class="sect4">
<h5 id="beans-java-injecting-dependencies"><a class="anchor" href="#beans-java-injecting-dependencies"></a>Injecting Inter-bean Dependencies</h5>
<div class="paragraph">
<p>When beans have dependencies on one another, expressing that dependency is as simple
as having one bean method call another, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class AppConfig {

    @Bean
    public BeanOne beanOne() {
        return new BeanOne(beanTwo());
    }

    @Bean
    public BeanTwo beanTwo() {
        return new BeanTwo();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
class AppConfig {

    @Bean
    fun beanOne() = BeanOne(beanTwo())

    @Bean
    fun beanTwo() = BeanTwo()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, <code>beanOne</code> receives a reference to <code>beanTwo</code> through constructor
injection.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This method of declaring inter-bean dependencies works only when the <code>@Bean</code> method
is declared within a <code>@Configuration</code> class. You cannot declare inter-bean dependencies
by using plain <code>@Component</code> classes.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-method-injection"><a class="anchor" href="#beans-java-method-injection"></a>Lookup Method Injection</h5>
<div class="paragraph">
<p>As noted earlier, <a href="#beans-factory-method-injection">lookup method injection</a> is an
advanced feature that you should use rarely. It is useful in cases where a
singleton-scoped bean has a dependency on a prototype-scoped bean. Using Java for this
type of configuration provides a natural means for implementing this pattern. The
following example shows how to use lookup method injection:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public abstract class CommandManager {
    public Object process(Object commandState) {
        // grab a new instance of the appropriate Command interface
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    // okay... but where is the implementation of this method?
    protected abstract Command createCommand();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">abstract class CommandManager {
    fun process(commandState: Any): Any {
        // grab a new instance of the appropriate Command interface
        val command = createCommand()
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState)
        return command.execute()
    }

    // okay... but where is the implementation of this method?
    protected abstract fun createCommand(): Command
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>By using Java configuration, you can create a subclass of <code>CommandManager</code> where
the abstract <code>createCommand()</code> method is overridden in such a way that it looks up a new
(prototype) command object. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
@Scope("prototype")
public AsyncCommand asyncCommand() {
    AsyncCommand command = new AsyncCommand();
    // inject dependencies here as required
    return command;
}

@Bean
public CommandManager commandManager() {
    // return new anonymous implementation of CommandManager with createCommand()
    // overridden to return a new prototype Command object
    return new CommandManager() {
        protected Command createCommand() {
            return asyncCommand();
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Bean
@Scope("prototype")
fun asyncCommand(): AsyncCommand {
    val command = AsyncCommand()
    // inject dependencies here as required
    return command
}

@Bean
fun commandManager(): CommandManager {
    // return new anonymous implementation of CommandManager with createCommand()
    // overridden to return a new prototype Command object
    return object : CommandManager() {
        override fun createCommand(): Command {
            return asyncCommand()
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-further-information-java-config"><a class="anchor" href="#beans-java-further-information-java-config"></a>Further Information About How Java-based Configuration Works Internally</h5>
<div class="paragraph">
<p>Consider the following example, which shows a <code>@Bean</code> annotated method being called twice:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class AppConfig {

    @Bean
    public ClientService clientService1() {
        ClientServiceImpl clientService = new ClientServiceImpl();
        clientService.setClientDao(clientDao());
        return clientService;
    }

    @Bean
    public ClientService clientService2() {
        ClientServiceImpl clientService = new ClientServiceImpl();
        clientService.setClientDao(clientDao());
        return clientService;
    }

    @Bean
    public ClientDao clientDao() {
        return new ClientDaoImpl();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
class AppConfig {

    @Bean
    fun clientService1(): ClientService {
        return ClientServiceImpl().apply {
            clientDao = clientDao()
        }
    }

    @Bean
    fun clientService2(): ClientService {
        return ClientServiceImpl().apply {
            clientDao = clientDao()
        }
    }

    @Bean
    fun clientDao(): ClientDao {
        return ClientDaoImpl()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>clientDao()</code> has been called once in <code>clientService1()</code> and once in <code>clientService2()</code>.
Since this method creates a new instance of <code>ClientDaoImpl</code> and returns it, you would
normally expect to have two instances (one for each service). That definitely would be
problematic: In Spring, instantiated beans have a <code>singleton</code> scope by default. This is
where the magic comes in: All <code>@Configuration</code> classes are subclassed at startup-time
with <code>CGLIB</code>. In the subclass, the child method checks the container first for any
cached (scoped) beans before it calls the parent method and creates a new instance.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The behavior could be different according to the scope of your bean. We are talking
about singletons here.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As of Spring 3.2, it is no longer necessary to add CGLIB to your classpath because CGLIB
classes have been repackaged under <code>org.springframework.cglib</code> and included directly
within the spring-core JAR.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>There are a few restrictions due to the fact that CGLIB dynamically adds features at
startup-time. In particular, configuration classes must not be final. However, as
of 4.3, any constructors are allowed on configuration classes, including the use of
<code>@Autowired</code> or a single non-default constructor declaration for default injection.</p>
</div>
<div class="paragraph">
<p>If you prefer to avoid any CGLIB-imposed limitations, consider declaring your <code>@Bean</code>
methods on non-<code>@Configuration</code> classes (for example, on plain <code>@Component</code> classes instead).
Cross-method calls between <code>@Bean</code> methods are not then intercepted, so you have
to exclusively rely on dependency injection at the constructor or method level there.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-java-composing-configuration-classes"><a class="anchor" href="#beans-java-composing-configuration-classes"></a>1.12.5. Composing Java-based Configurations</h4>
<div class="paragraph">
<p>Spring&#8217;s Java-based configuration feature lets you compose annotations, which can reduce
the complexity of your configuration.</p>
</div>
<div class="sect4">
<h5 id="beans-java-using-import"><a class="anchor" href="#beans-java-using-import"></a>Using the <code>@Import</code> Annotation</h5>
<div class="paragraph">
<p>Much as the <code>&lt;import/&gt;</code> element is used within Spring XML files to aid in modularizing
configurations, the <code>@Import</code> annotation allows for loading <code>@Bean</code> definitions from
another configuration class, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class ConfigA {

    @Bean
    public A a() {
        return new A();
    }
}

@Configuration
@Import(ConfigA.class)
public class ConfigB {

    @Bean
    public B b() {
        return new B();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
class ConfigA {

    @Bean
    fun a() = A()
}

@Configuration
@Import(ConfigA::class)
class ConfigB {

    @Bean
    fun b() = B()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, rather than needing to specify both <code>ConfigA.class</code> and <code>ConfigB.class</code> when
instantiating the context, only <code>ConfigB</code> needs to be supplied explicitly, as the
following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);

    // now both beans A and B will be available...
    A a = ctx.getBean(A.class);
    B b = ctx.getBean(B.class);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.beans.factory.getBean

fun main() {
    val ctx = AnnotationConfigApplicationContext(ConfigB::class.java)

    // now both beans A and B will be available...
    val a = ctx.getBean&lt;A&gt;()
    val b = ctx.getBean&lt;B&gt;()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This approach simplifies container instantiation, as only one class needs to be dealt
with, rather than requiring you to remember a potentially large number of
<code>@Configuration</code> classes during construction.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
As of Spring Framework 4.2, <code>@Import</code> also supports references to regular component
classes, analogous to the <code>AnnotationConfigApplicationContext.register</code> method.
This is particularly useful if you want to avoid component scanning, by using a few
configuration classes as entry points to explicitly define all your components.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="beans-java-injecting-imported-beans"><a class="anchor" href="#beans-java-injecting-imported-beans"></a>Injecting Dependencies on Imported <code>@Bean</code> Definitions</h6>
<div class="paragraph">
<p>The preceding example works but is simplistic. In most practical scenarios, beans have
dependencies on one another across configuration classes. When using XML, this is not an
issue, because no compiler is involved, and you can declare
<code>ref="someBean"</code> and trust Spring to work it out during container initialization.
When using <code>@Configuration</code> classes, the Java compiler places constraints on
the configuration model, in that references to other beans must be valid Java syntax.</p>
</div>
<div class="paragraph">
<p>Fortunately, solving this problem is simple. As <a href="#beans-java-dependencies">we already discussed</a>,
a <code>@Bean</code> method can have an arbitrary number of parameters that describe the bean
dependencies. Consider the following more real-world scenario with several <code>@Configuration</code>
classes, each depending on beans declared in the others:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class ServiceConfig {

    @Bean
    public TransferService transferService(AccountRepository accountRepository) {
        return new TransferServiceImpl(accountRepository);
    }
}

@Configuration
public class RepositoryConfig {

    @Bean
    public AccountRepository accountRepository(DataSource dataSource) {
        return new JdbcAccountRepository(dataSource);
    }
}

@Configuration
@Import({ServiceConfig.class, RepositoryConfig.class})
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // return new DataSource
    }
}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    // everything wires up across configuration classes...
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, "A123", "C456");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.beans.factory.getBean

@Configuration
class ServiceConfig {

    @Bean
    fun transferService(accountRepository: AccountRepository): TransferService {
        return TransferServiceImpl(accountRepository)
    }
}

@Configuration
class RepositoryConfig {

    @Bean
    fun accountRepository(dataSource: DataSource): AccountRepository {
        return JdbcAccountRepository(dataSource)
    }
}

@Configuration
@Import(ServiceConfig::class, RepositoryConfig::class)
class SystemTestConfig {

    @Bean
    fun dataSource(): DataSource {
        // return new DataSource
    }
}


fun main() {
    val ctx = AnnotationConfigApplicationContext(SystemTestConfig::class.java)
    // everything wires up across configuration classes...
    val transferService = ctx.getBean&lt;TransferService&gt;()
    transferService.transfer(100.00, "A123", "C456")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is another way to achieve the same result. Remember that <code>@Configuration</code> classes are
ultimately only another bean in the container: This means that they can take advantage of
<code>@Autowired</code> and <code>@Value</code> injection and other features the same as any other bean.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Make sure that the dependencies you inject that way are of the simplest kind only. <code>@Configuration</code>
classes are processed quite early during the initialization of the context, and forcing a dependency
to be injected this way may lead to unexpected early initialization. Whenever possible, resort to
parameter-based injection, as in the preceding example.</p>
</div>
<div class="paragraph">
<p>Also, be particularly careful with <code>BeanPostProcessor</code> and <code>BeanFactoryPostProcessor</code> definitions
through <code>@Bean</code>. Those should usually be declared as <code>static @Bean</code> methods, not triggering the
instantiation of their containing configuration class. Otherwise, <code>@Autowired</code> and <code>@Value</code> may not
work on the configuration class itself, since it is possible to create it as a bean instance earlier than
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html"><code>AutowiredAnnotationBeanPostProcessor</code></a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows how one bean can be autowired to another bean:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class ServiceConfig {

    @Autowired
    private AccountRepository accountRepository;

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl(accountRepository);
    }
}

@Configuration
public class RepositoryConfig {

    private final DataSource dataSource;

    public RepositoryConfig(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }
}

@Configuration
@Import({ServiceConfig.class, RepositoryConfig.class})
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // return new DataSource
    }
}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    // everything wires up across configuration classes...
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, "A123", "C456");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.beans.factory.getBean

@Configuration
class ServiceConfig {

    @Autowired
    lateinit var accountRepository: AccountRepository

    @Bean
    fun transferService(): TransferService {
        return TransferServiceImpl(accountRepository)
    }
}

@Configuration
class RepositoryConfig(private val dataSource: DataSource) {

    @Bean
    fun accountRepository(): AccountRepository {
        return JdbcAccountRepository(dataSource)
    }
}

@Configuration
@Import(ServiceConfig::class, RepositoryConfig::class)
class SystemTestConfig {

    @Bean
    fun dataSource(): DataSource {
        // return new DataSource
    }
}

fun main() {
    val ctx = AnnotationConfigApplicationContext(SystemTestConfig::class.java)
    // everything wires up across configuration classes...
    val transferService = ctx.getBean&lt;TransferService&gt;()
    transferService.transfer(100.00, "A123", "C456")
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Constructor injection in <code>@Configuration</code> classes is only supported as of Spring
Framework 4.3. Note also that there is no need to specify <code>@Autowired</code> if the target
bean defines only one constructor.
</td>
</tr>
</table>
</div>
<div class="openblock">
<div class="title"><a id="beans-java-injecting-imported-beans-fq"></a>Fully-qualifying imported beans for ease of navigation</div>
<div class="content">
<div class="paragraph">
<p>In the preceding scenario, using <code>@Autowired</code> works well and provides the desired
modularity, but determining exactly where the autowired bean definitions are declared is
still somewhat ambiguous. For example, as a developer looking at <code>ServiceConfig</code>, how do
you know exactly where the <code>@Autowired AccountRepository</code> bean is declared? It is not
explicit in the code, and this may be just fine. Remember that the
<a href="https://spring.io/tools">Spring Tools for Eclipse</a> provides tooling that
can render graphs showing how everything is wired, which may be all you need. Also,
your Java IDE can easily find all declarations and uses of the <code>AccountRepository</code> type
and quickly show you the location of <code>@Bean</code> methods that return that type.</p>
</div>
<div class="paragraph">
<p>In cases where this ambiguity is not acceptable and you wish to have direct navigation
from within your IDE from one <code>@Configuration</code> class to another, consider autowiring the
configuration classes themselves. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class ServiceConfig {

    @Autowired
    private RepositoryConfig repositoryConfig;

    @Bean
    public TransferService transferService() {
        // navigate 'through' the config class to the @Bean method!
        return new TransferServiceImpl(repositoryConfig.accountRepository());
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
class ServiceConfig {

    @Autowired
    private lateinit var repositoryConfig: RepositoryConfig

    @Bean
    fun transferService(): TransferService {
        // navigate 'through' the config class to the @Bean method!
        return TransferServiceImpl(repositoryConfig.accountRepository())
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding situation, where <code>AccountRepository</code> is defined is completely explicit.
However, <code>ServiceConfig</code> is now tightly coupled to <code>RepositoryConfig</code>. That is the
tradeoff. This tight coupling can be somewhat mitigated by using interface-based or
abstract class-based <code>@Configuration</code> classes. Consider the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class ServiceConfig {

    @Autowired
    private RepositoryConfig repositoryConfig;

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl(repositoryConfig.accountRepository());
    }
}

@Configuration
public interface RepositoryConfig {

    @Bean
    AccountRepository accountRepository();
}

@Configuration
public class DefaultRepositoryConfig implements RepositoryConfig {

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(...);
    }
}

@Configuration
@Import({ServiceConfig.class, DefaultRepositoryConfig.class})  // import the concrete config!
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // return DataSource
    }

}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, "A123", "C456");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.beans.factory.getBean

@Configuration
class ServiceConfig {

    @Autowired
    private lateinit var repositoryConfig: RepositoryConfig

    @Bean
    fun transferService(): TransferService {
        return TransferServiceImpl(repositoryConfig.accountRepository())
    }
}

@Configuration
interface RepositoryConfig {

    @Bean
    fun accountRepository(): AccountRepository
}

@Configuration
class DefaultRepositoryConfig : RepositoryConfig {

    @Bean
    fun accountRepository(): AccountRepository {
        return JdbcAccountRepository(...)
    }
}

@Configuration
@Import(ServiceConfig::class, DefaultRepositoryConfig::class)  // import the concrete config!
class SystemTestConfig {

    @Bean
    fun dataSource(): DataSource {
        // return DataSource
    }

}

fun main() {
    val ctx = AnnotationConfigApplicationContext(SystemTestConfig::class.java)
    val transferService = ctx.getBean&lt;TransferService&gt;()
    transferService.transfer(100.00, "A123", "C456")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now <code>ServiceConfig</code> is loosely coupled with respect to the concrete
<code>DefaultRepositoryConfig</code>, and built-in IDE tooling is still useful: You can easily
get a type hierarchy of <code>RepositoryConfig</code> implementations. In this
way, navigating <code>@Configuration</code> classes and their dependencies becomes no different
than the usual process of navigating interface-based code.</p>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you want to influence the startup creation order of certain beans, consider
declaring some of them as <code>@Lazy</code> (for creation on first access instead of on startup)
or as <code>@DependsOn</code> certain other beans (making sure that specific other beans are
created before the current bean, beyond what the latter&#8217;s direct dependencies imply).
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-conditional"><a class="anchor" href="#beans-java-conditional"></a>Conditionally Include <code>@Configuration</code> Classes or <code>@Bean</code> Methods</h5>
<div class="paragraph">
<p>It is often useful to conditionally enable or disable a complete <code>@Configuration</code> class
or even individual <code>@Bean</code> methods, based on some arbitrary system state. One common
example of this is to use the <code>@Profile</code> annotation to activate beans only when a specific
profile has been enabled in the Spring <code>Environment</code> (see <a href="#beans-definition-profiles">Bean Definition Profiles</a>
for details).</p>
</div>
<div class="paragraph">
<p>The <code>@Profile</code> annotation is actually implemented by using a much more flexible annotation
called <a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/context/annotation/Conditional.html"><code>@Conditional</code></a>.
The <code>@Conditional</code> annotation indicates specific
<code>org.springframework.context.annotation.Condition</code> implementations that should be
consulted before a <code>@Bean</code> is registered.</p>
</div>
<div class="paragraph">
<p>Implementations of the <code>Condition</code> interface provide a <code>matches(&#8230;&#8203;)</code>
method that returns <code>true</code> or <code>false</code>. For example, the following listing shows the actual
<code>Condition</code> implementation used for <code>@Profile</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Override
public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
    // Read the @Profile annotation attributes
    MultiValueMap&lt;String, Object&gt; attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());
    if (attrs != null) {
        for (Object value : attrs.get("value")) {
            if (context.getEnvironment().acceptsProfiles(((String[]) value))) {
                return true;
            }
        }
        return false;
    }
    return true;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">override fun matches(context: ConditionContext, metadata: AnnotatedTypeMetadata): Boolean {
    // Read the @Profile annotation attributes
    val attrs = metadata.getAllAnnotationAttributes(Profile::class.java.name)
    if (attrs != null) {
        for (value in attrs["value"]!!) {
            if (context.environment.acceptsProfiles(Profiles .of(*value as Array&lt;String&gt;))) {
                return true
            }
        }
        return false
    }
    return true
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/context/annotation/Conditional.html"><code>@Conditional</code></a>
javadoc for more detail.</p>
</div>
</div>
<div class="sect4">
<h5 id="beans-java-combining"><a class="anchor" href="#beans-java-combining"></a>Combining Java and XML Configuration</h5>
<div class="paragraph">
<p>Spring&#8217;s <code>@Configuration</code> class support does not aim to be a 100% complete replacement
for Spring XML. Some facilities, such as Spring XML namespaces, remain an ideal way to
configure the container. In cases where XML is convenient or necessary, you have a
choice: either instantiate the container in an &#8220;XML-centric&#8221; way by using, for example,
<code>ClassPathXmlApplicationContext</code>, or instantiate it in a &#8220;Java-centric&#8221; way by using
<code>AnnotationConfigApplicationContext</code> and the <code>@ImportResource</code> annotation to import XML
as needed.</p>
</div>
<div class="sect5">
<h6 id="beans-java-combining-xml-centric"><a class="anchor" href="#beans-java-combining-xml-centric"></a>XML-centric Use of <code>@Configuration</code> Classes</h6>
<div class="paragraph">
<p>It may be preferable to bootstrap the Spring container from XML and include
<code>@Configuration</code> classes in an ad-hoc fashion. For example, in a large existing codebase
that uses Spring XML, it is easier to create <code>@Configuration</code> classes on an
as-needed basis and include them from the existing XML files. Later in this section, we cover the
options for using <code>@Configuration</code> classes in this kind of &#8220;XML-centric&#8221; situation.</p>
</div>
<div class="openblock">
<div class="title"><a id="beans-java-combining-xml-centric-declare-as-bean"></a>Declaring <code>@Configuration</code> classes as plain Spring <code>&lt;bean/&gt;</code> elements</div>
<div class="content">
<div class="paragraph">
<p>Remember that <code>@Configuration</code> classes are ultimately bean definitions in the
container. In this series examples, we create a <code>@Configuration</code> class named <code>AppConfig</code> and
include it within <code>system-test-config.xml</code> as a <code>&lt;bean/&gt;</code> definition. Because
<code>&lt;context:annotation-config/&gt;</code> is switched on, the container recognizes the
<code>@Configuration</code> annotation and processes the <code>@Bean</code> methods declared in <code>AppConfig</code>
properly.</p>
</div>
<div class="paragraph">
<p>The following example shows an ordinary configuration class in Java:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class AppConfig {

    @Autowired
    private DataSource dataSource;

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }

    @Bean
    public TransferService transferService() {
        return new TransferService(accountRepository());
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
class AppConfig {

    @Autowired
    private lateinit var dataSource: DataSource

    @Bean
    fun accountRepository(): AccountRepository {
        return JdbcAccountRepository(dataSource)
    }

    @Bean
    fun transferService() = TransferService(accountRepository())
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows part of a sample <code>system-test-config.xml</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;!-- enable processing of annotations such as @Autowired and @Configuration --&gt;
    &lt;context:annotation-config/&gt;
    &lt;context:property-placeholder location="classpath:/com/acme/jdbc.properties"/&gt;

    &lt;bean class="com.acme.AppConfig"/&gt;

    &lt;bean class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
        &lt;property name="url" value="${jdbc.url}"/&gt;
        &lt;property name="username" value="${jdbc.username}"/&gt;
        &lt;property name="password" value="${jdbc.password}"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows a possible <code>jdbc.properties</code> file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=</pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public static void main(String[] args) {
    ApplicationContext ctx = new ClassPathXmlApplicationContext("classpath:/com/acme/system-test-config.xml");
    TransferService transferService = ctx.getBean(TransferService.class);
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun main() {
    val ctx = ClassPathXmlApplicationContext("classpath:/com/acme/system-test-config.xml")
    val transferService = ctx.getBean&lt;TransferService&gt;()
    // ...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In <code>system-test-config.xml</code> file, the <code>AppConfig</code> <code>&lt;bean/&gt;</code> does not declare an <code>id</code>
element. While it would be acceptable to do so, it is unnecessary, given that no other bean
ever refers to it, and it is unlikely to be explicitly fetched from the container by name.
Similarly, the <code>DataSource</code> bean is only ever autowired by type, so an explicit bean <code>id</code>
is not strictly required.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="openblock">
<div class="title"><a id="beans-java-combining-xml-centric-component-scan"></a> Using &lt;context:component-scan/&gt; to pick up <code>@Configuration</code> classes</div>
<div class="content">
<div class="paragraph">
<p>Because <code>@Configuration</code> is meta-annotated with <code>@Component</code>, <code>@Configuration</code>-annotated
classes are automatically candidates for component scanning. Using the same scenario as
describe in the previous example, we can redefine <code>system-test-config.xml</code> to take advantage of component-scanning.
Note that, in this case, we need not explicitly declare
<code>&lt;context:annotation-config/&gt;</code>, because <code>&lt;context:component-scan/&gt;</code> enables the same
functionality.</p>
</div>
<div class="paragraph">
<p>The following example shows the modified <code>system-test-config.xml</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;!-- picks up and registers AppConfig as a bean definition --&gt;
    &lt;context:component-scan base-package="com.acme"/&gt;
    &lt;context:property-placeholder location="classpath:/com/acme/jdbc.properties"/&gt;

    &lt;bean class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
        &lt;property name="url" value="${jdbc.url}"/&gt;
        &lt;property name="username" value="${jdbc.username}"/&gt;
        &lt;property name="password" value="${jdbc.password}"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="beans-java-combining-java-centric"><a class="anchor" href="#beans-java-combining-java-centric"></a><code>@Configuration</code> Class-centric Use of XML with <code>@ImportResource</code></h6>
<div class="paragraph">
<p>In applications where <code>@Configuration</code> classes are the primary mechanism for configuring
the container, it is still likely necessary to use at least some XML. In these
scenarios, you can use <code>@ImportResource</code> and define only as much XML as you need. Doing
so achieves a &#8220;Java-centric&#8221; approach to configuring the container and keeps XML to a
bare minimum. The following example (which includes a configuration class, an XML file
that defines a bean, a properties file, and the <code>main</code> class) shows how to use
the <code>@ImportResource</code> annotation to achieve &#8220;Java-centric&#8221; configuration that uses XML
as needed:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@ImportResource("classpath:/com/acme/properties-config.xml")
public class AppConfig {

    @Value("${jdbc.url}")
    private String url;

    @Value("${jdbc.username}")
    private String username;

    @Value("${jdbc.password}")
    private String password;

    @Bean
    public DataSource dataSource() {
        return new DriverManagerDataSource(url, username, password);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@ImportResource("classpath:/com/acme/properties-config.xml")
class AppConfig {

    @Value("\${jdbc.url}")
    private lateinit var url: String

    @Value("\${jdbc.username}")
    private lateinit var username: String

    @Value("\${jdbc.password}")
    private lateinit var password: String

    @Bean
    fun dataSource(): DataSource {
        return DriverManagerDataSource(url, username, password)
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">properties-config.xml
&lt;beans&gt;
    &lt;context:property-placeholder location="classpath:/com/acme/jdbc.properties"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>jdbc.properties
jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=</pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
    TransferService transferService = ctx.getBean(TransferService.class);
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.beans.factory.getBean

fun main() {
    val ctx = AnnotationConfigApplicationContext(AppConfig::class.java)
    val transferService = ctx.getBean&lt;TransferService&gt;()
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-environment"><a class="anchor" href="#beans-environment"></a>1.13. Environment Abstraction</h3>
<div class="paragraph">
<p>The <a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/core/env/Environment.html"><code>Environment</code></a> interface
is an abstraction integrated in the container that models two key
aspects of the application environment: <a href="#beans-definition-profiles">profiles</a>
and <a href="#beans-property-source-abstraction">properties</a>.</p>
</div>
<div class="paragraph">
<p>A profile is a named, logical group of bean definitions to be registered with the
container only if the given profile is active. Beans may be assigned to a profile
whether defined in XML or with annotations. The role of the <code>Environment</code> object with
relation to profiles is in determining which profiles (if any) are currently active,
and which profiles (if any) should be active by default.</p>
</div>
<div class="paragraph">
<p>Properties play an important role in almost all applications and may originate from
a variety of sources: properties files, JVM system properties, system environment
variables, JNDI, servlet context parameters, ad-hoc <code>Properties</code> objects, <code>Map</code> objects, and so
on. The role of the <code>Environment</code> object with relation to properties is to provide the
user with a convenient service interface for configuring property sources and resolving
properties from them.</p>
</div>
<div class="sect3">
<h4 id="beans-definition-profiles"><a class="anchor" href="#beans-definition-profiles"></a>1.13.1. Bean Definition Profiles</h4>
<div class="paragraph">
<p>Bean definition profiles provide a mechanism in the core container that allows for
registration of different beans in different environments. The word, &#8220;environment,&#8221;
can mean different things to different users, and this feature can help with many
use cases, including:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Working against an in-memory datasource in development versus looking up that same
datasource from JNDI when in QA or production.</p>
</li>
<li>
<p>Registering monitoring infrastructure only when deploying an application into a
performance environment.</p>
</li>
<li>
<p>Registering customized implementations of beans for customer A versus customer
B deployments.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Consider the first use case in a practical application that requires a
<code>DataSource</code>. In a test environment, the configuration might resemble the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean
public DataSource dataSource() {
    return new EmbeddedDatabaseBuilder()
        .setType(EmbeddedDatabaseType.HSQL)
        .addScript("my-schema.sql")
        .addScript("my-test-data.sql")
        .build();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Bean
fun dataSource(): DataSource {
    return EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("my-schema.sql")
            .addScript("my-test-data.sql")
            .build()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now consider how this application can be deployed into a QA or production
environment, assuming that the datasource for the application is registered
with the production application server&#8217;s JNDI directory. Our <code>dataSource</code> bean
now looks like the following listing:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Bean(destroyMethod="")
public DataSource dataSource() throws Exception {
    Context ctx = new InitialContext();
    return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Bean(destroyMethod = "")
fun dataSource(): DataSource {
    val ctx = InitialContext()
    return ctx.lookup("java:comp/env/jdbc/datasource") as DataSource
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The problem is how to switch between using these two variations based on the
current environment. Over time, Spring users have devised a number of ways to
get this done, usually relying on a combination of system environment variables
and XML <code>&lt;import/&gt;</code> statements containing <code>${placeholder}</code> tokens that resolve
to the correct configuration file path depending on the value of an environment
variable. Bean definition profiles is a core container feature that provides a
solution to this problem.</p>
</div>
<div class="paragraph">
<p>If we generalize the use case shown in the preceding example of environment-specific bean
definitions, we end up with the need to register certain bean definitions in
certain contexts but not in others. You could say that you want to register a
certain profile of bean definitions in situation A and a different profile in
situation B. We start by updating our configuration to reflect this need.</p>
</div>
<div class="sect4">
<h5 id="beans-definition-profiles-java"><a class="anchor" href="#beans-definition-profiles-java"></a>Using <code>@Profile</code></h5>
<div class="paragraph">
<p>The <a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/context/annotation/Profile.html"><code>@Profile</code></a>
annotation lets you indicate that a component is eligible for registration
when one or more specified profiles are active. Using our preceding example, we
can rewrite the <code>dataSource</code> configuration as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@Profile("development")
public class StandaloneDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .addScript("classpath:com/bank/config/sql/test-data.sql")
            .build();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@Profile("development")
class StandaloneDataConfig {

    @Bean
    fun dataSource(): DataSource {
        return EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.HSQL)
                .addScript("classpath:com/bank/config/sql/schema.sql")
                .addScript("classpath:com/bank/config/sql/test-data.sql")
                .build()
    }
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@Profile("production")
public class JndiDataConfig {

    @Bean(destroyMethod="")
    public DataSource dataSource() throws Exception {
        Context ctx = new InitialContext();
        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@Profile("production")
class JndiDataConfig {

    @Bean(destroyMethod = "")
    fun dataSource(): DataSource {
        val ctx = InitialContext()
        return ctx.lookup("java:comp/env/jdbc/datasource") as DataSource
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As mentioned earlier, with <code>@Bean</code> methods, you typically choose to use programmatic
JNDI lookups, by using either Spring&#8217;s <code>JndiTemplate</code>/<code>JndiLocatorDelegate</code> helpers or the
straight JNDI <code>InitialContext</code> usage shown earlier but not the <code>JndiObjectFactoryBean</code>
variant, which would force you to declare the return type as the <code>FactoryBean</code> type.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The profile string may contain a simple profile name (for example, <code>production</code>) or a
profile expression. A profile expression allows for more complicated profile logic to be
expressed (for example, <code>production &amp; us-east</code>). The following operators are supported in
profile expressions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>!</code>: A logical &#8220;not&#8221; of the profile</p>
</li>
<li>
<p><code>&amp;</code>: A logical &#8220;and&#8221; of the profiles</p>
</li>
<li>
<p><code>|</code>: A logical &#8220;or&#8221; of the profiles</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You cannot mix the <code>&amp;</code> and <code>|</code> operators without using parentheses. For example,
<code>production &amp; us-east | eu-central</code> is not a valid expression. It must be expressed as
<code>production &amp; (us-east | eu-central)</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can use <code>@Profile</code> as a <a href="#beans-meta-annotations">meta-annotation</a> for the purpose
of creating a custom composed annotation. The following example defines a custom
<code>@Production</code> annotation that you can use as a drop-in replacement for
<code>@Profile("production")</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Profile("production")
public @interface Production {
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Target(AnnotationTarget.TYPE)
@Retention(AnnotationRetention.RUNTIME)
@Profile("production")
annotation class Production</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If a <code>@Configuration</code> class is marked with <code>@Profile</code>, all of the <code>@Bean</code> methods and
<code>@Import</code> annotations associated with that class are bypassed unless one or more of
the specified profiles are active. If a <code>@Component</code> or <code>@Configuration</code> class is marked
with <code>@Profile({"p1", "p2"})</code>, that class is not registered or processed unless
profiles 'p1' or 'p2' have been activated. If a given profile is prefixed with the
NOT operator (<code>!</code>), the annotated element is registered only if the profile is not
active. For example, given <code>@Profile({"p1", "!p2"})</code>, registration will occur if profile
'p1' is active or if profile 'p2' is not active.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>@Profile</code> can also be declared at the method level to include only one particular bean
of a configuration class (for example, for alternative variants of a particular bean), as
the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class AppConfig {

    @Bean("dataSource")
    @Profile("development") <i class="conum" data-value="1"></i><b>(1)</b>
    public DataSource standaloneDataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .addScript("classpath:com/bank/config/sql/test-data.sql")
            .build();
    }

    @Bean("dataSource")
    @Profile("production") <i class="conum" data-value="2"></i><b>(2)</b>
    public DataSource jndiDataSource() throws Exception {
        Context ctx = new InitialContext();
        return (DataSource) ctx.lookup("java:comp/env/jdbc/datasource");
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>standaloneDataSource</code> method is available only in the <code>development</code> profile.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>jndiDataSource</code> method is available only in the <code>production</code> profile.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
class AppConfig {

    @Bean("dataSource")
    @Profile("development") <i class="conum" data-value="1"></i><b>(1)</b>
    fun standaloneDataSource(): DataSource {
        return EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.HSQL)
                .addScript("classpath:com/bank/config/sql/schema.sql")
                .addScript("classpath:com/bank/config/sql/test-data.sql")
                .build()
    }

    @Bean("dataSource")
    @Profile("production") <i class="conum" data-value="2"></i><b>(2)</b>
    fun jndiDataSource() =
        InitialContext().lookup("java:comp/env/jdbc/datasource") as DataSource
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>standaloneDataSource</code> method is available only in the <code>development</code> profile.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>jndiDataSource</code> method is available only in the <code>production</code> profile.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>With <code>@Profile</code> on <code>@Bean</code> methods, a special scenario may apply: In the case of
overloaded <code>@Bean</code> methods of the same Java method name (analogous to constructor
overloading), a <code>@Profile</code> condition needs to be consistently declared on all
overloaded methods. If the conditions are inconsistent, only the condition on the
first declaration among the overloaded methods matters. Therefore, <code>@Profile</code> can
not be used to select an overloaded method with a particular argument signature over
another. Resolution between all factory methods for the same bean follows Spring&#8217;s
constructor resolution algorithm at creation time.</p>
</div>
<div class="paragraph">
<p>If you want to define alternative beans with different profile conditions,
use distinct Java method names that point to the same bean name by using the <code>@Bean</code> name
attribute, as shown in the preceding example. If the argument signatures are all
the same (for example, all of the variants have no-arg factory methods), this is the only
way to represent such an arrangement in a valid Java class in the first place
(since there can only be one method of a particular name and argument signature).</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-definition-profiles-xml"><a class="anchor" href="#beans-definition-profiles-xml"></a>XML Bean Definition Profiles</h5>
<div class="paragraph">
<p>The XML counterpart is the <code>profile</code> attribute of the <code>&lt;beans&gt;</code> element. Our preceding sample
configuration can be rewritten in two XML files, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans profile="development"
    xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jdbc="http://www.springframework.org/schema/jdbc"
    xsi:schemaLocation="..."&gt;

    &lt;jdbc:embedded-database id="dataSource"&gt;
        &lt;jdbc:script location="classpath:com/bank/config/sql/schema.sql"/&gt;
        &lt;jdbc:script location="classpath:com/bank/config/sql/test-data.sql"/&gt;
    &lt;/jdbc:embedded-database&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans profile="production"
    xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xsi:schemaLocation="..."&gt;

    &lt;jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to avoid that split and nest <code>&lt;beans/&gt;</code> elements within the same file,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jdbc="http://www.springframework.org/schema/jdbc"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xsi:schemaLocation="..."&gt;

    &lt;!-- other bean definitions --&gt;

    &lt;beans profile="development"&gt;
        &lt;jdbc:embedded-database id="dataSource"&gt;
            &lt;jdbc:script location="classpath:com/bank/config/sql/schema.sql"/&gt;
            &lt;jdbc:script location="classpath:com/bank/config/sql/test-data.sql"/&gt;
        &lt;/jdbc:embedded-database&gt;
    &lt;/beans&gt;

    &lt;beans profile="production"&gt;
        &lt;jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/&gt;
    &lt;/beans&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>spring-bean.xsd</code> has been constrained to allow such elements only as the
last ones in the file. This should help provide flexibility without incurring
clutter in the XML files.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The XML counterpart does not support the profile expressions described earlier. It is possible,
however, to negate a profile by using the <code>!</code> operator. It is also possible to apply a logical
&#8220;and&#8221; by nesting the profiles, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:jdbc="http://www.springframework.org/schema/jdbc"
    xmlns:jee="http://www.springframework.org/schema/jee"
    xsi:schemaLocation="..."&gt;

    &lt;!-- other bean definitions --&gt;

    &lt;beans profile="production"&gt;
        &lt;beans profile="us-east"&gt;
            &lt;jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/datasource"/&gt;
        &lt;/beans&gt;
    &lt;/beans&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the <code>dataSource</code> bean is exposed if both the <code>production</code> and
<code>us-east</code> profiles are active.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="beans-definition-profiles-enable"><a class="anchor" href="#beans-definition-profiles-enable"></a>Activating a Profile</h5>
<div class="paragraph">
<p>Now that we have updated our configuration, we still need to instruct Spring which
profile is active. If we started our sample application right now, we would see
a <code>NoSuchBeanDefinitionException</code> thrown, because the container could not find
the Spring bean named <code>dataSource</code>.</p>
</div>
<div class="paragraph">
<p>Activating a profile can be done in several ways, but the most straightforward is to do
it programmatically against the <code>Environment</code> API which is available through an
<code>ApplicationContext</code>. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
ctx.getEnvironment().setActiveProfiles("development");
ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);
ctx.refresh();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val ctx = AnnotationConfigApplicationContext().apply {
    environment.setActiveProfiles("development")
    register(SomeConfig::class.java, StandaloneDataConfig::class.java, JndiDataConfig::class.java)
    refresh()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition, you can also declaratively activate profiles through the
<code>spring.profiles.active</code> property, which may be specified through system environment
variables, JVM system properties, servlet context parameters in <code>web.xml</code>, or even as an
entry in JNDI (see <a href="#beans-property-source-abstraction"><code>PropertySource</code> Abstraction</a>). In integration tests, active
profiles can be declared by using the <code>@ActiveProfiles</code> annotation in the <code>spring-test</code>
module (see <a href="testing.html#testcontext-ctx-management-env-profiles">context configuration with environment profiles</a>).</p>
</div>
<div class="paragraph">
<p>Note that profiles are not an &#8220;either-or&#8221; proposition. You can activate multiple
profiles at once. Programmatically, you can provide multiple profile names to the
<code>setActiveProfiles()</code> method, which accepts <code>String&#8230;&#8203;</code> varargs. The following example
activates multiple profiles:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ctx.getEnvironment().setActiveProfiles("profile1", "profile2");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">ctx.getEnvironment().setActiveProfiles("profile1", "profile2")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Declaratively, <code>spring.profiles.active</code> may accept a comma-separated list of profile names,
as the following example shows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    -Dspring.profiles.active="profile1,profile2"</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="beans-definition-profiles-default"><a class="anchor" href="#beans-definition-profiles-default"></a>Default Profile</h5>
<div class="paragraph">
<p>The default profile represents the profile that is enabled by default. Consider the
following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@Profile("default")
public class DefaultDataConfig {

    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.HSQL)
            .addScript("classpath:com/bank/config/sql/schema.sql")
            .build();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@Profile("default")
class DefaultDataConfig {

    @Bean
    fun dataSource(): DataSource {
        return EmbeddedDatabaseBuilder()
                .setType(EmbeddedDatabaseType.HSQL)
                .addScript("classpath:com/bank/config/sql/schema.sql")
                .build()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If no profile is active, the <code>dataSource</code> is created. You can see this
as a way to provide a default definition for one or more beans. If any
profile is enabled, the default profile does not apply.</p>
</div>
<div class="paragraph">
<p>You can change the name of the default profile by using <code>setDefaultProfiles()</code> on
the <code>Environment</code> or ,declaratively, by using the <code>spring.profiles.default</code> property.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-property-source-abstraction"><a class="anchor" href="#beans-property-source-abstraction"></a>1.13.2. <code>PropertySource</code> Abstraction</h4>
<div class="paragraph">
<p>Spring&#8217;s <code>Environment</code> abstraction provides search operations over a configurable
hierarchy of property sources. Consider the following listing:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ApplicationContext ctx = new GenericApplicationContext();
Environment env = ctx.getEnvironment();
boolean containsMyProperty = env.containsProperty("my-property");
System.out.println("Does my environment contain the 'my-property' property? " + containsMyProperty);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val ctx = GenericApplicationContext()
val env = ctx.environment
val containsMyProperty = env.containsProperty("my-property")
println("Does my environment contain the 'my-property' property? $containsMyProperty")</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding snippet, we see a high-level way of asking Spring whether the <code>my-property</code> property is
defined for the current environment. To answer this question, the <code>Environment</code> object performs
a search over a set of <a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/core/env/PropertySource.html"><code>PropertySource</code></a>
objects. A <code>PropertySource</code> is a simple abstraction over any source of key-value pairs, and
Spring&#8217;s <a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/core/env/StandardEnvironment.html"><code>StandardEnvironment</code></a>
is configured with two PropertySource objects&#8201;&#8212;&#8201;one representing the set of JVM system properties
(<code>System.getProperties()</code>) and one representing the set of system environment variables
(<code>System.getenv()</code>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
These default property sources are present for <code>StandardEnvironment</code>, for use in standalone
applications. <a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/web/context/support/StandardServletEnvironment.html"><code>StandardServletEnvironment</code></a>
is populated with additional default property sources including servlet config and servlet
context parameters. It can optionally enable a <a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/jndi/JndiPropertySource.html"><code>JndiPropertySource</code></a>.
See the javadoc for details.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Concretely, when you use the <code>StandardEnvironment</code>, the call to <code>env.containsProperty("my-property")</code>
returns true if a <code>my-property</code> system property or <code>my-property</code> environment variable is present at
runtime.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The search performed is hierarchical. By default, system properties have precedence over
environment variables. So, if the <code>my-property</code> property happens to be set in both places during
a call to <code>env.getProperty("my-property")</code>, the system property value &#8220;wins&#8221; and is returned.
Note that property values are not merged
but rather completely overridden by a preceding entry.</p>
</div>
<div class="paragraph">
<p>For a common <code>StandardServletEnvironment</code>, the full hierarchy is as follows, with the
highest-precedence entries at the top:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>ServletConfig parameters (if applicable&#8201;&#8212;&#8201;for example, in case of a <code>DispatcherServlet</code> context)</p>
</li>
<li>
<p>ServletContext parameters (web.xml context-param entries)</p>
</li>
<li>
<p>JNDI environment variables (<code>java:comp/env/</code> entries)</p>
</li>
<li>
<p>JVM system properties (<code>-D</code> command-line arguments)</p>
</li>
<li>
<p>JVM system environment (operating system environment variables)</p>
</li>
</ol>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Most importantly, the entire mechanism is configurable. Perhaps you have a custom source
of properties that you want to integrate into this search. To do so, implement
and instantiate your own <code>PropertySource</code> and add it to the set of <code>PropertySources</code> for the
current <code>Environment</code>. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ConfigurableApplicationContext ctx = new GenericApplicationContext();
MutablePropertySources sources = ctx.getEnvironment().getPropertySources();
sources.addFirst(new MyPropertySource());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val ctx = GenericApplicationContext()
val sources = ctx.environment.propertySources
sources.addFirst(MyPropertySource())</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding code, <code>MyPropertySource</code> has been added with highest precedence in the
search. If it contains a <code>my-property</code> property, the property is detected and returned, in favor of
any <code>my-property</code> property in any other <code>PropertySource</code>. The
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/core/env/MutablePropertySources.html"><code>MutablePropertySources</code></a>
API exposes a number of methods that allow for precise manipulation of the set of
property sources.</p>
</div>
</div>
<div class="sect3">
<h4 id="beans-using-propertysource"><a class="anchor" href="#beans-using-propertysource"></a>1.13.3. Using <code>@PropertySource</code></h4>
<div class="paragraph">
<p>The <a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/context/annotation/PropertySource.html"><code>@PropertySource</code></a>
annotation provides a convenient and declarative mechanism for adding a <code>PropertySource</code>
to Spring&#8217;s <code>Environment</code>.</p>
</div>
<div class="paragraph">
<p>Given a file called <code>app.properties</code> that contains the key-value pair <code>testbean.name=myTestBean</code>,
the following <code>@Configuration</code> class uses <code>@PropertySource</code> in such a way that
a call to <code>testBean.getName()</code> returns <code>myTestBean</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@PropertySource("classpath:/com/myco/app.properties")
public class AppConfig {

    @Autowired
    Environment env;

    @Bean
    public TestBean testBean() {
        TestBean testBean = new TestBean();
        testBean.setName(env.getProperty("testbean.name"));
        return testBean;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@PropertySource("classpath:/com/myco/app.properties")
class AppConfig {

    @Autowired
    private lateinit var env: Environment

    @Bean
    fun testBean() = TestBean().apply {
        name = env.getProperty("testbean.name")!!
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any <code>${&#8230;&#8203;}</code> placeholders present in a <code>@PropertySource</code> resource location are
resolved against the set of property sources already registered against the
environment, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@PropertySource("classpath:/com/${my.placeholder:default/path}/app.properties")
public class AppConfig {

    @Autowired
    Environment env;

    @Bean
    public TestBean testBean() {
        TestBean testBean = new TestBean();
        testBean.setName(env.getProperty("testbean.name"));
        return testBean;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@PropertySource("classpath:/com/\${my.placeholder:default/path}/app.properties")
class AppConfig {

    @Autowired
    private lateinit var env: Environment

    @Bean
    fun testBean() = TestBean().apply {
        name = env.getProperty("testbean.name")!!
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assuming that <code>my.placeholder</code> is present in one of the property sources already
registered (for example, system properties or environment variables), the placeholder is
resolved to the corresponding value. If not, then <code>default/path</code> is used
as a default. If no default is specified and a property cannot be resolved, an
<code>IllegalArgumentException</code> is thrown.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>@PropertySource</code> annotation is repeatable, according to Java 8 conventions.
However, all such <code>@PropertySource</code> annotations need to be declared at the same
level, either directly on the configuration class or as meta-annotations within the
same custom annotation. Mixing direct annotations and meta-annotations is not
recommended, since direct annotations effectively override meta-annotations.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="beans-placeholder-resolution-in-statements"><a class="anchor" href="#beans-placeholder-resolution-in-statements"></a>1.13.4. Placeholder Resolution in Statements</h4>
<div class="paragraph">
<p>Historically, the value of placeholders in elements could be resolved only against
JVM system properties or environment variables. This is no longer the case. Because
the <code>Environment</code> abstraction is integrated throughout the container, it is easy to
route resolution of placeholders through it. This means that you may configure the
resolution process in any way you like. You can change the precedence of searching through
system properties and environment variables or remove them entirely. You can also add your
own property sources to the mix, as appropriate.</p>
</div>
<div class="paragraph">
<p>Concretely, the following statement works regardless of where the <code>customer</code>
property is defined, as long as it is available in the <code>Environment</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;import resource="com/bank/service/${customer}-config.xml"/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="context-load-time-weaver"><a class="anchor" href="#context-load-time-weaver"></a>1.14. Registering a <code>LoadTimeWeaver</code></h3>
<div class="paragraph">
<p>The <code>LoadTimeWeaver</code> is used by Spring to dynamically transform classes as they are
loaded into the Java virtual machine (JVM).</p>
</div>
<div class="paragraph">
<p>To enable load-time weaving, you can add the <code>@EnableLoadTimeWeaving</code> to one of your
<code>@Configuration</code> classes, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@EnableLoadTimeWeaving
public class AppConfig {
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@EnableLoadTimeWeaving
class AppConfig</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, for XML configuration, you can use the <code>context:load-time-weaver</code> element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;context:load-time-weaver/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once configured for the <code>ApplicationContext</code>, any bean within that <code>ApplicationContext</code>
may implement <code>LoadTimeWeaverAware</code>, thereby receiving a reference to the load-time
weaver instance. This is particularly useful in combination with
<a href="data-access.html#orm-jpa">Spring&#8217;s JPA support</a> where load-time weaving may be
necessary for JPA class transformation.
Consult the
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.html"><code>LocalContainerEntityManagerFactoryBean</code></a>
javadoc for more detail. For more on AspectJ load-time weaving, see <a href="#aop-aj-ltw">Load-time Weaving with AspectJ in the Spring Framework</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="context-introduction"><a class="anchor" href="#context-introduction"></a>1.15. Additional Capabilities of the <code>ApplicationContext</code></h3>
<div class="paragraph">
<p>As discussed in the <a href="#beans">chapter introduction</a>, the <code>org.springframework.beans.factory</code>
package provides basic functionality for managing and manipulating beans, including in a
programmatic way. The <code>org.springframework.context</code> package adds the
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/context/ApplicationContext.html"><code>ApplicationContext</code></a>
interface, which extends the <code>BeanFactory</code> interface, in addition to extending other
interfaces to provide additional functionality in a more application
framework-oriented style. Many people use the <code>ApplicationContext</code> in a completely
declarative fashion, not even creating it programmatically, but instead relying on
support classes such as <code>ContextLoader</code> to automatically instantiate an
<code>ApplicationContext</code> as part of the normal startup process of a Java EE web application.</p>
</div>
<div class="paragraph">
<p>To enhance <code>BeanFactory</code> functionality in a more framework-oriented style, the context
package also provides the following functionality:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Access to messages in i18n-style, through the <code>MessageSource</code> interface.</p>
</li>
<li>
<p>Access to resources, such as URLs and files, through the <code>ResourceLoader</code> interface.</p>
</li>
<li>
<p>Event publication, namely to beans that implement the <code>ApplicationListener</code> interface,
through the use of the <code>ApplicationEventPublisher</code> interface.</p>
</li>
<li>
<p>Loading of multiple (hierarchical) contexts, letting each be focused on one
particular layer, such as the web layer of an application, through the
<code>HierarchicalBeanFactory</code> interface.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="context-functionality-messagesource"><a class="anchor" href="#context-functionality-messagesource"></a>1.15.1. Internationalization using <code>MessageSource</code></h4>
<div class="paragraph">
<p>The <code>ApplicationContext</code> interface extends an interface called <code>MessageSource</code> and,
therefore, provides internationalization (&#8220;i18n&#8221;) functionality. Spring also provides the
<code>HierarchicalMessageSource</code> interface, which can resolve messages hierarchically.
Together, these interfaces provide the foundation upon which Spring effects message
resolution. The methods defined on these interfaces include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>String getMessage(String code, Object[] args, String default, Locale loc)</code>: The basic
method used to retrieve a message from the <code>MessageSource</code>. When no message is found
for the specified locale, the default message is used. Any arguments passed in become
replacement values, using the <code>MessageFormat</code> functionality provided by the standard
library.</p>
</li>
<li>
<p><code>String getMessage(String code, Object[] args, Locale loc)</code>: Essentially the same as
the previous method but with one difference: No default message can be specified. If
the message cannot be found, a <code>NoSuchMessageException</code> is thrown.</p>
</li>
<li>
<p><code>String getMessage(MessageSourceResolvable resolvable, Locale locale)</code>: All properties
used in the preceding methods are also wrapped in a class named
<code>MessageSourceResolvable</code>, which you can use with this method.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When an <code>ApplicationContext</code> is loaded, it automatically searches for a <code>MessageSource</code>
bean defined in the context. The bean must have the name <code>messageSource</code>. If such a bean
is found, all calls to the preceding methods are delegated to the message source. If no
message source is found, the <code>ApplicationContext</code> attempts to find a parent containing a
bean with the same name. If it does, it uses that bean as the <code>MessageSource</code>. If the
<code>ApplicationContext</code> cannot find any source for messages, an empty
<code>DelegatingMessageSource</code> is instantiated in order to be able to accept calls to the
methods defined above.</p>
</div>
<div class="paragraph">
<p>Spring provides three <code>MessageSource</code> implementations, <code>ResourceBundleMessageSource</code>, <code>ReloadableResourceBundleMessageSource</code>
and <code>StaticMessageSource</code>. All of them implement <code>HierarchicalMessageSource</code> in order to do nested
messaging. The <code>StaticMessageSource</code> is rarely used but provides programmatic ways to
add messages to the source. The following example shows <code>ResourceBundleMessageSource</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;
    &lt;bean id="messageSource"
            class="org.springframework.context.support.ResourceBundleMessageSource"&gt;
        &lt;property name="basenames"&gt;
            &lt;list&gt;
                &lt;value&gt;format&lt;/value&gt;
                &lt;value&gt;exceptions&lt;/value&gt;
                &lt;value&gt;windows&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example assumes that you have three resource bundles called <code>format</code>, <code>exceptions</code> and <code>windows</code>
defined in your classpath. Any request to resolve a message is
handled in the JDK-standard way of resolving messages through <code>ResourceBundle</code> objects. For the
purposes of the example, assume the contents of two of the above resource bundle files
are as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    # in format.properties
    message=Alligators rock!</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>    # in exceptions.properties
    argument.required=The {0} argument is required.</pre>
</div>
</div>
<div class="paragraph">
<p>The next example shows a program to run the <code>MessageSource</code> functionality.
Remember that all <code>ApplicationContext</code> implementations are also <code>MessageSource</code>
implementations and so can be cast to the <code>MessageSource</code> interface.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public static void main(String[] args) {
    MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
    String message = resources.getMessage("message", null, "Default", Locale.ENGLISH);
    System.out.println(message);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun main() {
    val resources = ClassPathXmlApplicationContext("beans.xml")
    val message = resources.getMessage("message", null, "Default", Locale.ENGLISH)
    println(message)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The resulting output from the above program is as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Alligators rock!</pre>
</div>
</div>
<div class="paragraph">
<p>To summarize, the <code>MessageSource</code> is defined in a file called <code>beans.xml</code>, which
exists at the root of your classpath. The <code>messageSource</code> bean definition refers to a
number of resource bundles through its <code>basenames</code> property. The three files that are
passed in the list to the <code>basenames</code> property exist as files at the root of your
classpath and are called <code>format.properties</code>, <code>exceptions.properties</code>, and
<code>windows.properties</code>, respectively.</p>
</div>
<div class="paragraph">
<p>The next example shows arguments passed to the message lookup. These arguments are
converted into <code>String</code> objects and inserted into placeholders in the lookup message.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans&gt;

    &lt;!-- this MessageSource is being used in a web application --&gt;
    &lt;bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource"&gt;
        &lt;property name="basename" value="exceptions"/&gt;
    &lt;/bean&gt;

    &lt;!-- lets inject the above MessageSource into this POJO --&gt;
    &lt;bean id="example" class="com.something.Example"&gt;
        &lt;property name="messages" ref="messageSource"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class Example {

    private MessageSource messages;

    public void setMessages(MessageSource messages) {
        this.messages = messages;
    }

    public void execute() {
        String message = this.messages.getMessage("argument.required",
            new Object [] {"userDao"}, "Required", Locale.ENGLISH);
        System.out.println(message);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">    class Example {

    lateinit var messages: MessageSource

    fun execute() {
        val message = messages.getMessage("argument.required",
                arrayOf("userDao"), "Required", Locale.ENGLISH)
        println(message)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The resulting output from the invocation of the <code>execute()</code> method is as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>The userDao argument is required.</pre>
</div>
</div>
<div class="paragraph">
<p>With regard to internationalization (&#8220;i18n&#8221;), Spring&#8217;s various <code>MessageSource</code>
implementations follow the same locale resolution and fallback rules as the standard JDK
<code>ResourceBundle</code>. In short, and continuing with the example <code>messageSource</code> defined
previously, if you want to resolve messages against the British (<code>en-GB</code>) locale, you
would create files called <code>format_en_GB.properties</code>, <code>exceptions_en_GB.properties</code>, and
<code>windows_en_GB.properties</code>, respectively.</p>
</div>
<div class="paragraph">
<p>Typically, locale resolution is managed by the surrounding environment of the
application. In the following example, the locale against which (British) messages are
resolved is specified manually:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># in exceptions_en_GB.properties
argument.required=Ebagum lad, the ''{0}'' argument is required, I say, required.</pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public static void main(final String[] args) {
    MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
    String message = resources.getMessage("argument.required",
        new Object [] {"userDao"}, "Required", Locale.UK);
    System.out.println(message);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun main() {
    val resources = ClassPathXmlApplicationContext("beans.xml")
    val message = resources.getMessage("argument.required",
            arrayOf("userDao"), "Required", Locale.UK)
    println(message)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The resulting output from the running of the above program is as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Ebagum lad, the 'userDao' argument is required, I say, required.</pre>
</div>
</div>
<div class="paragraph">
<p>You can also use the <code>MessageSourceAware</code> interface to acquire a reference to any
<code>MessageSource</code> that has been defined. Any bean that is defined in an
<code>ApplicationContext</code> that implements the <code>MessageSourceAware</code> interface is injected with
the application context&#8217;s <code>MessageSource</code> when the bean is created and configured.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
As an alternative to <code>ResourceBundleMessageSource</code>, Spring provides a
<code>ReloadableResourceBundleMessageSource</code> class. This variant supports the same bundle
file format but is more flexible than the standard JDK based
<code>ResourceBundleMessageSource</code> implementation. In particular, it allows for reading
files from any Spring resource location (not only from the classpath) and supports hot
reloading of bundle property files (while efficiently caching them in between).
See the <a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/context/support/ReloadableResourceBundleMessageSource.html"><code>ReloadableResourceBundleMessageSource</code></a>
javadoc for details.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="context-functionality-events"><a class="anchor" href="#context-functionality-events"></a>1.15.2. Standard and Custom Events</h4>
<div class="paragraph">
<p>Event handling in the <code>ApplicationContext</code> is provided through the <code>ApplicationEvent</code>
class and the <code>ApplicationListener</code> interface. If a bean that implements the
<code>ApplicationListener</code> interface is deployed into the context, every time an
<code>ApplicationEvent</code> gets published to the <code>ApplicationContext</code>, that bean is notified.
Essentially, this is the standard Observer design pattern.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
As of Spring 4.2, the event infrastructure has been significantly improved and offers
an <a href="#context-functionality-events-annotation">annotation-based model</a> as well as the
ability to publish any arbitrary event (that is, an object that does not necessarily
extend from <code>ApplicationEvent</code>). When such an object is published, we wrap it in an
event for you.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following table describes the standard events that Spring provides:</p>
</div>
<table id="beans-ctx-events-tbl" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 7. Built-in Events</caption>
<colgroup>
<col style="width: 30%;">
<col style="width: 70%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Event</th>
<th class="tableblock halign-left valign-top">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContextRefreshedEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Published when the <code>ApplicationContext</code> is initialized or refreshed (for example, by
using the <code>refresh()</code> method on the <code>ConfigurableApplicationContext</code> interface).
Here, &#8220;initialized&#8221; means that all beans are loaded, post-processor beans are detected
and activated, singletons are pre-instantiated, and the <code>ApplicationContext</code> object is
ready for use. As long as the context has not been closed, a refresh can be triggered
multiple times, provided that the chosen <code>ApplicationContext</code> actually supports such
&#8220;hot&#8221; refreshes. For example, <code>XmlWebApplicationContext</code> supports hot refreshes, but
<code>GenericApplicationContext</code> does not.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContextStartedEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Published when the <code>ApplicationContext</code> is started by using the <code>start()</code> method on the
<code>ConfigurableApplicationContext</code> interface. Here, &#8220;started&#8221; means that all <code>Lifecycle</code>
beans receive an explicit start signal. Typically, this signal is used to restart beans
after an explicit stop, but it may also be used to start components that have not been
configured for autostart (for example, components that have not already started on
initialization).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContextStoppedEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Published when the <code>ApplicationContext</code> is stopped by using the <code>stop()</code> method on the
<code>ConfigurableApplicationContext</code> interface. Here, &#8220;stopped&#8221; means that all <code>Lifecycle</code>
beans receive an explicit stop signal. A stopped context may be restarted through a
<code>start()</code> call.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ContextClosedEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Published when the <code>ApplicationContext</code> is being closed by using the <code>close()</code> method
on the <code>ConfigurableApplicationContext</code> interface or via a JVM shutdown hook. Here,
"closed" means that all singleton beans will be destroyed. Once the context is closed,
it reaches its end of life and cannot be refreshed or restarted.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RequestHandledEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A web-specific event telling all beans that an HTTP request has been serviced. This
event is published after the request is complete. This event is only applicable to
web applications that use Spring&#8217;s <code>DispatcherServlet</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServletRequestHandledEvent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A subclass of <code>RequestHandledEvent</code> that adds Servlet-specific context information.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>You can also create and publish your own custom events. The following example shows a
simple class that extends Spring&#8217;s <code>ApplicationEvent</code> base class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class BlockedListEvent extends ApplicationEvent {

    private final String address;
    private final String content;

    public BlockedListEvent(Object source, String address, String content) {
        super(source);
        this.address = address;
        this.content = content;
    }

    // accessor and other methods...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class BlockedListEvent(source: Any,
                    val address: String,
                    val content: String) : ApplicationEvent(source)</code></pre>
</div>
</div>
<div class="paragraph">
<p>To publish a custom <code>ApplicationEvent</code>, call the <code>publishEvent()</code> method on an
<code>ApplicationEventPublisher</code>. Typically, this is done by creating a class that implements
<code>ApplicationEventPublisherAware</code> and registering it as a Spring bean. The following
example shows such a class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class EmailService implements ApplicationEventPublisherAware {

    private List&lt;String&gt; blockedList;
    private ApplicationEventPublisher publisher;

    public void setBlockedList(List&lt;String&gt; blockedList) {
        this.blockedList = blockedList;
    }

    public void setApplicationEventPublisher(ApplicationEventPublisher publisher) {
        this.publisher = publisher;
    }

    public void sendEmail(String address, String content) {
        if (blockedList.contains(address)) {
            publisher.publishEvent(new BlockedListEvent(this, address, content));
            return;
        }
        // send email...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class EmailService : ApplicationEventPublisherAware {

    private lateinit var blockedList: List&lt;String&gt;
    private lateinit var publisher: ApplicationEventPublisher

    fun setBlockedList(blockedList: List&lt;String&gt;) {
        this.blockedList = blockedList
    }

    override fun setApplicationEventPublisher(publisher: ApplicationEventPublisher) {
        this.publisher = publisher
    }

    fun sendEmail(address: String, content: String) {
        if (blockedList!!.contains(address)) {
            publisher!!.publishEvent(BlockedListEvent(this, address, content))
            return
        }
        // send email...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>At configuration time, the Spring container detects that <code>EmailService</code> implements
<code>ApplicationEventPublisherAware</code> and automatically calls
<code>setApplicationEventPublisher()</code>. In reality, the parameter passed in is the Spring
container itself. You are interacting with the application context through its
<code>ApplicationEventPublisher</code> interface.</p>
</div>
<div class="paragraph">
<p>To receive the custom <code>ApplicationEvent</code>, you can create a class that implements
<code>ApplicationListener</code> and register it as a Spring bean. The following example
shows such a class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class BlockedListNotifier implements ApplicationListener&lt;BlockedListEvent&gt; {

    private String notificationAddress;

    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    public void onApplicationEvent(BlockedListEvent event) {
        // notify appropriate parties via notificationAddress...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class BlockedListNotifier : ApplicationListener&lt;BlockedListEvent&gt; {

    lateinit var notificationAddres: String

    override fun onApplicationEvent(event: BlockedListEvent) {
        // notify appropriate parties via notificationAddress...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that <code>ApplicationListener</code> is generically parameterized with the type of your
custom event (<code>BlockedListEvent</code> in the preceding example). This means that the
<code>onApplicationEvent()</code> method can remain type-safe, avoiding any need for downcasting.
You can register as many event listeners as you wish, but note that, by default, event
listeners receive events synchronously. This means that the <code>publishEvent()</code> method
blocks until all listeners have finished processing the event. One advantage of this
synchronous and single-threaded approach is that, when a listener receives an event, it
operates inside the transaction context of the publisher if a transaction context is
available. If another strategy for event publication becomes necessary, see the javadoc
for Spring&#8217;s
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/context/event/ApplicationEventMulticaster.html"><code>ApplicationEventMulticaster</code></a> interface
and <a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/context/event/SimpleApplicationEventMulticaster.html"><code>SimpleApplicationEventMulticaster</code></a>
implementation for configuration options.</p>
</div>
<div class="paragraph">
<p>The following example shows the bean definitions used to register and configure each of
the classes above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="emailService" class="example.EmailService"&gt;
    &lt;property name="blockedList"&gt;
        &lt;list&gt;
            &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="afc4c1c0d8c181dcdfcec2c2caddefcad7cec2dfc3ca81c0ddc8">[email&#160;protected]</a>&lt;/value&gt;
            &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7c1712130b1252141d1f17190e3c19041d110c1019">[email&#160;protected]</a>.org&lt;/value&gt;
            &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d2b8bdbabcfcb6bdb792b7aab3bfa2beb7fcbda0b5">[email&#160;protected]</a>&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="blockedListNotifier" class="example.BlockedListNotifier"&gt;
    &lt;property name="notificationAddress" value="<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="73111f1c101816171f1a000733160b121e031f165d1c0114">[email&#160;protected]</a>"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Putting it all together, when the <code>sendEmail()</code> method of the <code>emailService</code> bean is
called, if there are any email messages that should be blocked, a custom event of type
<code>BlockedListEvent</code> is published. The <code>blockedListNotifier</code> bean is registered as an
<code>ApplicationListener</code> and receives the <code>BlockedListEvent</code>, at which point it can
notify appropriate parties.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring&#8217;s eventing mechanism is designed for simple communication between Spring beans
within the same application context. However, for more sophisticated enterprise
integration needs, the separately maintained
<a href="https://projects.spring.io/spring-integration/">Spring Integration</a> project provides
complete support for building lightweight,
<a href="https://www.enterpriseintegrationpatterns.com">pattern-oriented</a>, event-driven
architectures that build upon the well-known Spring programming model.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="context-functionality-events-annotation"><a class="anchor" href="#context-functionality-events-annotation"></a>Annotation-based Event Listeners</h5>
<div class="paragraph">
<p>You can register an event listener on any method of a managed bean by using the
<code>@EventListener</code> annotation. The <code>BlockedListNotifier</code> can be rewritten as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class BlockedListNotifier {

    private String notificationAddress;

    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    @EventListener
    public void processBlockedListEvent(BlockedListEvent event) {
        // notify appropriate parties via notificationAddress...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class BlockedListNotifier {

    lateinit var notificationAddress: String

    @EventListener
    fun processBlockedListEvent(event: BlockedListEvent) {
        // notify appropriate parties via notificationAddress...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The method signature once again declares the event type to which it listens,
but, this time, with a flexible name and without implementing a specific listener interface.
The event type can also be narrowed through generics as long as the actual event type
resolves your generic parameter in its implementation hierarchy.</p>
</div>
<div class="paragraph">
<p>If your method should listen to several events or if you want to define it with no
parameter at all, the event types can also be specified on the annotation itself. The
following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class})
public void handleContextStart() {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@EventListener(ContextStartedEvent::class, ContextRefreshedEvent::class)
fun handleContextStart() {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to add additional runtime filtering by using the <code>condition</code> attribute
of the annotation that defines a <a href="#expressions"><code>SpEL</code> expression</a> , which should match
to actually invoke the method for a particular event.</p>
</div>
<div class="paragraph">
<p>The following example shows how our notifier can be rewritten to be invoked only if the
<code>content</code> attribute of the event is equal to <code>my-event</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@EventListener(condition = "#blEvent.content == 'my-event'")
public void processBlockedListEvent(BlockedListEvent blEvent) {
    // notify appropriate parties via notificationAddress...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@EventListener(condition = "#blEvent.content == 'my-event'")
fun processBlockedListEvent(blEvent: BlockedListEvent) {
    // notify appropriate parties via notificationAddress...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each <code>SpEL</code> expression evaluates against a dedicated context. The following table lists the
items made available to the context so that you can use them for conditional event processing:</p>
</div>
<table id="context-functionality-events-annotation-tbl" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 8. Event SpEL available metadata</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Location</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Event</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">root object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The actual <code>ApplicationEvent</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#root.event</code> or <code>event</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Arguments array</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">root object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The arguments (as an object array) used to invoke the method.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#root.args</code> or <code>args</code>; <code>args[0]</code> to access the first argument, etc.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Argument name</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">evaluation context</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name of any of the method arguments. If, for some reason, the names are not available
(for example, because there is no debug information in the compiled byte code), individual
arguments are also available using the <code>#a&lt;#arg&gt;</code> syntax where <code>&lt;#arg&gt;</code> stands for the
argument index (starting from 0).</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#blEvent</code> or <code>#a0</code> (you can also use <code>#p0</code> or <code>#p&lt;#arg&gt;</code> parameter notation as an alias)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Note that <code>#root.event</code> gives you access to the underlying event, even if your method
signature actually refers to an arbitrary object that was published.</p>
</div>
<div class="paragraph">
<p>If you need to publish an event as the result of processing another event, you can change the
method signature to return the event that should be published, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@EventListener
public ListUpdateEvent handleBlockedListEvent(BlockedListEvent event) {
    // notify appropriate parties via notificationAddress and
    // then publish a ListUpdateEvent...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@EventListener
fun handleBlockedListEvent(event: BlockedListEvent): ListUpdateEvent {
    // notify appropriate parties via notificationAddress and
    // then publish a ListUpdateEvent...
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This feature is not supported for
<a href="#context-functionality-events-async">asynchronous listeners</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>handleBlockedListEvent()</code> method publishes a new <code>ListUpdateEvent</code> for every
<code>BlockedListEvent</code> that it handles. If you need to publish several events, you can return
a <code>Collection</code> or an array of events instead.</p>
</div>
</div>
<div class="sect4">
<h5 id="context-functionality-events-async"><a class="anchor" href="#context-functionality-events-async"></a>Asynchronous Listeners</h5>
<div class="paragraph">
<p>If you want a particular listener to process events asynchronously, you can reuse the
<a href="integration.html#scheduling-annotation-support-async">regular <code>@Async</code> support</a>.
The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@EventListener
@Async
public void processBlockedListEvent(BlockedListEvent event) {
    // BlockedListEvent is processed in a separate thread
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@EventListener
@Async
fun processBlockedListEvent(event: BlockedListEvent) {
    // BlockedListEvent is processed in a separate thread
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Be aware of the following limitations when using asynchronous events:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If an asynchronous event listener throws an <code>Exception</code>, it is not propagated to the
caller. See <code>AsyncUncaughtExceptionHandler</code> for more details.</p>
</li>
<li>
<p>Asynchronous event listener methods cannot publish a subsequent event by returning a
value. If you need to publish another event as the result of the processing, inject an
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.html"><code>ApplicationEventPublisher</code></a>
to publish the event manually.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="context-functionality-events-order"><a class="anchor" href="#context-functionality-events-order"></a>Ordering Listeners</h5>
<div class="paragraph">
<p>If you need one listener to be invoked before another one, you can add the <code>@Order</code>
annotation to the method declaration, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@EventListener
@Order(42)
public void processBlockedListEvent(BlockedListEvent event) {
    // notify appropriate parties via notificationAddress...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@EventListener
@Order(42)
fun processBlockedListEvent(event: BlockedListEvent) {
    // notify appropriate parties via notificationAddress...
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="context-functionality-events-generics"><a class="anchor" href="#context-functionality-events-generics"></a>Generic Events</h5>
<div class="paragraph">
<p>You can also use generics to further define the structure of your event. Consider using an
<code>EntityCreatedEvent&lt;T&gt;</code> where <code>T</code> is the type of the actual entity that got created. For example, you
can create the following listener definition to receive only <code>EntityCreatedEvent</code> for a
<code>Person</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@EventListener
public void onPersonCreated(EntityCreatedEvent&lt;Person&gt; event) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@EventListener
fun onPersonCreated(event: EntityCreatedEvent&lt;Person&gt;) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Due to type erasure, this works only if the event that is fired resolves the generic
parameters on which the event listener filters (that is, something like
<code>class PersonCreatedEvent extends EntityCreatedEvent&lt;Person&gt; { &#8230;&#8203; }</code>).</p>
</div>
<div class="paragraph">
<p>In certain circumstances, this may become quite tedious if all events follow the same
structure (as should be the case for the event in the preceding example). In such a case,
you can implement <code>ResolvableTypeProvider</code> to guide the framework beyond what the runtime
environment provides. The following event shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class EntityCreatedEvent&lt;T&gt; extends ApplicationEvent implements ResolvableTypeProvider {

    public EntityCreatedEvent(T entity) {
        super(entity);
    }

    @Override
    public ResolvableType getResolvableType() {
        return ResolvableType.forClassWithGenerics(getClass(), ResolvableType.forInstance(getSource()));
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class EntityCreatedEvent&lt;T&gt;(entity: T) : ApplicationEvent(entity), ResolvableTypeProvider {

    override fun getResolvableType(): ResolvableType? {
        return ResolvableType.forClassWithGenerics(javaClass, ResolvableType.forInstance(getSource()))
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
This works not only for <code>ApplicationEvent</code> but any arbitrary object that you send as
an event.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="context-functionality-resources"><a class="anchor" href="#context-functionality-resources"></a>1.15.3. Convenient Access to Low-level Resources</h4>
<div class="paragraph">
<p>For optimal usage and understanding of application contexts, you should familiarize
yourself with Spring&#8217;s <code>Resource</code> abstraction, as described in <a href="#resources">Resources</a>.</p>
</div>
<div class="paragraph">
<p>An application context is a <code>ResourceLoader</code>, which can be used to load <code>Resource</code> objects.
A <code>Resource</code> is essentially a more feature rich version of the JDK <code>java.net.URL</code> class.
In fact, the implementations of the <code>Resource</code> wrap an instance of <code>java.net.URL</code>, where
appropriate. A <code>Resource</code> can obtain low-level resources from almost any location in a
transparent fashion, including from the classpath, a filesystem location, anywhere
describable with a standard URL, and some other variations. If the resource location
string is a simple path without any special prefixes, where those resources come from is
specific and appropriate to the actual application context type.</p>
</div>
<div class="paragraph">
<p>You can configure a bean deployed into the application context to implement the special
callback interface, <code>ResourceLoaderAware</code>, to be automatically called back at
initialization time with the application context itself passed in as the <code>ResourceLoader</code>.
You can also expose properties of type <code>Resource</code>, to be used to access static resources.
They are injected into it like any other properties. You can specify those <code>Resource</code>
properties as simple <code>String</code> paths and rely on automatic conversion from those text
strings to actual <code>Resource</code> objects when the bean is deployed.</p>
</div>
<div class="paragraph">
<p>The location path or paths supplied to an <code>ApplicationContext</code> constructor are actually
resource strings and, in simple form, are treated appropriately according to the specific
context implementation. For example <code>ClassPathXmlApplicationContext</code> treats a simple
location path as a classpath location. You can also use location paths (resource strings)
with special prefixes to force loading of definitions from the classpath or a URL,
regardless of the actual context type.</p>
</div>
</div>
<div class="sect3">
<h4 id="context-functionality-startup"><a class="anchor" href="#context-functionality-startup"></a>1.15.4. Application Startup Tracking</h4>
<div class="paragraph">
<p>The <code>ApplicationContext</code> manages the lifecycle of Spring applications and provides a rich
programming model around components. As a result, complex applications can have equally
complex component graphs and startup phases.</p>
</div>
<div class="paragraph">
<p>Tracking the application startup steps with specific metrics can help understand where
time is being spent during the startup phase, but it can also be used as a way to better
understand the context lifecycle as a whole.</p>
</div>
<div class="paragraph">
<p>The <code>AbstractApplicationContext</code> (and its subclasses) is instrumented with an
<code>ApplicationStartup</code>, which collects <code>StartupStep</code> data about various startup phases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>application context lifecycle (base packages scanning, config classes management)</p>
</li>
<li>
<p>beans lifecycle (instantiation, smart initialization, post processing)</p>
</li>
<li>
<p>application events processing</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here is an example of instrumentation in the <code>AnnotationConfigApplicationContext</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// create a startup step and start recording
StartupStep scanPackages = this.getApplicationStartup().start("spring.context.base-packages.scan");
// add tagging information to the current step
scanPackages.tag("packages", () -&gt; Arrays.toString(basePackages));
// perform the actual phase we're instrumenting
this.scanner.scan(basePackages);
// end the current step
scanPackages.end();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// create a startup step and start recording
val scanPackages = this.getApplicationStartup().start("spring.context.base-packages.scan")
// add tagging information to the current step
scanPackages.tag("packages", () -&gt; Arrays.toString(basePackages))
// perform the actual phase we're instrumenting
this.scanner.scan(basePackages)
// end the current step
scanPackages.end()</code></pre>
</div>
</div>
<div class="paragraph">
<p>The application context is already instrumented with multiple steps.
Once recorded, these startup steps can be collected, displayed and analyzed with specific tools.
For a complete list of existing startup steps, you can check out the
<a href="#application-startup-steps">dedicated appendix section</a>.</p>
</div>
<div class="paragraph">
<p>The default <code>ApplicationStartup</code> implementation is a no-op variant, for minimal overhead.
This means no metrics will be collected during application startup by default.
Spring Framework ships with an implementation for tracking startup steps with Java Flight Recorder:
<code>FlightRecorderApplicationStartup</code>. To use this variant, you must configure an instance of it
to the <code>ApplicationContext</code> as soon as it&#8217;s been created.</p>
</div>
<div class="paragraph">
<p>Developers can also use the <code>ApplicationStartup</code> infrastructure if they&#8217;re providing their own
<code>AbstractApplicationContext</code> subclass, or if they wish to collect more precise data.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<code>ApplicationStartup</code> is meant to be only used during application startup and for
the core container; this is by no means a replacement for Java profilers or
metrics libraries like <a href="https://micrometer.io">Micrometer</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To start collecting custom <code>StartupStep</code>, components can either get the <code>ApplicationStartup</code>
instance from the application context directly, make their component implement <code>ApplicationStartupAware</code>,
or ask for the <code>ApplicationStartup</code> type on any injection point.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Developers should not use the <code>"spring.*"</code> namespace when creating custom startup steps.
This namespace is reserved for internal Spring usage and is subject to change.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="context-create"><a class="anchor" href="#context-create"></a>1.15.5. Convenient ApplicationContext Instantiation for Web Applications</h4>
<div class="paragraph">
<p>You can create <code>ApplicationContext</code> instances declaratively by using, for example, a
<code>ContextLoader</code>. Of course, you can also create <code>ApplicationContext</code> instances
programmatically by using one of the <code>ApplicationContext</code> implementations.</p>
</div>
<div class="paragraph">
<p>You can register an <code>ApplicationContext</code> by using the <code>ContextLoaderListener</code>, as the
following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The listener inspects the <code>contextConfigLocation</code> parameter. If the parameter does not
exist, the listener uses <code>/WEB-INF/applicationContext.xml</code> as a default. When the
parameter does exist, the listener separates the <code>String</code> by using predefined
delimiters (comma, semicolon, and whitespace) and uses the values as locations where
application contexts are searched. Ant-style path patterns are supported as well.
Examples are <code>/WEB-INF/*Context.xml</code> (for all files with names that end with
<code>Context.xml</code> and that reside in the <code>WEB-INF</code> directory) and <code>/WEB-INF/**/*Context.xml</code>
(for all such files in any subdirectory of <code>WEB-INF</code>).</p>
</div>
</div>
<div class="sect3">
<h4 id="context-deploy-rar"><a class="anchor" href="#context-deploy-rar"></a>1.15.6. Deploying a Spring <code>ApplicationContext</code> as a Java EE RAR File</h4>
<div class="paragraph">
<p>It is possible to deploy a Spring <code>ApplicationContext</code> as a RAR file, encapsulating the
context and all of its required bean classes and library JARs in a Java EE RAR deployment
unit. This is the equivalent of bootstrapping a stand-alone <code>ApplicationContext</code> (only hosted
in Java EE environment) being able to access the Java EE servers facilities. RAR deployment
is a more natural alternative to a scenario of deploying a headless WAR file&#8201;&#8212;&#8201;in effect,
a WAR file without any HTTP entry points that is used only for bootstrapping a Spring
<code>ApplicationContext</code> in a Java EE environment.</p>
</div>
<div class="paragraph">
<p>RAR deployment is ideal for application contexts that do not need HTTP entry points but
rather consist only of message endpoints and scheduled jobs. Beans in such a context can
use application server resources such as the JTA transaction manager and JNDI-bound JDBC
<code>DataSource</code> instances and JMS <code>ConnectionFactory</code> instances and can also register with
the platform&#8217;s JMX server&#8201;&#8212;&#8201;all through Spring&#8217;s standard transaction management and JNDI
and JMX support facilities. Application components can also interact with the application
server&#8217;s JCA <code>WorkManager</code> through Spring&#8217;s <code>TaskExecutor</code> abstraction.</p>
</div>
<div class="paragraph">
<p>See the javadoc of the
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html"><code>SpringContextResourceAdapter</code></a>
class for the configuration details involved in RAR deployment.</p>
</div>
<div class="paragraph">
<p>For a simple deployment of a Spring ApplicationContext as a Java EE RAR file:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Package
all application classes into a RAR file (which is a standard JAR file with a different
file extension).
.Add all required library JARs into the root of the RAR archive.
.Add a
<code>META-INF/ra.xml</code> deployment descriptor (as shown in the <a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/jca/context/SpringContextResourceAdapter.html">javadoc for <code>SpringContextResourceAdapter</code></a>)
and the corresponding Spring XML bean definition file(s) (typically
<code>META-INF/applicationContext.xml</code>).</p>
</li>
<li>
<p>Drop the resulting RAR file into your
application server&#8217;s deployment directory.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Such RAR deployment units are usually self-contained. They do not expose components
to the outside world, not even to other modules of the same application. Interaction with a
RAR-based <code>ApplicationContext</code> usually occurs through JMS destinations that it shares with
other modules. A RAR-based <code>ApplicationContext</code> may also, for example, schedule some jobs
or react to new files in the file system (or the like). If it needs to allow synchronous
access from the outside, it could (for example) export RMI endpoints, which may be used
by other application modules on the same machine.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="beans-beanfactory"><a class="anchor" href="#beans-beanfactory"></a>1.16. The <code>BeanFactory</code></h3>
<div class="paragraph">
<p>The <code>BeanFactory</code> API provides the underlying basis for Spring&#8217;s IoC functionality.
Its specific contracts are mostly used in integration with other parts of Spring and
related third-party frameworks, and its <code>DefaultListableBeanFactory</code> implementation
is a key delegate within the higher-level <code>GenericApplicationContext</code> container.</p>
</div>
<div class="paragraph">
<p><code>BeanFactory</code> and related interfaces (such as <code>BeanFactoryAware</code>, <code>InitializingBean</code>,
<code>DisposableBean</code>) are important integration points for other framework components.
By not requiring any annotations or even reflection, they allow for very efficient
interaction between the container and its components. Application-level beans may
use the same callback interfaces but typically prefer declarative dependency
injection instead, either through annotations or through programmatic configuration.</p>
</div>
<div class="paragraph">
<p>Note that the core <code>BeanFactory</code> API level and its <code>DefaultListableBeanFactory</code>
implementation do not make assumptions about the configuration format or any
component annotations to be used. All of these flavors come in through extensions
(such as <code>XmlBeanDefinitionReader</code> and <code>AutowiredAnnotationBeanPostProcessor</code>) and
operate on shared <code>BeanDefinition</code> objects as a core metadata representation.
This is the essence of what makes Spring&#8217;s container so flexible and extensible.</p>
</div>
<div class="sect3">
<h4 id="context-introduction-ctx-vs-beanfactory"><a class="anchor" href="#context-introduction-ctx-vs-beanfactory"></a>1.16.1. <code>BeanFactory</code> or <code>ApplicationContext</code>?</h4>
<div class="paragraph">
<p>This section explains the differences between the <code>BeanFactory</code> and
<code>ApplicationContext</code> container levels and the implications on bootstrapping.</p>
</div>
<div class="paragraph">
<p>You should use an <code>ApplicationContext</code> unless you have a good reason for not doing so, with
<code>GenericApplicationContext</code> and its subclass <code>AnnotationConfigApplicationContext</code>
as the common implementations for custom bootstrapping. These are the primary entry
points to Spring&#8217;s core container for all common purposes: loading of configuration
files, triggering a classpath scan, programmatically registering bean definitions
and annotated classes, and (as of 5.0) registering functional bean definitions.</p>
</div>
<div class="paragraph">
<p>Because an <code>ApplicationContext</code> includes all the functionality of a <code>BeanFactory</code>, it is
generally recommended over a plain <code>BeanFactory</code>, except for scenarios where full
control over bean processing is needed. Within an <code>ApplicationContext</code> (such as the
<code>GenericApplicationContext</code> implementation), several kinds of beans are detected
by convention (that is, by bean name or by bean type&#8201;&#8212;&#8201;in particular, post-processors),
while a plain <code>DefaultListableBeanFactory</code> is agnostic about any special beans.</p>
</div>
<div class="paragraph">
<p>For many extended container features, such as annotation processing and AOP proxying,
the <a href="#beans-factory-extension-bpp"><code>BeanPostProcessor</code> extension point</a> is essential.
If you use only a plain <code>DefaultListableBeanFactory</code>, such post-processors do not
get detected and activated by default. This situation could be confusing, because
nothing is actually wrong with your bean configuration. Rather, in such a scenario,
the container needs to be fully bootstrapped through additional setup.</p>
</div>
<div class="paragraph">
<p>The following table lists features provided by the <code>BeanFactory</code> and
<code>ApplicationContext</code> interfaces and implementations.</p>
</div>
<table id="context-introduction-ctx-vs-beanfactory-feature-matrix" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 9. Feature Matrix</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Feature</th>
<th class="tableblock halign-left valign-top"><code>BeanFactory</code></th>
<th class="tableblock halign-left valign-top"><code>ApplicationContext</code></th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bean instantiation/wiring</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integrated lifecycle management</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Automatic <code>BeanPostProcessor</code> registration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Automatic <code>BeanFactoryPostProcessor</code> registration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Convenient <code>MessageSource</code> access (for internalization)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Built-in <code>ApplicationEvent</code> publication mechanism</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>To explicitly register a bean post-processor with a <code>DefaultListableBeanFactory</code>,
you need to programmatically call <code>addBeanPostProcessor</code>, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
// populate the factory with bean definitions

// now register any needed BeanPostProcessor instances
factory.addBeanPostProcessor(new AutowiredAnnotationBeanPostProcessor());
factory.addBeanPostProcessor(new MyBeanPostProcessor());

// now start using the factory</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val factory = DefaultListableBeanFactory()
// populate the factory with bean definitions

// now register any needed BeanPostProcessor instances
factory.addBeanPostProcessor(AutowiredAnnotationBeanPostProcessor())
factory.addBeanPostProcessor(MyBeanPostProcessor())

// now start using the factory</code></pre>
</div>
</div>
<div class="paragraph">
<p>To apply a <code>BeanFactoryPostProcessor</code> to a plain <code>DefaultListableBeanFactory</code>,
you need to call its <code>postProcessBeanFactory</code> method, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);
reader.loadBeanDefinitions(new FileSystemResource("beans.xml"));

// bring in some property values from a Properties file
PropertySourcesPlaceholderConfigurer cfg = new PropertySourcesPlaceholderConfigurer();
cfg.setLocation(new FileSystemResource("jdbc.properties"));

// now actually do the replacement
cfg.postProcessBeanFactory(factory);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val factory = DefaultListableBeanFactory()
val reader = XmlBeanDefinitionReader(factory)
reader.loadBeanDefinitions(FileSystemResource("beans.xml"))

// bring in some property values from a Properties file
val cfg = PropertySourcesPlaceholderConfigurer()
cfg.setLocation(FileSystemResource("jdbc.properties"))

// now actually do the replacement
cfg.postProcessBeanFactory(factory)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In both cases, the explicit registration steps are inconvenient, which is
why the various <code>ApplicationContext</code> variants are preferred over a plain
<code>DefaultListableBeanFactory</code> in Spring-backed applications, especially when
relying on <code>BeanFactoryPostProcessor</code> and <code>BeanPostProcessor</code> instances for extended
container functionality in a typical enterprise setup.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>An <code>AnnotationConfigApplicationContext</code> has all common annotation post-processors
registered and may bring in additional processors underneath the
covers through configuration annotations, such as <code>@EnableTransactionManagement</code>.
At the abstraction level of Spring&#8217;s annotation-based configuration model,
the notion of bean post-processors becomes a mere internal container detail.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
    <h2 id="resources"><a class="anchor" href="#resources"></a>2. Resources<div class="translate">（资源）</div></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter covers how Spring handles resources and how you can work with resources in
Spring. It includes the following topics:
<div class="translate">
本章将介绍Spring如何处理资源，以及如何使用Spring中的资源。它包括以下主题:
</div>
</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#resources-introduction">Introduction</a></p>
</li>
<li>
<p><a href="#resources-resource">The <code>Resource</code> Interface</a></p>
</li>
<li>
<p><a href="#resources-implementations">Built-in <code>Resource</code> Implementations</a></p>
</li>
<li>
<p><a href="#resources-resourceloader">The <code>ResourceLoader</code> Interface</a></p>
</li>
<li>
<p><a href="#resources-resourcepatternresolver">The <code>ResourcePatternResolver</code> Interface</a></p>
</li>
<li>
<p><a href="#resources-resourceloaderaware">The <code>ResourceLoaderAware</code> Interface</a></p>
</li>
<li>
<p><a href="#resources-as-dependencies">Resources as Dependencies</a></p>
</li>
<li>
<p><a href="#resources-app-ctx">Application Contexts and Resource Paths</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="resources-introduction"><a class="anchor" href="#resources-introduction"></a>2.1. Introduction<div class="translate">（简介）</div></h3>
<div class="paragraph">
<p>Java&#8217;s standard <code>java.net.URL</code> class and standard handlers for various URL prefixes,
unfortunately, are not quite adequate enough for all access to low-level resources. For
example, there is no standardized <code>URL</code> implementation that may be used to access a
resource that needs to be obtained from the classpath or relative to a
<code>ServletContext</code>. While it is possible to register new handlers for specialized <code>URL</code>
prefixes (similar to existing handlers for prefixes such as <code>http:</code>), this is generally
quite complicated, and the <code>URL</code> interface still lacks some desirable functionality,
such as a method to check for the existence of the resource being pointed to.
<div class="translate">
遗憾的是，仅仅靠Java的标准java.net.URL类和用于各种URL前缀的标准处理程序，并不能完全满足对所有底层资源的访问。例如，目前没有一个标准化的URL实现可以用来从类路径或者相对ServletContext中获取资源。
虽然可以为专门的URL前缀注册新的处理程序(类似于现有的前缀处理程序，如http:)，但是这通常相当复杂，而且URL接口仍然缺乏一些理想的功能，例如检查所指定资源是否存在的方法。
</div>
</p>
</div>
</div>
<div class="sect2">
<h3 id="resources-resource"><a class="anchor" href="#resources-resource"></a>2.2. The <code>Resource</code> Interface<div class="translate">（Resource接口）</div></h3>
<div class="paragraph">
<p>Spring&#8217;s <code>Resource</code> interface located in the <code>org.springframework.core.io.</code> package is
meant to be a more capable interface for abstracting access to low-level resources. The
following listing provides an overview of the <code>Resource</code> interface. See the
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/core/io/Resource.html"><code>Resource</code></a> javadoc for further details.
<div class="translate">
Spring的Resource接口位于org.springframework.core.io.包中，一个用于抽象对底层资源访问的更强大的接口。下面的清单提供了Resource接口的概述。更多细节请参见参考Resource的javadoc。
</div>
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface Resource extends InputStreamSource {

    boolean exists();

    boolean isReadable();

    boolean isOpen();

    boolean isFile();

    URL getURL() throws IOException;

    URI getURI() throws IOException;

    File getFile() throws IOException;

    ReadableByteChannel readableChannel() throws IOException;

    long contentLength() throws IOException;

    long lastModified() throws IOException;

    Resource createRelative(String relativePath) throws IOException;

    String getFilename();

    String getDescription();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As the definition of the <code>Resource</code> interface shows, it extends the <code>InputStreamSource</code>
interface. The following listing shows the definition of the <code>InputStreamSource</code>
interface:
<div class="translate">
正如Resource接口的定义所示，它扩展了InputStreamSource接口。下面的清单显示了InputStreamSource接口的定义:
</div>
</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface InputStreamSource {

    InputStream getInputStream() throws IOException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some of the most important methods from the <code>Resource</code> interface are:</p>
<div class="translate">
    Resource接口的一些十分重要的方法如下:
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getInputStream()</code>: Locates and opens the resource, returning an <code>InputStream</code> for
reading from the resource. It is expected that each invocation returns a fresh
<code>InputStream</code>. It is the responsibility of the caller to close the stream.
    <div class="translate">
    getInputStream():定位并打开资源，返回一个从资源读取的InputStream。期望每次调用返回一个新的InputStream。调用者的责任是关闭流。
</div>
</p>
</li>
<li>
<p><code>exists()</code>: Returns a <code>boolean</code> indicating whether this resource actually exists in
physical form.
    <div class="translate">
    exists():返回一个boolean，指示该资源是否以物理形态存在。
</div>
</p>
</li>
<li>
<p><code>isOpen()</code>: Returns a <code>boolean</code> indicating whether this resource represents a handle
with an open stream. If <code>true</code>, the <code>InputStream</code> cannot be read multiple times and
must be read once only and then closed to avoid resource leaks. Returns <code>false</code> for
all usual resource implementations, with the exception of <code>InputStreamResource</code>.
    <div class="translate">
    isOpen():返回一个boolean，指示该资源是否代表一个打开流的句柄。如果为true，则不能多次读取InputStream，必须只读取一次，然后关闭以避免资源泄漏。对于所有通常的资源实现返回false，除了InputStreamResource。
</div>
</p>
</li>
<li>
<p><code>getDescription()</code>: Returns a description for this resource, to be used for error
output when working with the resource. This is often the fully qualified file name or
the actual URL of the resource.
    <div class="translate">
    getDescription():返回此资源的描述，用于处理该资源时的错误输出。这通常是完全限定的文件名或资源的实际URL。
</div>
</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other methods let you obtain an actual <code>URL</code> or <code>File</code> object representing the
resource (if the underlying implementation is compatible and supports that
functionality).
    <div class="translate">
    其他方法让您获得表示资源的实际URL或File对象(如果底层实现是兼容的并支持该功能的话)。
    </div>
</p>
</div>
<div class="paragraph">
<p>Some implementations of the <code>Resource</code> interface also implement the extended
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/core/io/WritableResource.html"><code>WritableResource</code></a> interface
for a resource that supports writing to it.
    <div class="translate">
    Resource接口的一些实现还为了支持向其写入的资源而实现了扩展的WritableResource接口。
    </div>
</p>
</div>
<div class="paragraph">
<p>Spring itself uses the <code>Resource</code> abstraction extensively, as an argument type in
many method signatures when a resource is needed. Other methods in some Spring APIs
(such as the constructors to various <code>ApplicationContext</code> implementations) take a
<code>String</code> which in unadorned or simple form is used to create a <code>Resource</code> appropriate to
that context implementation or, via special prefixes on the <code>String</code> path, let the
caller specify that a specific <code>Resource</code> implementation must be created and used.
    <div class="translate">
    Spring本身广泛地使用Resource抽象，当需要资源时，它作为许多方法签名中的参数类型。
    一些Spring APIs里的其他方法(比如各种ApplicationContext实现的构造函数)采用一个String，
    它以简单的形式用于创建适合该上下文实现的资源，或者通过String路径上的特殊前缀，让调用者指定必须创建和使用特定的资源实现。
    </div>
</p>
</div>
<div class="paragraph">
<p>While the <code>Resource</code> interface is used a lot with Spring and by Spring, it is actually
very convenient to use as a general utility class by itself in your own code, for access
to resources, even when your code does not know or care about any other parts of Spring.
While this couples your code to Spring, it really only couples it to this small set of
utility classes, which serves as a more capable replacement for <code>URL</code> and can be
considered equivalent to any other library you would use for this purpose.
    <div class="translate">
    虽然Resource接口在Spring中经常和Spring一起使用了，实际上，在您自己的代码中使用它作为访问资源的通用工具类也是非常方便的，即使您的代码不知道或不关心Spring的任何其他部分。
    虽然这将您的代码与Spring耦合在一起，但实际上它只是将代码与这一小组工具类耦合在一起，这些工具类可以作为URL的更有力的替代，可以认为等同于您将为此目的而使用的任何其他库。
    </div>
</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>Resource</code> abstraction does not replace functionality. It wraps it where
possible. For example, a <code>UrlResource</code> wraps a URL and uses the wrapped <code>URL</code> to do its
work.
    <div class="translate">
        Resource抽象并没有替换功能。而是尽可能地包装它。例如，UrlResource包装一个URL并使用包装后的URL来完成它的工作。
    </div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
    <h3 id="resources-implementations"><a class="anchor" href="#resources-implementations"></a>2.3. Built-in <code>Resource</code> Implementations<div class="translate">（内置的Resource实现）</div></h3>
<div class="paragraph">
<p>Spring includes several built-in <code>Resource</code> implementations:
    <div class="translate">
    Spring包括的几个内置的Resource实现:
    </div>
</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#resources-implementations-urlresource"><code>UrlResource</code></a></p>
</li>
<li>
<p><a href="#resources-implementations-classpathresource"><code>ClassPathResource</code></a></p>
</li>
<li>
<p><a href="#resources-implementations-filesystemresource"><code>FileSystemResource</code></a></p>
</li>
<li>
<p><a href="#resources-implementations-pathresource"><code>PathResource</code></a></p>
</li>
<li>
<p><a href="#resources-implementations-servletcontextresource"><code>ServletContextResource</code></a></p>
</li>
<li>
<p><a href="#resources-implementations-inputstreamresource"><code>InputStreamResource</code></a></p>
</li>
<li>
<p><a href="#resources-implementations-bytearrayresource"><code>ByteArrayResource</code></a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For a complete list of <code>Resource</code> implementations available in Spring, consult the
"All Known Implementing Classes" section of the
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/core/io/Resource.html"><code>Resource</code></a> javadoc.</p>
</div>
<div class="sect3">
<h4 id="resources-implementations-urlresource"><a class="anchor" href="#resources-implementations-urlresource"></a>2.3.1. <code>UrlResource</code></h4>
<div class="paragraph">
<p><code>UrlResource</code> wraps a <code>java.net.URL</code> and can be used to access any object that is
normally accessible with a URL, such as files, an HTTPS target, an FTP target, and
others. All URLs have a standardized <code>String</code> representation, such that appropriate
standardized prefixes are used to indicate one URL type from another. This includes
<code>file:</code> for accessing filesystem paths, <code>https:</code> for accessing resources through the
HTTPS protocol, <code>ftp:</code> for accessing resources through FTP, and others.</p>
</div>
<div class="paragraph">
<p>A <code>UrlResource</code> is created by Java code by explicitly using the <code>UrlResource</code> constructor
but is often created implicitly when you call an API method that takes a <code>String</code>
argument meant to represent a path. For the latter case, a JavaBeans <code>PropertyEditor</code>
ultimately decides which type of <code>Resource</code> to create. If the path string contains a
well-known (to property editor, that is) prefix (such as <code>classpath:</code>), it creates an
appropriate specialized <code>Resource</code> for that prefix. However, if it does not recognize the
prefix, it assumes the string is a standard URL string and creates a <code>UrlResource</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-classpathresource"><a class="anchor" href="#resources-implementations-classpathresource"></a>2.3.2. <code>ClassPathResource</code></h4>
<div class="paragraph">
<p>This class represents a resource that should be obtained from the classpath. It uses
either the thread context class loader, a given class loader, or a given class for
loading resources.</p>
</div>
<div class="paragraph">
<p>This <code>Resource</code> implementation supports resolution as a <code>java.io.File</code> if the class path
resource resides in the file system but not for classpath resources that reside in a
jar and have not been expanded (by the servlet engine or whatever the environment is)
to the filesystem. To address this, the various <code>Resource</code> implementations always support
resolution as a <code>java.net.URL</code>.</p>
</div>
<div class="paragraph">
<p>A <code>ClassPathResource</code> is created by Java code by explicitly using the <code>ClassPathResource</code>
constructor but is often created implicitly when you call an API method that takes a
<code>String</code> argument meant to represent a path. For the latter case, a JavaBeans
<code>PropertyEditor</code> recognizes the special prefix, <code>classpath:</code>, on the string path and
creates a <code>ClassPathResource</code> in that case.</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-filesystemresource"><a class="anchor" href="#resources-implementations-filesystemresource"></a>2.3.3. <code>FileSystemResource</code></h4>
<div class="paragraph">
<p>This is a <code>Resource</code> implementation for <code>java.io.File</code> handles. It also supports
<code>java.nio.file.Path</code> handles, applying Spring&#8217;s standard String-based path
transformations but performing all operations via the <code>java.nio.file.Files</code> API. For pure
<code>java.nio.path.Path</code> based support use a <code>PathResource</code> instead. <code>FileSystemResource</code>
supports resolution as a <code>File</code> and as a <code>URL</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-pathresource"><a class="anchor" href="#resources-implementations-pathresource"></a>2.3.4. <code>PathResource</code></h4>
<div class="paragraph">
<p>This is a <code>Resource</code> implementation for <code>java.nio.file.Path</code> handles, performing all
operations and transformations via the <code>Path</code> API. It supports resolution as a <code>File</code> and
as a <code>URL</code> and also implements the extended <code>WritableResource</code> interface. <code>PathResource</code>
is effectively a pure <code>java.nio.path.Path</code> based alternative to <code>FileSystemResource</code> with
different <code>createRelative</code> behavior.</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-servletcontextresource"><a class="anchor" href="#resources-implementations-servletcontextresource"></a>2.3.5. <code>ServletContextResource</code></h4>
<div class="paragraph">
<p>This is a <code>Resource</code> implementation for <code>ServletContext</code> resources that interprets
relative paths within the relevant web application&#8217;s root directory.</p>
</div>
<div class="paragraph">
<p>It always supports stream access and URL access but allows <code>java.io.File</code> access only
when the web application archive is expanded and the resource is physically on the
filesystem. Whether or not it is expanded and on the filesystem or accessed
directly from the JAR or somewhere else like a database (which is conceivable) is actually
dependent on the Servlet container.</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-inputstreamresource"><a class="anchor" href="#resources-implementations-inputstreamresource"></a>2.3.6. <code>InputStreamResource</code></h4>
<div class="paragraph">
<p>An <code>InputStreamResource</code> is a <code>Resource</code> implementation for a given <code>InputStream</code>. It
should be used only if no specific <code>Resource</code> implementation is applicable. In
particular, prefer <code>ByteArrayResource</code> or any of the file-based <code>Resource</code>
implementations where possible.</p>
</div>
<div class="paragraph">
<p>In contrast to other <code>Resource</code> implementations, this is a descriptor for an
already-opened resource. Therefore, it returns <code>true</code> from <code>isOpen()</code>. Do not use it if
you need to keep the resource descriptor somewhere or if you need to read a stream
multiple times.</p>
</div>
</div>
<div class="sect3">
<h4 id="resources-implementations-bytearrayresource"><a class="anchor" href="#resources-implementations-bytearrayresource"></a>2.3.7. <code>ByteArrayResource</code></h4>
<div class="paragraph">
<p>This is a <code>Resource</code> implementation for a given byte array. It creates a
<code>ByteArrayInputStream</code> for the given byte array.</p>
</div>
<div class="paragraph">
<p>It is useful for loading content from any given byte array without having to resort to a
single-use <code>InputStreamResource</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="resources-resourceloader"><a class="anchor" href="#resources-resourceloader"></a>2.4. The <code>ResourceLoader</code> Interface</h3>
<div class="paragraph">
<p>The <code>ResourceLoader</code> interface is meant to be implemented by objects that can return
(that is, load) <code>Resource</code> instances. The following listing shows the <code>ResourceLoader</code>
interface definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface ResourceLoader {

    Resource getResource(String location);

    ClassLoader getClassLoader();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>All application contexts implement the <code>ResourceLoader</code> interface. Therefore, all
application contexts may be used to obtain <code>Resource</code> instances.</p>
</div>
<div class="paragraph">
<p>When you call <code>getResource()</code> on a specific application context, and the location path
specified doesn&#8217;t have a specific prefix, you get back a <code>Resource</code> type that is
appropriate to that particular application context. For example, assume the following
snippet of code was run against a <code>ClassPathXmlApplicationContext</code> instance:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Resource template = ctx.getResource("some/resource/path/myTemplate.txt");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val template = ctx.getResource("some/resource/path/myTemplate.txt")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Against a <code>ClassPathXmlApplicationContext</code>, that code returns a <code>ClassPathResource</code>. If
the same method were run against a <code>FileSystemXmlApplicationContext</code> instance, it would
return a <code>FileSystemResource</code>. For a <code>WebApplicationContext</code>, it would return a
<code>ServletContextResource</code>. It would similarly return appropriate objects for each context.</p>
</div>
<div class="paragraph">
<p>As a result, you can load resources in a fashion appropriate to the particular application
context.</p>
</div>
<div class="paragraph">
<p>On the other hand, you may also force <code>ClassPathResource</code> to be used, regardless of the
application context type, by specifying the special <code>classpath:</code> prefix, as the following
example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Resource template = ctx.getResource("classpath:some/resource/path/myTemplate.txt");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val template = ctx.getResource("classpath:some/resource/path/myTemplate.txt")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, you can force a <code>UrlResource</code> to be used by specifying any of the standard
<code>java.net.URL</code> prefixes. The following examples use the <code>file</code> and <code>https</code> prefixes:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Resource template = ctx.getResource("file:///some/resource/path/myTemplate.txt");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val template = ctx.getResource("file:///some/resource/path/myTemplate.txt")</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Resource template = ctx.getResource("https://myhost.com/resource/path/myTemplate.txt");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val template = ctx.getResource("https://myhost.com/resource/path/myTemplate.txt")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following table summarizes the strategy for converting <code>String</code> objects to <code>Resource</code>
objects:</p>
</div>
<table id="resources-resource-strings" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 10. Resource strings</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Prefix</th>
<th class="tableblock halign-left valign-top">Example</th>
<th class="tableblock halign-left valign-top">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">classpath:</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>classpath:com/myapp/config.xml</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Loaded from the classpath.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">file:</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>file:///data/config.xml</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Loaded as a <code>URL</code> from the filesystem. See also <a href="#resources-filesystemresource-caveats"><code>FileSystemResource</code> Caveats</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">https:</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>https://myserver/logo.png</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Loaded as a <code>URL</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">(none)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/data/config.xml</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Depends on the underlying <code>ApplicationContext</code>.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="resources-resourcepatternresolver"><a class="anchor" href="#resources-resourcepatternresolver"></a>2.5. The <code>ResourcePatternResolver</code> Interface</h3>
<div class="paragraph">
<p>The <code>ResourcePatternResolver</code> interface is an extension to the <code>ResourceLoader</code> interface
which defines a strategy for resolving a location pattern (for example, an Ant-style path
pattern) into <code>Resource</code> objects.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface ResourcePatternResolver extends ResourceLoader {

    String CLASSPATH_ALL_URL_PREFIX = "classpath*:";

    Resource[] getResources(String locationPattern) throws IOException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As can be seen above, this interface also defines a special <code>classpath*:</code> resource prefix
for all matching resources from the class path. Note that the resource location is
expected to be a path without placeholders in this case&#8201;&#8212;&#8201;for example,
<code>classpath*:/config/beans.xml</code>. JAR files or different directories in the class path can
contain multiple files with the same path and the same name. See
<a href="#resources-app-ctx-wildcards-in-resource-paths">Wildcards in Application Context Constructor Resource Paths</a> and its subsections for further details
on wildcard support with the <code>classpath*:</code> resource prefix.</p>
</div>
<div class="paragraph">
<p>A passed-in <code>ResourceLoader</code> (for example, one supplied via
<a href="#resources-resourceloaderaware"><code>ResourceLoaderAware</code></a> semantics) can be checked whether
it implements this extended interface too.</p>
</div>
<div class="paragraph">
<p><code>PathMatchingResourcePatternResolver</code> is a standalone implementation that is usable
outside an <code>ApplicationContext</code> and is also used by <code>ResourceArrayPropertyEditor</code> for
populating <code>Resource[]</code> bean properties. <code>PathMatchingResourcePatternResolver</code> is able to
resolve a specified resource location path into one or more matching <code>Resource</code> objects.
The source path may be a simple path which has a one-to-one mapping to a target
<code>Resource</code>, or alternatively may contain the special <code>classpath*:</code> prefix and/or internal
Ant-style regular expressions (matched using Spring&#8217;s
<code>org.springframework.util.AntPathMatcher</code> utility). Both of the latter are effectively
wildcards.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The default <code>ResourceLoader</code> in any standard <code>ApplicationContext</code> is in fact an instance
of <code>PathMatchingResourcePatternResolver</code> which implements the <code>ResourcePatternResolver</code>
interface. The same is true for the <code>ApplicationContext</code> instance itself which also
implements the <code>ResourcePatternResolver</code> interface and delegates to the default
<code>PathMatchingResourcePatternResolver</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="resources-resourceloaderaware"><a class="anchor" href="#resources-resourceloaderaware"></a>2.6. The <code>ResourceLoaderAware</code> Interface</h3>
<div class="paragraph">
<p>The <code>ResourceLoaderAware</code> interface is a special callback interface which identifies
components that expect to be provided a <code>ResourceLoader</code> reference. The following listing
shows the definition of the <code>ResourceLoaderAware</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface ResourceLoaderAware {

    void setResourceLoader(ResourceLoader resourceLoader);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When a class implements <code>ResourceLoaderAware</code> and is deployed into an application context
(as a Spring-managed bean), it is recognized as <code>ResourceLoaderAware</code> by the application
context. The application context then invokes <code>setResourceLoader(ResourceLoader)</code>,
supplying itself as the argument (remember, all application contexts in Spring implement
the <code>ResourceLoader</code> interface).</p>
</div>
<div class="paragraph">
<p>Since an <code>ApplicationContext</code> is a <code>ResourceLoader</code>, the bean could also implement the
<code>ApplicationContextAware</code> interface and use the supplied application context directly to
load resources. However, in general, it is better to use the specialized <code>ResourceLoader</code>
interface if that is all you need. The code would be coupled only to the resource loading
interface (which can be considered a utility interface) and not to the whole Spring
<code>ApplicationContext</code> interface.</p>
</div>
<div class="paragraph">
<p>In application components, you may also rely upon autowiring of the <code>ResourceLoader</code> as
an alternative to implementing the <code>ResourceLoaderAware</code> interface. The <em>traditional</em>
<code>constructor</code> and <code>byType</code> autowiring modes (as described in <a href="#beans-factory-autowire">Autowiring Collaborators</a>)
are capable of providing a <code>ResourceLoader</code> for either a constructor argument or a
setter method parameter, respectively. For more flexibility (including the ability to
autowire fields and multiple parameter methods), consider using the annotation-based
autowiring features. In that case, the <code>ResourceLoader</code> is autowired into a field,
constructor argument, or method parameter that expects the <code>ResourceLoader</code> type as long
as the field, constructor, or method in question carries the <code>@Autowired</code> annotation.
For more information, see <a href="#beans-autowired-annotation">Using <code>@Autowired</code></a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To load one or more <code>Resource</code> objects for a resource path that contains wildcards
or makes use of the special <code>classpath*:</code> resource prefix, consider having an instance of
<a href="#resources-resourcepatternresolver"><code>ResourcePatternResolver</code></a> autowired into your
application components instead of <code>ResourceLoader</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="resources-as-dependencies"><a class="anchor" href="#resources-as-dependencies"></a>2.7. Resources as Dependencies</h3>
<div class="paragraph">
<p>If the bean itself is going to determine and supply the resource path through some sort
of dynamic process, it probably makes sense for the bean to use the <code>ResourceLoader</code> or
<code>ResourcePatternResolver</code> interface to load resources. For example, consider the loading
of a template of some sort, where the specific resource that is needed depends on the
role of the user. If the resources are static, it makes sense to eliminate the use of the
<code>ResourceLoader</code> interface (or <code>ResourcePatternResolver</code> interface) completely, have the
bean expose the <code>Resource</code> properties it needs, and expect them to be injected into it.</p>
</div>
<div class="paragraph">
<p>What makes it trivial to then inject these properties is that all application contexts
register and use a special JavaBeans <code>PropertyEditor</code>, which can convert <code>String</code> paths
to <code>Resource</code> objects. For example, the following <code>MyBean</code> class has a <code>template</code>
property of type <code>Resource</code>.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package example;

public class MyBean {

    private Resource template;

    public setTemplate(Resource template) {
        this.template = template;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class MyBean(var template: Resource)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In an XML configuration file, the <code>template</code> property can be configured with a simple
string for that resource, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="myBean" class="example.MyBean"&gt;
    &lt;property name="template" value="some/resource/path/myTemplate.txt"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the resource path has no prefix. Consequently, because the application context
itself is going to be used as the <code>ResourceLoader</code>, the resource is loaded through a
<code>ClassPathResource</code>, a <code>FileSystemResource</code>, or a <code>ServletContextResource</code>, depending on
the exact type of the application context.</p>
</div>
<div class="paragraph">
<p>If you need to force a specific <code>Resource</code> type to be used, you can use a prefix. The
following two examples show how to force a <code>ClassPathResource</code> and a <code>UrlResource</code> (the
latter being used to access a file in the filesystem):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;property name="template" value="classpath:some/resource/path/myTemplate.txt"&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;property name="template" value="file:///some/resource/path/myTemplate.txt"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the <code>MyBean</code> class is refactored for use with annotation-driven configuration, the
path to <code>myTemplate.txt</code> can be stored under a key named <code>template.path</code>&#8201;&#8212;&#8201;for example,
in a properties file made available to the Spring <code>Environment</code> (see
<a href="#beans-environment">Environment Abstraction</a>). The template path can then be referenced via the <code>@Value</code>
annotation using a property placeholder (see <a href="#beans-value-annotations">Using <code>@Value</code></a>). Spring will
retrieve the value of the template path as a string, and a special <code>PropertyEditor</code> will
convert the string to a <code>Resource</code> object to be injected into the <code>MyBean</code> constructor.
The following example demonstrates how to achieve this.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Component
public class MyBean {

    private final Resource template;

    public MyBean(@Value("${template.path}") Resource template) {
        this.template = template;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Component
class MyBean(@Value("\${template.path}") private val template: Resource)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we want to support multiple templates discovered under the same path in multiple
locations in the classpath&#8201;&#8212;&#8201;for example, in multiple jars in the classpath&#8201;&#8212;&#8201;we can
use the special <code>classpath*:</code> prefix and wildcarding to define a <code>templates.path</code> key as
<code>classpath*:/config/templates/*.txt</code>. If we redefine the <code>MyBean</code> class as follows,
Spring will convert the template path pattern into an array of <code>Resource</code> objects that
can be injected into the <code>MyBean</code> constructor.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Component
public class MyBean {

    private final Resource[] templates;

    public MyBean(@Value("${templates.path}") Resource[] templates) {
        this.templates = templates;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Component
class MyBean(@Value("\${templates.path}") private val templates: Resource[])</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="resources-app-ctx"><a class="anchor" href="#resources-app-ctx"></a>2.8. Application Contexts and Resource Paths</h3>
<div class="paragraph">
<p>This section covers how to create application contexts with resources, including shortcuts
that work with XML, how to use wildcards, and other details.</p>
</div>
<div class="sect3">
<h4 id="resources-app-ctx-construction"><a class="anchor" href="#resources-app-ctx-construction"></a>2.8.1. Constructing Application Contexts</h4>
<div class="paragraph">
<p>An application context constructor (for a specific application context type) generally
takes a string or array of strings as the location paths of the resources, such as
XML files that make up the definition of the context.</p>
</div>
<div class="paragraph">
<p>When such a location path does not have a prefix, the specific <code>Resource</code> type built from
that path and used to load the bean definitions depends on and is appropriate to the
specific application context. For example, consider the following example, which creates a
<code>ClassPathXmlApplicationContext</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ApplicationContext ctx = new ClassPathXmlApplicationContext("conf/appContext.xml");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val ctx = ClassPathXmlApplicationContext("conf/appContext.xml")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The bean definitions are loaded from the classpath, because a <code>ClassPathResource</code> is
used. However, consider the following example, which creates a <code>FileSystemXmlApplicationContext</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ApplicationContext ctx =
    new FileSystemXmlApplicationContext("conf/appContext.xml");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val ctx = FileSystemXmlApplicationContext("conf/appContext.xml")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now the bean definitions are loaded from a filesystem location (in this case, relative to
the current working directory).</p>
</div>
<div class="paragraph">
<p>Note that the use of the special <code>classpath</code> prefix or a standard URL prefix on the
location path overrides the default type of <code>Resource</code> created to load the bean
definitions. Consider the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ApplicationContext ctx =
    new FileSystemXmlApplicationContext("classpath:conf/appContext.xml");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val ctx = FileSystemXmlApplicationContext("classpath:conf/appContext.xml")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using <code>FileSystemXmlApplicationContext</code> loads the bean definitions from the classpath.
However, it is still a <code>FileSystemXmlApplicationContext</code>. If it is subsequently used as a
<code>ResourceLoader</code>, any unprefixed paths are still treated as filesystem paths.</p>
</div>
<div class="sect4">
<h5 id="resources-app-ctx-classpathxml"><a class="anchor" href="#resources-app-ctx-classpathxml"></a>Constructing <code>ClassPathXmlApplicationContext</code> Instances&#8201;&#8212;&#8201;Shortcuts</h5>
<div class="paragraph">
<p>The <code>ClassPathXmlApplicationContext</code> exposes a number of constructors to enable
convenient instantiation. The basic idea is that you can supply merely a string array
that contains only the filenames of the XML files themselves (without the leading path
information) and also supply a <code>Class</code>. The <code>ClassPathXmlApplicationContext</code> then derives
the path information from the supplied class.</p>
</div>
<div class="paragraph">
<p>Consider the following directory layout:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>com/
  example/
    services.xml
    repositories.xml
    MessengerService.class</pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows how a <code>ClassPathXmlApplicationContext</code> instance composed of
the beans defined in files named <code>services.xml</code> and <code>repositories.xml</code> (which are on the
classpath) can be instantiated:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ApplicationContext ctx = new ClassPathXmlApplicationContext(
    new String[] {"services.xml", "repositories.xml"}, MessengerService.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val ctx = ClassPathXmlApplicationContext(arrayOf("services.xml", "repositories.xml"), MessengerService::class.java)</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/context/support/ClassPathXmlApplicationContext.html"><code>ClassPathXmlApplicationContext</code></a>
javadoc for details on the various constructors.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="resources-app-ctx-wildcards-in-resource-paths"><a class="anchor" href="#resources-app-ctx-wildcards-in-resource-paths"></a>2.8.2. Wildcards in Application Context Constructor Resource Paths</h4>
<div class="paragraph">
<p>The resource paths in application context constructor values may be simple paths (as
shown earlier), each of which has a one-to-one mapping to a target <code>Resource</code> or,
alternately, may contain the special <code>classpath*:</code> prefix or internal Ant-style patterns
(matched by using Spring&#8217;s <code>PathMatcher</code> utility). Both of the latter are effectively
wildcards.</p>
</div>
<div class="paragraph">
<p>One use for this mechanism is when you need to do component-style application assembly. All
components can <em>publish</em> context definition fragments to a well-known location path, and,
when the final application context is created using the same path prefixed with
<code>classpath*:</code>, all component fragments are automatically picked up.</p>
</div>
<div class="paragraph">
<p>Note that this wildcarding is specific to the use of resource paths in application context
constructors (or when you use the <code>PathMatcher</code> utility class hierarchy directly) and is
resolved at construction time. It has nothing to do with the <code>Resource</code> type itself.
You cannot use the <code>classpath*:</code> prefix to construct an actual <code>Resource</code>, as
a resource points to just one resource at a time.</p>
</div>
<div class="sect4">
<h5 id="resources-app-ctx-ant-patterns-in-paths"><a class="anchor" href="#resources-app-ctx-ant-patterns-in-paths"></a>Ant-style Patterns</h5>
<div class="paragraph">
<p>Path locations can contain Ant-style patterns, as the following example shows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>/WEB-INF/*-context.xml
com/mycompany/**/applicationContext.xml
file:C:/some/path/*-context.xml
classpath:com/mycompany/**/applicationContext.xml</pre>
</div>
</div>
<div class="paragraph">
<p>When the path location contains an Ant-style pattern, the resolver follows a more complex
procedure to try to resolve the wildcard. It produces a <code>Resource</code> for the path up to the
last non-wildcard segment and obtains a URL from it. If this URL is not a <code>jar:</code> URL or
container-specific variant (such as <code>zip:</code> in WebLogic, <code>wsjar</code> in WebSphere, and so on),
a <code>java.io.File</code> is obtained from it and used to resolve the wildcard by traversing the
filesystem. In the case of a jar URL, the resolver either gets a
<code>java.net.JarURLConnection</code> from it or manually parses the jar URL and then traverses the
contents of the jar file to resolve the wildcards.</p>
</div>
<div class="sect5">
<h6 id="resources-app-ctx-portability"><a class="anchor" href="#resources-app-ctx-portability"></a>Implications on Portability</h6>
<div class="paragraph">
<p>If the specified path is already a <code>file</code> URL (either implicitly because the base
<code>ResourceLoader</code> is a filesystem one or explicitly), wildcarding is guaranteed to
work in a completely portable fashion.</p>
</div>
<div class="paragraph">
<p>If the specified path is a <code>classpath</code> location, the resolver must obtain the last
non-wildcard path segment URL by making a <code>Classloader.getResource()</code> call. Since this
is just a node of the path (not the file at the end), it is actually undefined (in the
<code>ClassLoader</code> javadoc) exactly what sort of a URL is returned in this case. In practice,
it is always a <code>java.io.File</code> representing the directory (where the classpath resource
resolves to a filesystem location) or a jar URL of some sort (where the classpath resource
resolves to a jar location). Still, there is a portability concern on this operation.</p>
</div>
<div class="paragraph">
<p>If a jar URL is obtained for the last non-wildcard segment, the resolver must be able to
get a <code>java.net.JarURLConnection</code> from it or manually parse the jar URL, to be able to
walk the contents of the jar and resolve the wildcard. This does work in most environments
but fails in others, and we strongly recommend that the wildcard resolution of resources
coming from jars be thoroughly tested in your specific environment before you rely on it.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="resources-classpath-wildcards"><a class="anchor" href="#resources-classpath-wildcards"></a>The <code>classpath*:</code> Prefix</h5>
<div class="paragraph">
<p>When constructing an XML-based application context, a location string may use the
special <code>classpath*:</code> prefix, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ApplicationContext ctx =
    new ClassPathXmlApplicationContext("classpath*:conf/appContext.xml");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val ctx = ClassPathXmlApplicationContext("classpath*:conf/appContext.xml")</code></pre>
</div>
</div>
<div class="paragraph">
<p>This special prefix specifies that all classpath resources that match the given name
must be obtained (internally, this essentially happens through a call to
<code>ClassLoader.getResources(&#8230;&#8203;)</code>) and then merged to form the final application
context definition.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The wildcard classpath relies on the <code>getResources()</code> method of the underlying
<code>ClassLoader</code>. As most application servers nowadays supply their own <code>ClassLoader</code>
implementation, the behavior might differ, especially when dealing with jar files. A
simple test to check if <code>classpath*</code> works is to use the <code>ClassLoader</code> to load a file from
within a jar on the classpath:
<code>getClass().getClassLoader().getResources("&lt;someFileInsideTheJar&gt;")</code>. Try this test with
files that have the same name but reside in two different locations&#8201;&#8212;&#8201;for example, files
with the same name and same path but in different jars on the classpath. In case an
inappropriate result is returned, check the application server documentation for settings
that might affect the <code>ClassLoader</code> behavior.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You can also combine the <code>classpath*:</code> prefix with a <code>PathMatcher</code> pattern in the
rest of the location path (for example, <code>classpath*:META-INF/*-beans.xml</code>). In this
case, the resolution strategy is fairly simple: A <code>ClassLoader.getResources()</code> call is
used on the last non-wildcard path segment to get all the matching resources in the
class loader hierarchy and then, off each resource, the same <code>PathMatcher</code> resolution
strategy described earlier is used for the wildcard subpath.</p>
</div>
</div>
<div class="sect4">
<h5 id="resources-wildcards-in-path-other-stuff"><a class="anchor" href="#resources-wildcards-in-path-other-stuff"></a>Other Notes Relating to Wildcards</h5>
<div class="paragraph">
<p>Note that <code>classpath*:</code>, when combined with Ant-style patterns, only works
reliably with at least one root directory before the pattern starts, unless the actual
target files reside in the file system. This means that a pattern such as
<code>classpath*:*.xml</code> might not retrieve files from the root of jar files but rather only
from the root of expanded directories.</p>
</div>
<div class="paragraph">
<p>Spring&#8217;s ability to retrieve classpath entries originates from the JDK&#8217;s
<code>ClassLoader.getResources()</code> method, which only returns file system locations for an
empty string (indicating potential roots to search). Spring evaluates
<code>URLClassLoader</code> runtime configuration and the <code>java.class.path</code> manifest in jar files
as well, but this is not guaranteed to lead to portable behavior.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The scanning of classpath packages requires the presence of corresponding directory
entries in the classpath. When you build JARs with Ant, do not activate the <code>files-only</code>
switch of the JAR task. Also, classpath directories may not get exposed based on security
policies in some environments&#8201;&#8212;&#8201;for example, stand-alone applications on JDK 1.7.0_45
and higher (which requires 'Trusted-Library' to be set up in your manifests. See
<a href="https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources" class="bare">https://stackoverflow.com/questions/19394570/java-jre-7u45-breaks-classloader-getresources</a>).</p>
</div>
<div class="paragraph">
<p>On JDK 9&#8217;s module path (Jigsaw), Spring&#8217;s classpath scanning generally works as expected.
Putting resources into a dedicated directory is highly recommendable here as well,
avoiding the aforementioned portability problems with searching the jar file root level.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Ant-style patterns with <code>classpath:</code> resources are not guaranteed to find matching
resources if the root package to search is available in multiple classpath locations.
Consider the following example of a resource location:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>com/mycompany/package1/service-context.xml</pre>
</div>
</div>
<div class="paragraph">
<p>Now consider an Ant-style path that someone might use to try to find that file:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>classpath:com/mycompany/**/service-context.xml</pre>
</div>
</div>
<div class="paragraph">
<p>Such a resource may exist in only one location in the classpath, but when a path such as
the preceding example is used to try to resolve it, the resolver works off the (first)
URL returned by <code>getResource("com/mycompany");</code>. If this base package node exists in
multiple <code>ClassLoader</code> locations, the desired resource may not exist in the first
location found. Therefore, in such cases you should prefer using <code>classpath*:</code> with the
same Ant-style pattern, which searches all classpath locations that contain the
<code>com.mycompany</code> base package: <code>classpath*:com/mycompany/**/service-context.xml</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="resources-filesystemresource-caveats"><a class="anchor" href="#resources-filesystemresource-caveats"></a>2.8.3. <code>FileSystemResource</code> Caveats</h4>
<div class="paragraph">
<p>A <code>FileSystemResource</code> that is not attached to a <code>FileSystemApplicationContext</code> (that
is, when a <code>FileSystemApplicationContext</code> is not the actual <code>ResourceLoader</code>) treats
absolute and relative paths as you would expect. Relative paths are relative to the
current working directory, while absolute paths are relative to the root of the
filesystem.</p>
</div>
<div class="paragraph">
<p>For backwards compatibility (historical) reasons however, this changes when the
<code>FileSystemApplicationContext</code> is the <code>ResourceLoader</code>. The
<code>FileSystemApplicationContext</code> forces all attached <code>FileSystemResource</code> instances
to treat all location paths as relative, whether they start with a leading slash or not.
In practice, this means the following examples are equivalent:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ApplicationContext ctx =
    new FileSystemXmlApplicationContext("conf/context.xml");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val ctx = FileSystemXmlApplicationContext("conf/context.xml")</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ApplicationContext ctx =
    new FileSystemXmlApplicationContext("/conf/context.xml");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val ctx = FileSystemXmlApplicationContext("/conf/context.xml")</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following examples are also equivalent (even though it would make sense for them to be different, as one
case is relative and the other absolute):</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">FileSystemXmlApplicationContext ctx = ...;
ctx.getResource("some/resource/path/myTemplate.txt");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val ctx: FileSystemXmlApplicationContext = ...
ctx.getResource("some/resource/path/myTemplate.txt")</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">FileSystemXmlApplicationContext ctx = ...;
ctx.getResource("/some/resource/path/myTemplate.txt");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val ctx: FileSystemXmlApplicationContext = ...
ctx.getResource("/some/resource/path/myTemplate.txt")</code></pre>
</div>
</div>
<div class="paragraph">
<p>In practice, if you need true absolute filesystem paths, you should avoid using
absolute paths with <code>FileSystemResource</code> or <code>FileSystemXmlApplicationContext</code> and
force the use of a <code>UrlResource</code> by using the <code>file:</code> URL prefix. The following examples
show how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// actual context type doesn't matter, the Resource will always be UrlResource
ctx.getResource("file:///some/resource/path/myTemplate.txt");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// actual context type doesn't matter, the Resource will always be UrlResource
ctx.getResource("file:///some/resource/path/myTemplate.txt")</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// force this FileSystemXmlApplicationContext to load its definition via a UrlResource
ApplicationContext ctx =
    new FileSystemXmlApplicationContext("file:///conf/context.xml");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// force this FileSystemXmlApplicationContext to load its definition via a UrlResource
val ctx = FileSystemXmlApplicationContext("file:///conf/context.xml")</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 5.3.7<br>
Last updated 2021-05-12 05:38:50 UTC
</div>
</div>
<link rel="stylesheet" href="js/highlight/styles/googlecode.min.css">
<script data-cfasync="false" src="js/cdn-cgi/email-decode.min.js"></script><script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<script>if (window.parent == window) {(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','js/google-analytics/analytics.js','ga');ga('create', 'UA-2728886-23', 'auto', {'siteSpeedSampleRate': 100});ga('send', 'pageview');}</script></body>
</html>