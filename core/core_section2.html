<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<title>Core Technologies</title>
<style>
@import 'css/spring.css';

.listingblock .switch {
border-style: none;
display: inline-block;
position: relative;
bottom: -3px;
}

.listingblock .switch--item {
padding: 10px;
background-color: #e6e1dc;
color: #282c34;
display: inline-block;
cursor: pointer;
border-top-left-radius: 4px;
border-top-right-radius: 4px;
}

.listingblock .switch--item:not(:first-child) {
border-style: none;
}

.listingblock .switch--item.selected {
background-color: #282c34;
color: #e6e1dc;
}

.listingblock pre.highlightjs {
padding: 0;
}
.translate {
#	display: none;
#	font-size: small;
#	color: #090;
color: #6db33f;
}

div p + div {
margin-top: -20px;
}

div p {
#    display: none;
}
</style>
<link rel="stylesheet" href="css/cloudflare/font-awesome.min.css">
<link rel="stylesheet" href="css/translate.css">
<link rel="shortcut icon" href="images/favicon.ico" type="image/x-icon">
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="js/cloudflare/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

function globalSwitch() {
	$('.switch--item').each(function() {
		var blockId = blockIdForSwitchItem($(this));
		$(this).off('click');
		$(this).on('click', function() {
			selectedText = $(this).text()
			window.localStorage.setItem(blockId, selectedText);
			$(".switch--item").filter(function() {
				return blockIdForSwitchItem($(this)) === blockId;
			}).filter(function() {
				return $(this).text() === selectedText;
			}).each(function() {
				select($(this))
			});
		});
		if ($(this).text() === window.localStorage.getItem(blockId)) {
			select($(this))
		}
	});
}

function blockIdForSwitchItem(item) {
	idComponents = []
	idComponents.push(item.text().toLowerCase());
	item.siblings(".switch--item").each(function(index, sibling) {
		idComponents.push($(sibling).text().toLowerCase());
	});
	return idComponents.sort().join("-")
}

function select(selected) {
	selected.addClass('selected');
	selected.siblings().removeClass('selected');
	selectedContent = selected.parent().siblings(".content").eq(selected.index())
	selectedContent.removeClass('hidden');
	selectedContent.siblings().addClass('hidden');
}

$(addBlockSwitches);
$(globalSwitch);

</script>
</head>
<body id="spring-core" class="book toc2 toc-left">
<div id="header">
<h1>Core Technologies<div class="translate">核心技术</div></h1>
<div class="details">
<span id="revnumber">version 5.3.7</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#beans">1. The IoC Container</a>
<ul class="sectlevel2">
<li><a href="#beans-introduction">1.1. Introduction to the Spring IoC Container and Beans</a></li>
<li><a href="#beans-basics">1.2. Container Overview</a>
<ul class="sectlevel3">
<li><a href="#beans-factory-metadata">1.2.1. Configuration Metadata</a></li>
<li><a href="#beans-factory-instantiation">1.2.2. Instantiating a Container</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-xml-import">Composing XML-based Configuration Metadata</a></li>
<li><a href="#groovy-bean-definition-dsl">The Groovy Bean Definition DSL</a></li>
</ul>
</li>
<li><a href="#beans-factory-client">1.2.3. Using the Container</a></li>
</ul>
</li>
<li><a href="#beans-definition">1.3. Bean Overview</a>
<ul class="sectlevel3">
<li><a href="#beans-beanname">1.3.1. Naming Beans</a>
<ul class="sectlevel4">
<li><a href="#beans-beanname-alias">Aliasing a Bean outside the Bean Definition</a></li>
</ul>
</li>
<li><a href="#beans-factory-class">1.3.2. Instantiating Beans</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-class-ctor">Instantiation with a Constructor</a></li>
<li><a href="#beans-factory-class-static-factory-method">Instantiation with a Static Factory Method</a></li>
<li><a href="#beans-factory-class-instance-factory-method">Instantiation by Using an Instance Factory Method</a></li>
<li><a href="#beans-factory-type-determination">Determining a Bean&#8217;s Runtime Type</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#beans-dependencies">1.4. Dependencies</a>
<ul class="sectlevel3">
<li><a href="#beans-factory-collaborators">1.4.1. Dependency Injection</a>
<ul class="sectlevel4">
<li><a href="#beans-constructor-injection">Constructor-based Dependency Injection</a></li>
<li><a href="#beans-setter-injection">Setter-based Dependency Injection</a></li>
<li><a href="#beans-dependency-resolution">Dependency Resolution Process</a></li>
<li><a href="#beans-some-examples">Examples of Dependency Injection</a></li>
</ul>
</li>
<li><a href="#beans-factory-properties-detailed">1.4.2. Dependencies and Configuration in Detail</a>
<ul class="sectlevel4">
<li><a href="#beans-value-element">Straight Values (Primitives, Strings, and so on)</a></li>
<li><a href="#beans-ref-element">References to Other Beans (Collaborators)</a></li>
<li><a href="#beans-inner-beans">Inner Beans</a></li>
<li><a href="#beans-collection-elements">Collections</a></li>
<li><a href="#beans-null-element">Null and Empty String Values</a></li>
<li><a href="#beans-p-namespace">XML Shortcut with the p-namespace</a></li>
<li><a href="#beans-c-namespace">XML Shortcut with the c-namespace</a></li>
<li><a href="#beans-compound-property-names">Compound Property Names</a></li>
</ul>
</li>
<li><a href="#beans-factory-dependson">1.4.3. Using <code>depends-on</code></a></li>
<li><a href="#beans-factory-lazy-init">1.4.4. Lazy-initialized Beans</a></li>
<li><a href="#beans-factory-autowire">1.4.5. Autowiring Collaborators</a>
<ul class="sectlevel4">
<li><a href="#beans-autowired-exceptions">Limitations and Disadvantages of Autowiring</a></li>
<li><a href="#beans-factory-autowire-candidate">Excluding a Bean from Autowiring</a></li>
</ul>
</li>
<li><a href="#beans-factory-method-injection">1.4.6. Method Injection</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-lookup-method-injection">Lookup Method Injection</a></li>
<li><a href="#beans-factory-arbitrary-method-replacement">Arbitrary Method Replacement</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#beans-factory-scopes">1.5. Bean Scopes</a>
<ul class="sectlevel3">
<li><a href="#beans-factory-scopes-singleton">1.5.1. The Singleton Scope</a></li>
<li><a href="#beans-factory-scopes-prototype">1.5.2. The Prototype Scope</a></li>
<li><a href="#beans-factory-scopes-sing-prot-interaction">1.5.3. Singleton Beans with Prototype-bean Dependencies</a></li>
<li><a href="#beans-factory-scopes-other">1.5.4. Request, Session, Application, and WebSocket Scopes</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-scopes-other-web-configuration">Initial Web Configuration</a></li>
<li><a href="#beans-factory-scopes-request">Request scope</a></li>
<li><a href="#beans-factory-scopes-session">Session Scope</a></li>
<li><a href="#beans-factory-scopes-application">Application Scope</a></li>
<li><a href="#beans-factory-scopes-other-injection">Scoped Beans as Dependencies</a></li>
</ul>
</li>
<li><a href="#beans-factory-scopes-custom">1.5.5. Custom Scopes</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-scopes-custom-creating">Creating a Custom Scope</a></li>
<li><a href="#beans-factory-scopes-custom-using">Using a Custom Scope</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#beans-factory-nature">1.6. Customizing the Nature of a Bean</a>
<ul class="sectlevel3">
<li><a href="#beans-factory-lifecycle">1.6.1. Lifecycle Callbacks</a>
<ul class="sectlevel4">
<li><a href="#beans-factory-lifecycle-initializingbean">Initialization Callbacks</a></li>
<li><a href="#beans-factory-lifecycle-disposablebean">Destruction Callbacks</a></li>
<li><a href="#beans-factory-lifecycle-default-init-destroy-methods">Default Initialization and Destroy Methods</a></li>
<li><a href="#beans-factory-lifecycle-combined-effects">Combining Lifecycle Mechanisms</a></li>
<li><a href="#beans-factory-lifecycle-processor">Startup and Shutdown Callbacks</a></li>
<li><a href="#beans-factory-shutdown">Shutting Down the Spring IoC Container Gracefully in Non-Web Applications</a></li>
</ul>
</li>
<li><a href="#beans-factory-aware">1.6.2. <code>ApplicationContextAware</code> and <code>BeanNameAware</code></a></li>
<li><a href="#aware-list">1.6.3. Other <code>Aware</code> Interfaces</a></li>
</ul>
</li>
<li><a href="#beans-child-bean-definitions">1.7. Bean Definition Inheritance</a></li>
<li><a href="#beans-factory-extension">1.8. Container Extension Points</a>
<ul class="sectlevel3">
<li><a href="#beans-factory-extension-bpp">1.8.1. Customizing Beans by Using a <code>BeanPostProcessor</code></a>
<ul class="sectlevel4">
<li><a href="#beans-factory-extension-bpp-examples-hw">Example: Hello World, <code>BeanPostProcessor</code>-style</a></li>
<li><a href="#beans-factory-extension-bpp-examples-aabpp">Example: The <code>AutowiredAnnotationBeanPostProcessor</code></a></li>
</ul>
</li>
<li><a href="#beans-factory-extension-factory-postprocessors">1.8.2. Customizing Configuration Metadata with a <code>BeanFactoryPostProcessor</code></a>
<ul class="sectlevel4">
<li><a href="#beans-factory-placeholderconfigurer">Example: The Class Name Substitution <code>PropertySourcesPlaceholderConfigurer</code></a></li>
<li><a href="#beans-factory-overrideconfigurer">Example: The <code>PropertyOverrideConfigurer</code></a></li>
</ul>
</li>
<li><a href="#beans-factory-extension-factorybean">1.8.3. Customizing Instantiation Logic with a <code>FactoryBean</code></a></li>
</ul>
</li>
<li><a href="#beans-annotation-config">1.9. Annotation-based Container Configuration</a>
<ul class="sectlevel3">
<li><a href="#beans-required-annotation">1.9.1. @Required</a></li>
<li><a href="#beans-autowired-annotation">1.9.2. Using <code>@Autowired</code></a></li>
<li><a href="#beans-autowired-annotation-primary">1.9.3. Fine-tuning Annotation-based Autowiring with <code>@Primary</code></a></li>
<li><a href="#beans-autowired-annotation-qualifiers">1.9.4. Fine-tuning Annotation-based Autowiring with Qualifiers</a></li>
<li><a href="#beans-generics-as-qualifiers">1.9.5. Using Generics as Autowiring Qualifiers</a></li>
<li><a href="#beans-custom-autowire-configurer">1.9.6. Using <code>CustomAutowireConfigurer</code></a></li>
<li><a href="#beans-resource-annotation">1.9.7. Injection with <code>@Resource</code></a></li>
<li><a href="#beans-value-annotations">1.9.8. Using <code>@Value</code></a></li>
<li><a href="#beans-postconstruct-and-predestroy-annotations">1.9.9. Using <code>@PostConstruct</code> and <code>@PreDestroy</code></a></li>
</ul>
</li>
<li><a href="#beans-classpath-scanning">1.10. Classpath Scanning and Managed Components</a>
<ul class="sectlevel3">
<li><a href="#beans-stereotype-annotations">1.10.1. <code>@Component</code> and Further Stereotype Annotations</a></li>
<li><a href="#beans-meta-annotations">1.10.2. Using Meta-annotations and Composed Annotations</a></li>
<li><a href="#beans-scanning-autodetection">1.10.3. Automatically Detecting Classes and Registering Bean Definitions</a></li>
<li><a href="#beans-scanning-filters">1.10.4. Using Filters to Customize Scanning</a></li>
<li><a href="#beans-factorybeans-annotations">1.10.5. Defining Bean Metadata within Components</a></li>
<li><a href="#beans-scanning-name-generator">1.10.6. Naming Autodetected Components</a></li>
<li><a href="#beans-scanning-scope-resolver">1.10.7. Providing a Scope for Autodetected Components</a></li>
<li><a href="#beans-scanning-qualifiers">1.10.8. Providing Qualifier Metadata with Annotations</a></li>
<li><a href="#beans-scanning-index">1.10.9. Generating an Index of Candidate Components</a></li>
</ul>
</li>
<li><a href="#beans-standard-annotations">1.11. Using JSR 330 Standard Annotations</a>
<ul class="sectlevel3">
<li><a href="#beans-inject-named">1.11.1. Dependency Injection with <code>@Inject</code> and <code>@Named</code></a></li>
<li><a href="#beans-named">1.11.2. <code>@Named</code> and <code>@ManagedBean</code>: Standard Equivalents to the <code>@Component</code> Annotation</a></li>
<li><a href="#beans-standard-annotations-limitations">1.11.3. Limitations of JSR-330 Standard Annotations</a></li>
</ul>
</li>
<li><a href="#beans-java">1.12. Java-based Container Configuration</a>
<ul class="sectlevel3">
<li><a href="#beans-java-basic-concepts">1.12.1. Basic Concepts: <code>@Bean</code> and <code>@Configuration</code></a></li>
<li><a href="#beans-java-instantiating-container">1.12.2. Instantiating the Spring Container by Using <code>AnnotationConfigApplicationContext</code></a>
<ul class="sectlevel4">
<li><a href="#beans-java-instantiating-container-constructor">Simple Construction</a></li>
<li><a href="#beans-java-instantiating-container-register">Building the Container Programmatically by Using <code>register(Class&lt;?&gt;&#8230;&#8203;)</code></a></li>
<li><a href="#beans-java-instantiating-container-scan">Enabling Component Scanning with <code>scan(String&#8230;&#8203;)</code></a></li>
<li><a href="#beans-java-instantiating-container-web">Support for Web Applications with <code>AnnotationConfigWebApplicationContext</code></a></li>
</ul>
</li>
<li><a href="#beans-java-bean-annotation">1.12.3. Using the <code>@Bean</code> Annotation</a>
<ul class="sectlevel4">
<li><a href="#beans-java-declaring-a-bean">Declaring a Bean</a></li>
<li><a href="#beans-java-dependencies">Bean Dependencies</a></li>
<li><a href="#beans-java-lifecycle-callbacks">Receiving Lifecycle Callbacks</a></li>
<li><a href="#beans-java-specifying-bean-scope">Specifying Bean Scope</a></li>
<li><a href="#beans-java-customizing-bean-naming">Customizing Bean Naming</a></li>
<li><a href="#beans-java-bean-aliasing">Bean Aliasing</a></li>
<li><a href="#beans-java-bean-description">Bean Description</a></li>
</ul>
</li>
<li><a href="#beans-java-configuration-annotation">1.12.4. Using the <code>@Configuration</code> annotation</a>
<ul class="sectlevel4">
<li><a href="#beans-java-injecting-dependencies">Injecting Inter-bean Dependencies</a></li>
<li><a href="#beans-java-method-injection">Lookup Method Injection</a></li>
<li><a href="#beans-java-further-information-java-config">Further Information About How Java-based Configuration Works Internally</a></li>
</ul>
</li>
<li><a href="#beans-java-composing-configuration-classes">1.12.5. Composing Java-based Configurations</a>
<ul class="sectlevel4">
<li><a href="#beans-java-using-import">Using the <code>@Import</code> Annotation</a></li>
<li><a href="#beans-java-conditional">Conditionally Include <code>@Configuration</code> Classes or <code>@Bean</code> Methods</a></li>
<li><a href="#beans-java-combining">Combining Java and XML Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#beans-environment">1.13. Environment Abstraction</a>
<ul class="sectlevel3">
<li><a href="#beans-definition-profiles">1.13.1. Bean Definition Profiles</a>
<ul class="sectlevel4">
<li><a href="#beans-definition-profiles-java">Using <code>@Profile</code></a></li>
<li><a href="#beans-definition-profiles-xml">XML Bean Definition Profiles</a></li>
<li><a href="#beans-definition-profiles-enable">Activating a Profile</a></li>
<li><a href="#beans-definition-profiles-default">Default Profile</a></li>
</ul>
</li>
<li><a href="#beans-property-source-abstraction">1.13.2. <code>PropertySource</code> Abstraction</a></li>
<li><a href="#beans-using-propertysource">1.13.3. Using <code>@PropertySource</code></a></li>
<li><a href="#beans-placeholder-resolution-in-statements">1.13.4. Placeholder Resolution in Statements</a></li>
</ul>
</li>
<li><a href="#context-load-time-weaver">1.14. Registering a <code>LoadTimeWeaver</code></a></li>
<li><a href="#context-introduction">1.15. Additional Capabilities of the <code>ApplicationContext</code></a>
<ul class="sectlevel3">
<li><a href="#context-functionality-messagesource">1.15.1. Internationalization using <code>MessageSource</code></a></li>
<li><a href="#context-functionality-events">1.15.2. Standard and Custom Events</a>
<ul class="sectlevel4">
<li><a href="#context-functionality-events-annotation">Annotation-based Event Listeners</a></li>
<li><a href="#context-functionality-events-async">Asynchronous Listeners</a></li>
<li><a href="#context-functionality-events-order">Ordering Listeners</a></li>
<li><a href="#context-functionality-events-generics">Generic Events</a></li>
</ul>
</li>
<li><a href="#context-functionality-resources">1.15.3. Convenient Access to Low-level Resources</a></li>
<li><a href="#context-functionality-startup">1.15.4. Application Startup Tracking</a></li>
<li><a href="#context-create">1.15.5. Convenient ApplicationContext Instantiation for Web Applications</a></li>
<li><a href="#context-deploy-rar">1.15.6. Deploying a Spring <code>ApplicationContext</code> as a Java EE RAR File</a></li>
</ul>
</li>
<li><a href="#beans-beanfactory">1.16. The <code>BeanFactory</code></a>
<ul class="sectlevel3">
<li><a href="#context-introduction-ctx-vs-beanfactory">1.16.1. <code>BeanFactory</code> or <code>ApplicationContext</code>?</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#resources">2. Resources</a>
<ul class="sectlevel2">
<li><a href="#resources-introduction">2.1. Introduction</a></li>
<li><a href="#resources-resource">2.2. The <code>Resource</code> Interface</a></li>
<li><a href="#resources-implementations">2.3. Built-in <code>Resource</code> Implementations</a>
<ul class="sectlevel3">
<li><a href="#resources-implementations-urlresource">2.3.1. <code>UrlResource</code></a></li>
<li><a href="#resources-implementations-classpathresource">2.3.2. <code>ClassPathResource</code></a></li>
<li><a href="#resources-implementations-filesystemresource">2.3.3. <code>FileSystemResource</code></a></li>
<li><a href="#resources-implementations-pathresource">2.3.4. <code>PathResource</code></a></li>
<li><a href="#resources-implementations-servletcontextresource">2.3.5. <code>ServletContextResource</code></a></li>
<li><a href="#resources-implementations-inputstreamresource">2.3.6. <code>InputStreamResource</code></a></li>
<li><a href="#resources-implementations-bytearrayresource">2.3.7. <code>ByteArrayResource</code></a></li>
</ul>
</li>
<li><a href="#resources-resourceloader">2.4. The <code>ResourceLoader</code> Interface</a></li>
<li><a href="#resources-resourcepatternresolver">2.5. The <code>ResourcePatternResolver</code> Interface</a></li>
<li><a href="#resources-resourceloaderaware">2.6. The <code>ResourceLoaderAware</code> Interface</a></li>
<li><a href="#resources-as-dependencies">2.7. Resources as Dependencies</a></li>
<li><a href="#resources-app-ctx">2.8. Application Contexts and Resource Paths</a>
<ul class="sectlevel3">
<li><a href="#resources-app-ctx-construction">2.8.1. Constructing Application Contexts</a>
<ul class="sectlevel4">
<li><a href="#resources-app-ctx-classpathxml">Constructing <code>ClassPathXmlApplicationContext</code> Instances&#8201;&#8212;&#8201;Shortcuts</a></li>
</ul>
</li>
<li><a href="#resources-app-ctx-wildcards-in-resource-paths">2.8.2. Wildcards in Application Context Constructor Resource Paths</a>
<ul class="sectlevel4">
<li><a href="#resources-app-ctx-ant-patterns-in-paths">Ant-style Patterns</a></li>
<li><a href="#resources-classpath-wildcards">The <code>classpath*:</code> Prefix</a></li>
<li><a href="#resources-wildcards-in-path-other-stuff">Other Notes Relating to Wildcards</a></li>
</ul>
</li>
<li><a href="#resources-filesystemresource-caveats">2.8.3. <code>FileSystemResource</code> Caveats</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#validation">3. Validation, Data Binding, and Type Conversion</a>
<ul class="sectlevel2">
<li><a href="#validator">3.1. Validation by Using Spring&#8217;s Validator Interface</a></li>
<li><a href="#validation-conversion">3.2. Resolving Codes to Error Messages</a></li>
<li><a href="#beans-beans">3.3. Bean Manipulation and the <code>BeanWrapper</code></a>
<ul class="sectlevel3">
<li><a href="#beans-beans-conventions">3.3.1. Setting and Getting Basic and Nested Properties</a></li>
<li><a href="#beans-beans-conversion">3.3.2. Built-in <code>PropertyEditor</code> Implementations</a>
<ul class="sectlevel4">
<li><a href="#beans-beans-conversion-customeditor-registration">Registering Additional Custom <code>PropertyEditor</code> Implementations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#core-convert">3.4. Spring Type Conversion</a>
<ul class="sectlevel3">
<li><a href="#core-convert-Converter-API">3.4.1. Converter SPI</a></li>
<li><a href="#core-convert-ConverterFactory-SPI">3.4.2. Using <code>ConverterFactory</code></a></li>
<li><a href="#core-convert-GenericConverter-SPI">3.4.3. Using <code>GenericConverter</code></a>
<ul class="sectlevel4">
<li><a href="#core-convert-ConditionalGenericConverter-SPI">Using <code>ConditionalGenericConverter</code></a></li>
</ul>
</li>
<li><a href="#core-convert-ConversionService-API">3.4.4. The <code>ConversionService</code> API</a></li>
<li><a href="#core-convert-Spring-config">3.4.5. Configuring a <code>ConversionService</code></a></li>
<li><a href="#core-convert-programmatic-usage">3.4.6. Using a <code>ConversionService</code> Programmatically</a></li>
</ul>
</li>
<li><a href="#format">3.5. Spring Field Formatting</a>
<ul class="sectlevel3">
<li><a href="#format-Formatter-SPI">3.5.1. The <code>Formatter</code> SPI</a></li>
<li><a href="#format-CustomFormatAnnotations">3.5.2. Annotation-driven Formatting</a>
<ul class="sectlevel4">
<li><a href="#format-annotations-api">Format Annotation API</a></li>
</ul>
</li>
<li><a href="#format-FormatterRegistry-SPI">3.5.3. The <code>FormatterRegistry</code> SPI</a></li>
<li><a href="#format-FormatterRegistrar-SPI">3.5.4. The <code>FormatterRegistrar</code> SPI</a></li>
<li><a href="#format-configuring-formatting-mvc">3.5.5. Configuring Formatting in Spring MVC</a></li>
</ul>
</li>
<li><a href="#format-configuring-formatting-globaldatetimeformat">3.6. Configuring a Global Date and Time Format</a></li>
<li><a href="#validation-beanvalidation">3.7. Java Bean Validation</a>
<ul class="sectlevel3">
<li><a href="#validation-beanvalidation-overview">3.7.1. Overview of Bean Validation</a></li>
<li><a href="#validation-beanvalidation-spring">3.7.2. Configuring a Bean Validation Provider</a>
<ul class="sectlevel4">
<li><a href="#validation-beanvalidation-spring-inject">Injecting a Validator</a></li>
<li><a href="#validation-beanvalidation-spring-constraints">Configuring Custom Constraints</a></li>
<li><a href="#validation-beanvalidation-spring-method">Spring-driven Method Validation</a></li>
<li><a href="#validation-beanvalidation-spring-other">Additional Configuration Options</a></li>
</ul>
</li>
<li><a href="#validation-binder">3.7.3. Configuring a <code>DataBinder</code></a></li>
<li><a href="#validation-mvc">3.7.4. Spring MVC 3 Validation</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#expressions">4. Spring Expression Language (SpEL)</a>
<ul class="sectlevel2">
<li><a href="#expressions-evaluation">4.1. Evaluation</a>
<ul class="sectlevel3">
<li><a href="#expressions-evaluation-context">4.1.1. Understanding <code>EvaluationContext</code></a>
<ul class="sectlevel4">
<li><a href="#expressions-type-conversion">Type Conversion</a></li>
</ul>
</li>
<li><a href="#expressions-parser-configuration">4.1.2. Parser Configuration</a></li>
<li><a href="#expressions-spel-compilation">4.1.3. SpEL Compilation</a>
<ul class="sectlevel4">
<li><a href="#expressions-compiler-configuration">Compiler Configuration</a></li>
<li><a href="#expressions-compiler-limitations">Compiler Limitations</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#expressions-beandef">4.2. Expressions in Bean Definitions</a>
<ul class="sectlevel3">
<li><a href="#expressions-beandef-xml-based">4.2.1. XML Configuration</a></li>
<li><a href="#expressions-beandef-annotation-based">4.2.2. Annotation Configuration</a></li>
</ul>
</li>
<li><a href="#expressions-language-ref">4.3. Language Reference</a>
<ul class="sectlevel3">
<li><a href="#expressions-ref-literal">4.3.1. Literal Expressions</a></li>
<li><a href="#expressions-properties-arrays">4.3.2. Properties, Arrays, Lists, Maps, and Indexers</a></li>
<li><a href="#expressions-inline-lists">4.3.3. Inline Lists</a></li>
<li><a href="#expressions-inline-maps">4.3.4. Inline Maps</a></li>
<li><a href="#expressions-array-construction">4.3.5. Array Construction</a></li>
<li><a href="#expressions-methods">4.3.6. Methods</a></li>
<li><a href="#expressions-operators">4.3.7. Operators</a>
<ul class="sectlevel4">
<li><a href="#expressions-operators-relational">Relational Operators</a></li>
<li><a href="#expressions-operators-logical">Logical Operators</a></li>
<li><a href="#expressions-operators-mathematical">Mathematical Operators</a></li>
<li><a href="#expressions-assignment">The Assignment Operator</a></li>
</ul>
</li>
<li><a href="#expressions-types">4.3.8. Types</a></li>
<li><a href="#expressions-constructors">4.3.9. Constructors</a></li>
<li><a href="#expressions-ref-variables">4.3.10. Variables</a>
<ul class="sectlevel4">
<li><a href="#expressions-this-root">The <code>#this</code> and <code>#root</code> Variables</a></li>
</ul>
</li>
<li><a href="#expressions-ref-functions">4.3.11. Functions</a></li>
<li><a href="#expressions-bean-references">4.3.12. Bean References</a></li>
<li><a href="#expressions-operator-ternary">4.3.13. Ternary Operator (If-Then-Else)</a></li>
<li><a href="#expressions-operator-elvis">4.3.14. The Elvis Operator</a></li>
<li><a href="#expressions-operator-safe-navigation">4.3.15. Safe Navigation Operator</a></li>
<li><a href="#expressions-collection-selection">4.3.16. Collection Selection</a></li>
<li><a href="#expressions-collection-projection">4.3.17. Collection Projection</a></li>
<li><a href="#expressions-templating">4.3.18. Expression templating</a></li>
</ul>
</li>
<li><a href="#expressions-example-classes">4.4. Classes Used in the Examples</a></li>
</ul>
</li>
<li><a href="#aop">5. Aspect Oriented Programming with Spring</a>
<ul class="sectlevel2">
<li><a href="#aop-introduction-defn">5.1. AOP Concepts</a></li>
<li><a href="#aop-introduction-spring-defn">5.2. Spring AOP Capabilities and Goals</a></li>
<li><a href="#aop-introduction-proxies">5.3. AOP Proxies</a></li>
<li><a href="#aop-ataspectj">5.4. @AspectJ support</a>
<ul class="sectlevel3">
<li><a href="#aop-aspectj-support">5.4.1. Enabling @AspectJ Support</a>
<ul class="sectlevel4">
<li><a href="#aop-enable-aspectj-java">Enabling @AspectJ Support with Java Configuration</a></li>
<li><a href="#aop-enable-aspectj-xml">Enabling @AspectJ Support with XML Configuration</a></li>
</ul>
</li>
<li><a href="#aop-at-aspectj">5.4.2. Declaring an Aspect</a></li>
<li><a href="#aop-pointcuts">5.4.3. Declaring a Pointcut</a>
<ul class="sectlevel4">
<li><a href="#aop-pointcuts-designators">Supported Pointcut Designators</a></li>
<li><a href="#aop-pointcuts-combining">Combining Pointcut Expressions</a></li>
<li><a href="#aop-common-pointcuts">Sharing Common Pointcut Definitions</a></li>
<li><a href="#aop-pointcuts-examples">Examples</a></li>
<li><a href="#writing-good-pointcuts">Writing Good Pointcuts</a></li>
</ul>
</li>
<li><a href="#aop-advice">5.4.4. Declaring Advice</a>
<ul class="sectlevel4">
<li><a href="#aop-advice-before">Before Advice</a></li>
<li><a href="#aop-advice-after-returning">After Returning Advice</a></li>
<li><a href="#aop-advice-after-throwing">After Throwing Advice</a></li>
<li><a href="#aop-advice-after-finally">After (Finally) Advice</a></li>
<li><a href="#aop-ataspectj-around-advice">Around Advice</a></li>
<li><a href="#aop-ataspectj-advice-params">Advice Parameters</a></li>
<li><a href="#aop-ataspectj-advice-ordering">Advice Ordering</a></li>
</ul>
</li>
<li><a href="#aop-introductions">5.4.5. Introductions</a></li>
<li><a href="#aop-instantiation-models">5.4.6. Aspect Instantiation Models</a></li>
<li><a href="#aop-ataspectj-example">5.4.7. An AOP Example</a></li>
</ul>
</li>
<li><a href="#aop-schema">5.5. Schema-based AOP Support</a>
<ul class="sectlevel3">
<li><a href="#aop-schema-declaring-an-aspect">5.5.1. Declaring an Aspect</a></li>
<li><a href="#aop-schema-pointcuts">5.5.2. Declaring a Pointcut</a></li>
<li><a href="#aop-schema-advice">5.5.3. Declaring Advice</a>
<ul class="sectlevel4">
<li><a href="#aop-schema-advice-before">Before Advice</a></li>
<li><a href="#aop-schema-advice-after-returning">After Returning Advice</a></li>
<li><a href="#aop-schema-advice-after-throwing">After Throwing Advice</a></li>
<li><a href="#aop-schema-advice-after-finally">After (Finally) Advice</a></li>
<li><a href="#aop-schema-advice-around">Around Advice</a></li>
<li><a href="#aop-schema-params">Advice Parameters</a></li>
<li><a href="#aop-ordering">Advice Ordering</a></li>
</ul>
</li>
<li><a href="#aop-schema-introductions">5.5.4. Introductions</a></li>
<li><a href="#aop-schema-instatiation-models">5.5.5. Aspect Instantiation Models</a></li>
<li><a href="#aop-schema-advisors">5.5.6. Advisors</a></li>
<li><a href="#aop-schema-example">5.5.7. An AOP Schema Example</a></li>
</ul>
</li>
<li><a href="#aop-choosing">5.6. Choosing which AOP Declaration Style to Use</a>
<ul class="sectlevel3">
<li><a href="#aop-spring-or-aspectj">5.6.1. Spring AOP or Full AspectJ?</a></li>
<li><a href="#aop-ataspectj-or-xml">5.6.2. @AspectJ or XML for Spring AOP?</a></li>
</ul>
</li>
<li><a href="#aop-mixing-styles">5.7. Mixing Aspect Types</a></li>
<li><a href="#aop-proxying">5.8. Proxying Mechanisms</a>
<ul class="sectlevel3">
<li><a href="#aop-understanding-aop-proxies">5.8.1. Understanding AOP Proxies</a></li>
</ul>
</li>
<li><a href="#aop-aspectj-programmatic">5.9. Programmatic Creation of @AspectJ Proxies</a></li>
<li><a href="#aop-using-aspectj">5.10. Using AspectJ with Spring Applications</a>
<ul class="sectlevel3">
<li><a href="#aop-atconfigurable">5.10.1. Using AspectJ to Dependency Inject Domain Objects with Spring</a>
<ul class="sectlevel4">
<li><a href="#aop-configurable-testing">Unit Testing <code>@Configurable</code> Objects</a></li>
<li><a href="#aop-configurable-container">Working with Multiple Application Contexts</a></li>
</ul>
</li>
<li><a href="#aop-ajlib-other">5.10.2. Other Spring aspects for AspectJ</a></li>
<li><a href="#aop-aj-configure">5.10.3. Configuring AspectJ Aspects by Using Spring IoC</a></li>
<li><a href="#aop-aj-ltw">5.10.4. Load-time Weaving with AspectJ in the Spring Framework</a>
<ul class="sectlevel4">
<li><a href="#aop-aj-ltw-first-example">A First Example</a></li>
<li><a href="#aop-aj-ltw-the-aspects">Aspects</a></li>
<li><a href="#aop-aj-ltw-aop_dot_xml">'META-INF/aop.xml'</a></li>
<li><a href="#aop-aj-ltw-libraries">Required libraries (JARS)</a></li>
<li><a href="#aop-aj-ltw-spring">Spring Configuration</a></li>
<li><a href="#aop-aj-ltw-environments">Environment-specific Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#aop-resources">5.11. Further Resources</a></li>
</ul>
</li>
<li><a href="#aop-api">6. Spring AOP APIs</a>
<ul class="sectlevel2">
<li><a href="#aop-api-pointcuts">6.1. Pointcut API in Spring</a>
<ul class="sectlevel3">
<li><a href="#aop-api-concepts">6.1.1. Concepts</a></li>
<li><a href="#aop-api-pointcut-ops">6.1.2. Operations on Pointcuts</a></li>
<li><a href="#aop-api-pointcuts-aspectj">6.1.3. AspectJ Expression Pointcuts</a></li>
<li><a href="#aop-api-pointcuts-impls">6.1.4. Convenience Pointcut Implementations</a>
<ul class="sectlevel4">
<li><a href="#aop-api-pointcuts-static">Static Pointcuts</a></li>
<li><a href="#aop-api-pointcuts-dynamic">Dynamic pointcuts</a></li>
</ul>
</li>
<li><a href="#aop-api-pointcuts-superclasses">6.1.5. Pointcut Superclasses</a></li>
<li><a href="#aop-api-pointcuts-custom">6.1.6. Custom Pointcuts</a></li>
</ul>
</li>
<li><a href="#aop-api-advice">6.2. Advice API in Spring</a>
<ul class="sectlevel3">
<li><a href="#aop-api-advice-lifecycle">6.2.1. Advice Lifecycles</a></li>
<li><a href="#aop-api-advice-types">6.2.2. Advice Types in Spring</a>
<ul class="sectlevel4">
<li><a href="#aop-api-advice-around">Interception Around Advice</a></li>
<li><a href="#aop-api-advice-before">Before Advice</a></li>
<li><a href="#aop-api-advice-throws">Throws Advice</a></li>
<li><a href="#aop-api-advice-after-returning">After Returning Advice</a></li>
<li><a href="#aop-api-advice-introduction">Introduction Advice</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#aop-api-advisor">6.3. The Advisor API in Spring</a></li>
<li><a href="#aop-pfb">6.4. Using the <code>ProxyFactoryBean</code> to Create AOP Proxies</a>
<ul class="sectlevel3">
<li><a href="#aop-pfb-1">6.4.1. Basics</a></li>
<li><a href="#aop-pfb-2">6.4.2. JavaBean Properties</a></li>
<li><a href="#aop-pfb-proxy-types">6.4.3. JDK- and CGLIB-based proxies</a></li>
<li><a href="#aop-api-proxying-intf">6.4.4. Proxying Interfaces</a></li>
<li><a href="#aop-api-proxying-class">6.4.5. Proxying Classes</a></li>
<li><a href="#aop-global-advisors">6.4.6. Using &#8220;Global&#8221; Advisors</a></li>
</ul>
</li>
<li><a href="#aop-concise-proxy">6.5. Concise Proxy Definitions</a></li>
<li><a href="#aop-prog">6.6. Creating AOP Proxies Programmatically with the <code>ProxyFactory</code></a></li>
<li><a href="#aop-api-advised">6.7. Manipulating Advised Objects</a></li>
<li><a href="#aop-autoproxy">6.8. Using the "auto-proxy" facility</a>
<ul class="sectlevel3">
<li><a href="#aop-autoproxy-choices">6.8.1. Auto-proxy Bean Definitions</a>
<ul class="sectlevel4">
<li><a href="#aop-api-autoproxy"><code>BeanNameAutoProxyCreator</code></a></li>
<li><a href="#aop-api-autoproxy-default"><code>DefaultAdvisorAutoProxyCreator</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#aop-targetsource">6.9. Using <code>TargetSource</code> Implementations</a>
<ul class="sectlevel3">
<li><a href="#aop-ts-swap">6.9.1. Hot-swappable Target Sources</a></li>
<li><a href="#aop-ts-pool">6.9.2. Pooling Target Sources</a></li>
<li><a href="#aop-ts-prototype">6.9.3. Prototype Target Sources</a></li>
<li><a href="#aop-ts-threadlocal">6.9.4. <code>ThreadLocal</code> Target Sources</a></li>
</ul>
</li>
<li><a href="#aop-extensibility">6.10. Defining New Advice Types</a></li>
</ul>
</li>
<li><a href="#null-safety">7. Null-safety</a>
<ul class="sectlevel2">
<li><a href="#use-cases">7.1. Use cases</a></li>
<li><a href="#jsr-305-meta-annotations">7.2. JSR-305 meta-annotations</a></li>
</ul>
</li>
<li><a href="#databuffers">8. Data Buffers and Codecs</a>
<ul class="sectlevel2">
<li><a href="#databuffers-factory">8.1. <code>DataBufferFactory</code></a></li>
<li><a href="#databuffers-buffer">8.2. <code>DataBuffer</code></a></li>
<li><a href="#databuffers-buffer-pooled">8.3. <code>PooledDataBuffer</code></a></li>
<li><a href="#databuffers-utils">8.4. <code>DataBufferUtils</code></a></li>
<li><a href="#codecs">8.5. Codecs</a></li>
<li><a href="#databuffers-using">8.6. Using <code>DataBuffer</code></a></li>
</ul>
</li>
<li><a href="#spring-jcl">9. Logging</a></li>
<li><a href="#appendix">10. Appendix</a>
<ul class="sectlevel2">
<li><a href="#xsd-schemas">10.1. XML Schemas</a>
<ul class="sectlevel3">
<li><a href="#xsd-schemas-util">10.1.1. The <code>util</code> Schema</a>
<ul class="sectlevel4">
<li><a href="#xsd-schemas-util-constant">Using <code>&lt;util:constant/&gt;</code></a></li>
<li><a href="#xsd-schemas-util-property-path">Using <code>&lt;util:property-path/&gt;</code></a></li>
<li><a href="#xsd-schemas-util-properties">Using <code>&lt;util:properties/&gt;</code></a></li>
<li><a href="#xsd-schemas-util-list">Using <code>&lt;util:list/&gt;</code></a></li>
<li><a href="#xsd-schemas-util-map">Using <code>&lt;util:map/&gt;</code></a></li>
<li><a href="#xsd-schemas-util-set">Using <code>&lt;util:set/&gt;</code></a></li>
</ul>
</li>
<li><a href="#xsd-schemas-aop">10.1.2. The <code>aop</code> Schema</a></li>
<li><a href="#xsd-schemas-context">10.1.3. The <code>context</code> Schema</a>
<ul class="sectlevel4">
<li><a href="#xsd-schemas-context-pphc">Using <code>&lt;property-placeholder/&gt;</code></a></li>
<li><a href="#xsd-schemas-context-ac">Using <code>&lt;annotation-config/&gt;</code></a></li>
<li><a href="#xsd-schemas-context-component-scan">Using <code>&lt;component-scan/&gt;</code></a></li>
<li><a href="#xsd-schemas-context-ltw">Using <code>&lt;load-time-weaver/&gt;</code></a></li>
<li><a href="#xsd-schemas-context-sc">Using <code>&lt;spring-configured/&gt;</code></a></li>
<li><a href="#xsd-schemas-context-mbe">Using <code>&lt;mbean-export/&gt;</code></a></li>
</ul>
</li>
<li><a href="#xsd-schemas-beans">10.1.4. The Beans Schema</a></li>
</ul>
</li>
<li><a href="#xml-custom">10.2. XML Schema Authoring</a>
<ul class="sectlevel3">
<li><a href="#xsd-custom-schema">10.2.1. Authoring the Schema</a></li>
<li><a href="#xsd-custom-namespacehandler">10.2.2. Coding a <code>NamespaceHandler</code></a></li>
<li><a href="#xsd-custom-parser">10.2.3. Using <code>BeanDefinitionParser</code></a></li>
<li><a href="#xsd-custom-registration">10.2.4. Registering the Handler and the Schema</a>
<ul class="sectlevel4">
<li><a href="#xsd-custom-registration-spring-handlers">Writing <code>META-INF/spring.handlers</code></a></li>
<li><a href="#xsd-custom-registration-spring-schemas">Writing 'META-INF/spring.schemas'</a></li>
</ul>
</li>
<li><a href="#xsd-custom-using">10.2.5. Using a Custom Extension in Your Spring XML Configuration</a></li>
<li><a href="#xsd-custom-meat">10.2.6. More Detailed Examples</a>
<ul class="sectlevel4">
<li><a href="#xsd-custom-custom-nested">Nesting Custom Elements within Custom Elements</a></li>
<li><a href="#xsd-custom-custom-just-attributes">Custom Attributes on &#8220;Normal&#8221; Elements</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#application-startup-steps">10.3. Application Startup Steps</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="validation"><a class="anchor" href="#validation"></a>3. Validation, Data Binding, and Type Conversion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There are pros and cons for considering validation as business logic, and Spring offers
a design for validation (and data binding) that does not exclude either one of them.
Specifically, validation should not be tied to the web tier and should be easy to localize,
and it should be possible to plug in any available validator. Considering these concerns,
Spring provides a <code>Validator</code> contract that is both basic and eminently usable
in every layer of an application.</p>
</div>
<div class="paragraph">
<p>Data binding is useful for letting user input be dynamically bound to the domain
model of an application (or whatever objects you use to process user input). Spring
provides the aptly named <code>DataBinder</code> to do exactly that. The <code>Validator</code> and the
<code>DataBinder</code> make up the <code>validation</code> package, which is primarily used in but not
limited to the web layer.</p>
</div>
<div class="paragraph">
<p>The <code>BeanWrapper</code> is a fundamental concept in the Spring Framework and is used in a lot
of places. However, you probably do not need to use the <code>BeanWrapper</code>
directly. Because this is reference documentation, however, we felt that some explanation
might be in order. We explain the <code>BeanWrapper</code> in this chapter, since, if you are
going to use it at all, you are most likely do so when trying to bind data to objects.</p>
</div>
<div class="paragraph">
<p>Spring&#8217;s <code>DataBinder</code> and the lower-level <code>BeanWrapper</code> both use <code>PropertyEditorSupport</code>
implementations to parse and format property values. The <code>PropertyEditor</code> and
<code>PropertyEditorSupport</code> types are part of the JavaBeans specification and are also
explained in this chapter. Spring 3 introduced a <code>core.convert</code> package that provides a
general type conversion facility, as well as a higher-level &#8220;format&#8221; package for
formatting UI field values. You can use these packages as simpler alternatives to
<code>PropertyEditorSupport</code> implementations. They are also discussed in this chapter.</p>
</div>
<div class="paragraph">
<p>Spring supports Java Bean Validation through setup infrastructure and an adaptor to
Spring&#8217;s own <code>Validator</code> contract. Applications can enable Bean Validation once globally,
as described in <a href="#validation-beanvalidation">Java Bean Validation</a>, and use it exclusively for all validation
needs. In the web layer, applications can further register controller-local Spring
<code>Validator</code> instances per <code>DataBinder</code>, as described in <a href="#validation-binder">Configuring a <code>DataBinder</code></a>, which can
be useful for plugging in custom validation logic.</p>
</div>
<div class="sect2">
<h3 id="validator"><a class="anchor" href="#validator"></a>3.1. Validation by Using Spring&#8217;s Validator Interface</h3>
<div class="paragraph">
<p>Spring features a <code>Validator</code> interface that you can use to validate objects. The
<code>Validator</code> interface works by using an <code>Errors</code> object so that, while validating,
validators can report validation failures to the <code>Errors</code> object.</p>
</div>
<div class="paragraph">
<p>Consider the following example of a small data object:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class Person {

    private String name;
    private int age;

    // the usual getters and setters...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class Person(val name: String, val age: Int)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next example provides validation behavior for the <code>Person</code> class by implementing the
following two methods of the <code>org.springframework.validation.Validator</code> interface:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>supports(Class)</code>: Can this <code>Validator</code> validate instances of the supplied <code>Class</code>?</p>
</li>
<li>
<p><code>validate(Object, org.springframework.validation.Errors)</code>: Validates the given object
and, in case of validation errors, registers those with the given <code>Errors</code> object.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Implementing a <code>Validator</code> is fairly straightforward, especially when you know of the
<code>ValidationUtils</code> helper class that the Spring Framework also provides. The following
example implements <code>Validator</code> for <code>Person</code> instances:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class PersonValidator implements Validator {

    /**
     * This Validator validates only Person instances
     */
    public boolean supports(Class clazz) {
        return Person.class.equals(clazz);
    }

    public void validate(Object obj, Errors e) {
        ValidationUtils.rejectIfEmpty(e, "name", "name.empty");
        Person p = (Person) obj;
        if (p.getAge() &lt; 0) {
            e.rejectValue("age", "negativevalue");
        } else if (p.getAge() &gt; 110) {
            e.rejectValue("age", "too.darn.old");
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class PersonValidator : Validator {

    /**
     * This Validator validates only Person instances
     */
    override fun supports(clazz: Class&lt;*&gt;): Boolean {
        return Person::class.java == clazz
    }

    override fun validate(obj: Any, e: Errors) {
        ValidationUtils.rejectIfEmpty(e, "name", "name.empty")
        val p = obj as Person
        if (p.age &lt; 0) {
            e.rejectValue("age", "negativevalue")
        } else if (p.age &gt; 110) {
            e.rejectValue("age", "too.darn.old")
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>static</code> <code>rejectIfEmpty(..)</code> method on the <code>ValidationUtils</code> class is used to
reject the <code>name</code> property if it is <code>null</code> or the empty string. Have a look at the
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/validation/ValidationUtils.html"><code>ValidationUtils</code></a> javadoc
to see what functionality it provides besides the example shown previously.</p>
</div>
<div class="paragraph">
<p>While it is certainly possible to implement a single <code>Validator</code> class to validate each
of the nested objects in a rich object, it may be better to encapsulate the validation
logic for each nested class of object in its own <code>Validator</code> implementation. A simple
example of a &#8220;rich&#8221; object would be a <code>Customer</code> that is composed of two <code>String</code>
properties (a first and a second name) and a complex <code>Address</code> object. <code>Address</code> objects
may be used independently of <code>Customer</code> objects, so a distinct <code>AddressValidator</code>
has been implemented. If you want your <code>CustomerValidator</code> to reuse the logic contained
within the <code>AddressValidator</code> class without resorting to copy-and-paste, you can
dependency-inject or instantiate an <code>AddressValidator</code> within your <code>CustomerValidator</code>,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class CustomerValidator implements Validator {

    private final Validator addressValidator;

    public CustomerValidator(Validator addressValidator) {
        if (addressValidator == null) {
            throw new IllegalArgumentException("The supplied [Validator] is " +
                "required and must not be null.");
        }
        if (!addressValidator.supports(Address.class)) {
            throw new IllegalArgumentException("The supplied [Validator] must " +
                "support the validation of [Address] instances.");
        }
        this.addressValidator = addressValidator;
    }

    /**
     * This Validator validates Customer instances, and any subclasses of Customer too
     */
    public boolean supports(Class clazz) {
        return Customer.class.isAssignableFrom(clazz);
    }

    public void validate(Object target, Errors errors) {
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "field.required");
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "surname", "field.required");
        Customer customer = (Customer) target;
        try {
            errors.pushNestedPath("address");
            ValidationUtils.invokeValidator(this.addressValidator, customer.getAddress(), errors);
        } finally {
            errors.popNestedPath();
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class CustomerValidator(private val addressValidator: Validator) : Validator {

    init {
        if (addressValidator == null) {
            throw IllegalArgumentException("The supplied [Validator] is required and must not be null.")
        }
        if (!addressValidator.supports(Address::class.java)) {
            throw IllegalArgumentException("The supplied [Validator] must support the validation of [Address] instances.")
        }
    }

    /<strong>*
    * This Validator validates Customer instances, and any subclasses of Customer too
    */
    override fun supports(clazz: Class&lt;</strong>&gt;): Boolean {
        return Customer::class.java.isAssignableFrom(clazz)
    }

    override fun validate(target: Any, errors: Errors) {
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "field.required")
        ValidationUtils.rejectIfEmptyOrWhitespace(errors, "surname", "field.required")
        val customer = target as Customer
        try {
            errors.pushNestedPath("address")
            ValidationUtils.invokeValidator(this.addressValidator, customer.address, errors)
        } finally {
            errors.popNestedPath()
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Validation errors are reported to the <code>Errors</code> object passed to the validator. In the case
of Spring Web MVC, you can use the <code>&lt;spring:bind/&gt;</code> tag to inspect the error messages, but
you can also inspect the <code>Errors</code> object yourself. More information about the
methods it offers can be found in the <a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframeworkvalidation/Errors.html">javadoc</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="validation-conversion"><a class="anchor" href="#validation-conversion"></a>3.2. Resolving Codes to Error Messages</h3>
<div class="paragraph">
<p>We covered databinding and validation. This section covers outputting messages that correspond
to validation errors. In the example shown in the <a href="#validator">preceding section</a>,
we rejected the <code>name</code> and <code>age</code> fields. If we want to output the error messages by using a
<code>MessageSource</code>, we can do so using the error code we provide when rejecting the field
('name' and 'age' in this case). When you call (either directly, or indirectly, by using,
for example, the <code>ValidationUtils</code> class) <code>rejectValue</code> or one of the other <code>reject</code> methods
from the <code>Errors</code> interface, the underlying implementation not only registers the code you
passed in but also registers a number of additional error codes. The <code>MessageCodesResolver</code>
determines which error codes the <code>Errors</code> interface registers. By default, the
<code>DefaultMessageCodesResolver</code> is used, which (for example) not only registers a message
with the code you gave but also registers messages that include the field name you passed
to the reject method. So, if you reject a field by using <code>rejectValue("age", "too.darn.old")</code>,
apart from the <code>too.darn.old</code> code, Spring also registers <code>too.darn.old.age</code> and
<code>too.darn.old.age.int</code> (the first includes the field name and the second includes the type
of the field). This is done as a convenience to aid developers when targeting error messages.</p>
</div>
<div class="paragraph">
<p>More information on the <code>MessageCodesResolver</code> and the default strategy can be found
in the javadoc of
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/validation/MessageCodesResolver.html"><code>MessageCodesResolver</code></a> and
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.html"><code>DefaultMessageCodesResolver</code></a>,
respectively.</p>
</div>
</div>
<div class="sect2">
<h3 id="beans-beans"><a class="anchor" href="#beans-beans"></a>3.3. Bean Manipulation and the <code>BeanWrapper</code></h3>
<div class="paragraph">
<p>The <code>org.springframework.beans</code> package adheres to the JavaBeans standard.
A JavaBean is a class with a default no-argument constructor and that follows
a naming convention where (for example) a property named <code>bingoMadness</code> would
have a setter method <code>setBingoMadness(..)</code> and a getter method <code>getBingoMadness()</code>. For
more information about JavaBeans and the specification, see
<a href="https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html">javabeans</a>.</p>
</div>
<div class="paragraph">
<p>One quite important class in the beans package is the <code>BeanWrapper</code> interface and its
corresponding implementation (<code>BeanWrapperImpl</code>). As quoted from the javadoc, the
<code>BeanWrapper</code> offers functionality to set and get property values (individually or in
bulk), get property descriptors, and query properties to determine if they are
readable or writable. Also, the <code>BeanWrapper</code> offers support for nested properties,
enabling the setting of properties on sub-properties to an unlimited depth. The
<code>BeanWrapper</code> also supports the ability to add standard JavaBeans <code>PropertyChangeListeners</code>
and <code>VetoableChangeListeners</code>, without the need for supporting code in the target class.
Last but not least, the <code>BeanWrapper</code> provides support for setting indexed properties.
The <code>BeanWrapper</code> usually is not used by application code directly but is used by the
<code>DataBinder</code> and the <code>BeanFactory</code>.</p>
</div>
<div class="paragraph">
<p>The way the <code>BeanWrapper</code> works is partly indicated by its name: it wraps a bean to
perform actions on that bean, such as setting and retrieving properties.</p>
</div>
<div class="sect3">
<h4 id="beans-beans-conventions"><a class="anchor" href="#beans-beans-conventions"></a>3.3.1. Setting and Getting Basic and Nested Properties</h4>
<div class="paragraph">
<p>Setting and getting properties is done through the <code>setPropertyValue</code> and
<code>getPropertyValue</code> overloaded method variants of <code>BeanWrapper</code>. See their Javadoc for
details. The below table shows some examples of these conventions:</p>
</div>
<table id="beans-beans-conventions-properties-tbl" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 11. Examples of properties</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Expression</th>
<th class="tableblock halign-left valign-top">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the property <code>name</code> that corresponds to the <code>getName()</code> or <code>isName()</code>
and <code>setName(..)</code> methods.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>account.name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the nested property <code>name</code> of the property <code>account</code> that corresponds to
(for example) the <code>getAccount().setName()</code> or <code>getAccount().getName()</code> methods.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>account[2]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the <em>third</em> element of the indexed property <code>account</code>. Indexed properties
can be of type <code>array</code>, <code>list</code>, or other naturally ordered collection.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>account[COMPANYNAME]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Indicates the value of the map entry indexed by the <code>COMPANYNAME</code> key of the <code>account</code> <code>Map</code>
property.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>(This next section is not vitally important to you if you do not plan to work with
the <code>BeanWrapper</code> directly. If you use only the <code>DataBinder</code> and the <code>BeanFactory</code>
and their default implementations, you should skip ahead to the
<a href="#beans-beans-conversion">section on <code>PropertyEditors</code></a>.)</p>
</div>
<div class="paragraph">
<p>The following two example classes use the <code>BeanWrapper</code> to get and set
properties:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class Company {

    private String name;
    private Employee managingDirector;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Employee getManagingDirector() {
        return this.managingDirector;
    }

    public void setManagingDirector(Employee managingDirector) {
        this.managingDirector = managingDirector;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class Company {
    var name: String? = null
    var managingDirector: Employee? = null
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class Employee {

    private String name;

    private float salary;

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public float getSalary() {
        return salary;
    }

    public void setSalary(float salary) {
        this.salary = salary;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class Employee {
    var name: String? = null
    var salary: Float? = null
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following code snippets show some examples of how to retrieve and manipulate some of
the properties of instantiated <code>Companies</code> and <code>Employees</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">BeanWrapper company = new BeanWrapperImpl(new Company());
// setting the company name..
company.setPropertyValue("name", "Some Company Inc.");
// ... can also be done like this:
PropertyValue value = new PropertyValue("name", "Some Company Inc.");
company.setPropertyValue(value);

// ok, let's create the director and tie it to the company:
BeanWrapper jim = new BeanWrapperImpl(new Employee());
jim.setPropertyValue("name", "Jim Stravinsky");
company.setPropertyValue("managingDirector", jim.getWrappedInstance());

// retrieving the salary of the managingDirector through the company
Float salary = (Float) company.getPropertyValue("managingDirector.salary");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val company = BeanWrapperImpl(Company())
// setting the company name..
company.setPropertyValue("name", "Some Company Inc.")
// ... can also be done like this:
val value = PropertyValue("name", "Some Company Inc.")
company.setPropertyValue(value)

// ok, let's create the director and tie it to the company:
val jim = BeanWrapperImpl(Employee())
jim.setPropertyValue("name", "Jim Stravinsky")
company.setPropertyValue("managingDirector", jim.wrappedInstance)

// retrieving the salary of the managingDirector through the company
val salary = company.getPropertyValue("managingDirector.salary") as Float?</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="beans-beans-conversion"><a class="anchor" href="#beans-beans-conversion"></a>3.3.2. Built-in <code>PropertyEditor</code> Implementations</h4>
<div class="paragraph">
<p>Spring uses the concept of a <code>PropertyEditor</code> to effect the conversion between an
<code>Object</code> and a <code>String</code>. It can be handy
to represent properties in a different way than the object itself. For example, a <code>Date</code>
can be represented in a human readable way (as the <code>String</code>: <code>'2007-14-09'</code>), while
we can still convert the human readable form back to the original date (or, even
better, convert any date entered in a human readable form back to <code>Date</code> objects). This
behavior can be achieved by registering custom editors of type
<code>java.beans.PropertyEditor</code>. Registering custom editors on a <code>BeanWrapper</code> or,
alternatively, in a specific IoC container (as mentioned in the previous chapter), gives it
the knowledge of how to convert properties to the desired type. For more about
<code>PropertyEditor</code>, see <a href="https://docs.oracle.com/javase/8/docs/api/java/beans/package-summary.html">the javadoc of the <code>java.beans</code> package from Oracle</a>.</p>
</div>
<div class="paragraph">
<p>A couple of examples where property editing is used in Spring:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Setting properties on beans is done by using <code>PropertyEditor</code> implementations.
When you use <code>String</code> as the value of a property of some bean that you declare
in an XML file, Spring (if the setter of the corresponding property has a <code>Class</code>
parameter) uses <code>ClassEditor</code> to try to resolve the parameter to a <code>Class</code> object.</p>
</li>
<li>
<p>Parsing HTTP request parameters in Spring&#8217;s MVC framework is done by using all kinds
of <code>PropertyEditor</code> implementations that you can manually bind in all subclasses of the
<code>CommandController</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring has a number of built-in <code>PropertyEditor</code> implementations to make life easy.
They are all located in the <code>org.springframework.beans.propertyeditors</code>
package. Most, (but not all, as indicated in the following table) are, by default, registered by
<code>BeanWrapperImpl</code>. Where the property editor is configurable in some fashion, you can
still register your own variant to override the default one. The following table describes
the various <code>PropertyEditor</code> implementations that Spring provides:</p>
</div>
<table id="beans-beans-property-editors-tbl" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 12. Built-in <code>PropertyEditor</code> Implementations</caption>
<colgroup>
<col style="width: 30%;">
<col style="width: 70%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Class</th>
<th class="tableblock halign-left valign-top">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ByteArrayPropertyEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Editor for byte arrays. Converts strings to their corresponding byte
representations. Registered by default by <code>BeanWrapperImpl</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ClassEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Parses Strings that represent classes to actual classes and vice-versa. When a
class is not found, an <code>IllegalArgumentException</code> is thrown. By default, registered by
<code>BeanWrapperImpl</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CustomBooleanEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Customizable property editor for <code>Boolean</code> properties. By default, registered by
<code>BeanWrapperImpl</code> but can be overridden by registering a custom instance of it as a
custom editor.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CustomCollectionEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Property editor for collections, converting any source <code>Collection</code> to a given target
<code>Collection</code> type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CustomDateEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Customizable property editor for <code>java.util.Date</code>, supporting a custom <code>DateFormat</code>. NOT
registered by default. Must be user-registered with the appropriate format as needed.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CustomNumberEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Customizable property editor for any <code>Number</code> subclass, such as <code>Integer</code>, <code>Long</code>, <code>Float</code>, or
<code>Double</code>. By default, registered by <code>BeanWrapperImpl</code> but can be overridden by
registering a custom instance of it as a custom editor.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FileEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Resolves strings to <code>java.io.File</code> objects. By default, registered by
<code>BeanWrapperImpl</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InputStreamEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">One-way property editor that can take a string and produce (through an
intermediate <code>ResourceEditor</code> and <code>Resource</code>) an <code>InputStream</code> so that <code>InputStream</code>
properties may be directly set as strings. Note that the default usage does not close
the <code>InputStream</code> for you. By default, registered by <code>BeanWrapperImpl</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LocaleEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Can resolve strings to <code>Locale</code> objects and vice-versa (the string format is
<code>[language]_[country]_[variant]</code>, same as the <code>toString()</code> method of
<code>Locale</code>). Also accepts spaces as separators, as an alternative to underscores.
By default, registered by <code>BeanWrapperImpl</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PatternEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Can resolve strings to <code>java.util.regex.Pattern</code> objects and vice-versa.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PropertiesEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Can convert strings (formatted with the format defined in the javadoc of the
<code>java.util.Properties</code> class) to <code>Properties</code> objects. By default, registered
by <code>BeanWrapperImpl</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StringTrimmerEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Property editor that trims strings. Optionally allows transforming an empty string
into a <code>null</code> value. NOT registered by default&#8201;&#8212;&#8201;must be user-registered.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>URLEditor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Can resolve a string representation of a URL to an actual <code>URL</code> object.
By default, registered by <code>BeanWrapperImpl</code>.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Spring uses the <code>java.beans.PropertyEditorManager</code> to set the search path for property
editors that might be needed. The search path also includes <code>sun.bean.editors</code>, which
includes <code>PropertyEditor</code> implementations for types such as <code>Font</code>, <code>Color</code>, and most of
the primitive types. Note also that the standard JavaBeans infrastructure
automatically discovers <code>PropertyEditor</code> classes (without you having to register them
explicitly) if they are in the same package as the class they handle and have the same
name as that class, with <code>Editor</code> appended. For example, one could have the following
class and package structure, which would be sufficient for the <code>SomethingEditor</code> class to be
recognized and used as the <code>PropertyEditor</code> for <code>Something</code>-typed properties.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>com
  chank
    pop
      Something
      SomethingEditor // the PropertyEditor for the Something class</pre>
</div>
</div>
<div class="paragraph">
<p>Note that you can also use the standard <code>BeanInfo</code> JavaBeans mechanism here as well
(described to some extent
<a href="https://docs.oracle.com/javase/tutorial/javabeans/advanced/customization.html">here</a>). The
following example uses the <code>BeanInfo</code> mechanism to explicitly register one or more
<code>PropertyEditor</code> instances with the properties of an associated class:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>com
  chank
    pop
      Something
      SomethingBeanInfo // the BeanInfo for the Something class</pre>
</div>
</div>
<div class="paragraph">
<p>The following Java source code for the referenced <code>SomethingBeanInfo</code> class
associates a <code>CustomNumberEditor</code> with the <code>age</code> property of the <code>Something</code> class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class SomethingBeanInfo extends SimpleBeanInfo {

    public PropertyDescriptor[] getPropertyDescriptors() {
        try {
            final PropertyEditor numberPE = new CustomNumberEditor(Integer.class, true);
            PropertyDescriptor ageDescriptor = new PropertyDescriptor("age", Something.class) {
                @Override
                public PropertyEditor createPropertyEditor(Object bean) {
                    return numberPE;
                }
            };
            return new PropertyDescriptor[] { ageDescriptor };
        }
        catch (IntrospectionException ex) {
            throw new Error(ex.toString());
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class SomethingBeanInfo : SimpleBeanInfo() {

    override fun getPropertyDescriptors(): Array&lt;PropertyDescriptor&gt; {
        try {
            val numberPE = CustomNumberEditor(Int::class.java, true)
            val ageDescriptor = object : PropertyDescriptor("age", Something::class.java) {
                override fun createPropertyEditor(bean: Any): PropertyEditor {
                    return numberPE
                }
            }
            return arrayOf(ageDescriptor)
        } catch (ex: IntrospectionException) {
            throw Error(ex.toString())
        }

    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="beans-beans-conversion-customeditor-registration"><a class="anchor" href="#beans-beans-conversion-customeditor-registration"></a>Registering Additional Custom <code>PropertyEditor</code> Implementations</h5>
<div class="paragraph">
<p>When setting bean properties as string values, a Spring IoC container ultimately uses
standard JavaBeans <code>PropertyEditor</code> implementations to convert these strings to the complex type of the
property. Spring pre-registers a number of custom <code>PropertyEditor</code> implementations (for example, to
convert a class name expressed as a string into a <code>Class</code> object). Additionally,
Java&#8217;s standard JavaBeans <code>PropertyEditor</code> lookup mechanism lets a <code>PropertyEditor</code>
for a class be named appropriately and placed in the same package as the class
for which it provides support, so that it can be found automatically.</p>
</div>
<div class="paragraph">
<p>If there is a need to register other custom <code>PropertyEditors</code>, several mechanisms are
available. The most manual approach, which is not normally convenient or
recommended, is to use the <code>registerCustomEditor()</code> method of the
<code>ConfigurableBeanFactory</code> interface, assuming you have a <code>BeanFactory</code> reference.
Another (slightly more convenient) mechanism is to use a special bean factory
post-processor called <code>CustomEditorConfigurer</code>. Although you can use bean factory post-processors
with <code>BeanFactory</code> implementations, the <code>CustomEditorConfigurer</code> has a
nested property setup, so we strongly recommend that you use it with the
<code>ApplicationContext</code>, where you can deploy it in similar fashion to any other bean and
where it can be automatically detected and applied.</p>
</div>
<div class="paragraph">
<p>Note that all bean factories and application contexts automatically use a number of
built-in property editors, through their use of a <code>BeanWrapper</code> to
handle property conversions. The standard property editors that the <code>BeanWrapper</code>
registers are listed in the <a href="#beans-beans-conversion">previous section</a>.
Additionally, <code>ApplicationContexts</code> also override or add additional editors to handle
resource lookups in a manner appropriate to the specific application context type.</p>
</div>
<div class="paragraph">
<p>Standard JavaBeans <code>PropertyEditor</code> instances are used to convert property values
expressed as strings to the actual complex type of the property. You can use
<code>CustomEditorConfigurer</code>, a bean factory post-processor, to conveniently add
support for additional <code>PropertyEditor</code> instances to an <code>ApplicationContext</code>.</p>
</div>
<div class="paragraph">
<p>Consider the following example, which defines a user class called <code>ExoticType</code> and
another class called <code>DependsOnExoticType</code>, which needs <code>ExoticType</code> set as a property:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package example;

public class ExoticType {

    private String name;

    public ExoticType(String name) {
        this.name = name;
    }
}

public class DependsOnExoticType {

    private ExoticType type;

    public void setType(ExoticType type) {
        this.type = type;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package example

class ExoticType(val name: String)

class DependsOnExoticType {

    var type: ExoticType? = null
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When things are properly set up, we want to be able to assign the type property as a
string, which a <code>PropertyEditor</code> converts into an actual
<code>ExoticType</code> instance. The following bean definition shows how to set up this relationship:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="sample" class="example.DependsOnExoticType"&gt;
    &lt;property name="type" value="aNameForExoticType"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>PropertyEditor</code> implementation could look similar to the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// converts string representation to ExoticType object
package example;

public class ExoticTypeEditor extends PropertyEditorSupport {

    public void setAsText(String text) {
        setValue(new ExoticType(text.toUpperCase()));
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// converts string representation to ExoticType object
package example

import java.beans.PropertyEditorSupport

class ExoticTypeEditor : PropertyEditorSupport() {

    override fun setAsText(text: String) {
        value = ExoticType(text.toUpperCase())
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, the following example shows how to use <code>CustomEditorConfigurer</code> to register the new <code>PropertyEditor</code> with the
<code>ApplicationContext</code>, which will then be able to use it as needed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean class="org.springframework.beans.factory.config.CustomEditorConfigurer"&gt;
    &lt;property name="customEditors"&gt;
        &lt;map&gt;
            &lt;entry key="example.ExoticType" value="example.ExoticTypeEditor"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="beans-beans-conversion-customeditor-registration-per"><a class="anchor" href="#beans-beans-conversion-customeditor-registration-per"></a>Using <code>PropertyEditorRegistrar</code></h6>
<div class="paragraph">
<p>Another mechanism for registering property editors with the Spring container is to
create and use a <code>PropertyEditorRegistrar</code>. This interface is particularly useful when
you need to use the same set of property editors in several different situations.
You can write a corresponding registrar and reuse it in each case.
<code>PropertyEditorRegistrar</code> instances work in conjunction with an interface called
<code>PropertyEditorRegistry</code>, an interface that is implemented by the Spring <code>BeanWrapper</code>
(and <code>DataBinder</code>). <code>PropertyEditorRegistrar</code> instances are particularly convenient
when used in conjunction with <code>CustomEditorConfigurer</code> (described
<a href="#beans-beans-conversion-customeditor-registration">here</a>), which exposes a property
called <code>setPropertyEditorRegistrars(..)</code>. <code>PropertyEditorRegistrar</code> instances added
to a <code>CustomEditorConfigurer</code> in this fashion can easily be shared with <code>DataBinder</code> and
Spring MVC controllers. Furthermore, it avoids the need for synchronization on custom
editors: A <code>PropertyEditorRegistrar</code> is expected to create fresh <code>PropertyEditor</code>
instances for each bean creation attempt.</p>
</div>
<div class="paragraph">
<p>The following example shows how to create your own <code>PropertyEditorRegistrar</code> implementation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package com.foo.editors.spring;

public final class CustomPropertyEditorRegistrar implements PropertyEditorRegistrar {

    public void registerCustomEditors(PropertyEditorRegistry registry) {

        // it is expected that new PropertyEditor instances are created
        registry.registerCustomEditor(ExoticType.class, new ExoticTypeEditor());

        // you could register as many custom property editors as are required here...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package com.foo.editors.spring

import org.springframework.beans.PropertyEditorRegistrar
import org.springframework.beans.PropertyEditorRegistry

class CustomPropertyEditorRegistrar : PropertyEditorRegistrar {

    override fun registerCustomEditors(registry: PropertyEditorRegistry) {

        // it is expected that new PropertyEditor instances are created
        registry.registerCustomEditor(ExoticType::class.java, ExoticTypeEditor())

        // you could register as many custom property editors as are required here...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>See also the <code>org.springframework.beans.support.ResourceEditorRegistrar</code> for an example
<code>PropertyEditorRegistrar</code> implementation. Notice how in its implementation of the
<code>registerCustomEditors(..)</code> method ,it creates new instances of each property editor.</p>
</div>
<div class="paragraph">
<p>The next example shows how to configure a <code>CustomEditorConfigurer</code> and inject an instance of our
<code>CustomPropertyEditorRegistrar</code> into it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean class="org.springframework.beans.factory.config.CustomEditorConfigurer"&gt;
    &lt;property name="propertyEditorRegistrars"&gt;
        &lt;list&gt;
            &lt;ref bean="customPropertyEditorRegistrar"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="customPropertyEditorRegistrar"
    class="com.foo.editors.spring.CustomPropertyEditorRegistrar"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally (and in a bit of a departure from the focus of this chapter for those of you
using <a href="web.html#mvc">Spring&#8217;s MVC web framework</a>), using <code>PropertyEditorRegistrars</code> in
conjunction with data-binding <code>Controllers</code> (such as <code>SimpleFormController</code>) can be very
convenient. The following example uses a <code>PropertyEditorRegistrar</code> in the
implementation of an <code>initBinder(..)</code> method:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public final class RegisterUserController extends SimpleFormController {

    private final PropertyEditorRegistrar customPropertyEditorRegistrar;

    public RegisterUserController(PropertyEditorRegistrar propertyEditorRegistrar) {
        this.customPropertyEditorRegistrar = propertyEditorRegistrar;
    }

    protected void initBinder(HttpServletRequest request,
            ServletRequestDataBinder binder) throws Exception {
        this.customPropertyEditorRegistrar.registerCustomEditors(binder);
    }

    // other methods to do with registering a User
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class RegisterUserController(
    private val customPropertyEditorRegistrar: PropertyEditorRegistrar) : SimpleFormController() {

    protected fun initBinder(request: HttpServletRequest,
                            binder: ServletRequestDataBinder) {
        this.customPropertyEditorRegistrar.registerCustomEditors(binder)
    }

    // other methods to do with registering a User
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This style of <code>PropertyEditor</code> registration can lead to concise code (the implementation
of <code>initBinder(..)</code> is only one line long) and lets common <code>PropertyEditor</code>
registration code be encapsulated in a class and then shared amongst as many
<code>Controllers</code> as needed.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="core-convert"><a class="anchor" href="#core-convert"></a>3.4. Spring Type Conversion</h3>
<div class="paragraph">
<p>Spring 3 introduced a <code>core.convert</code> package that provides a general type conversion
system. The system defines an SPI to implement type conversion logic and an API
to perform type conversions at runtime. Within a Spring container, you can use this system
as an alternative to <code>PropertyEditor</code> implementations to convert externalized bean property value
strings to the required property types. You can also use the public API anywhere in your
application where type conversion is needed.</p>
</div>
<div class="sect3">
<h4 id="core-convert-Converter-API"><a class="anchor" href="#core-convert-Converter-API"></a>3.4.1. Converter SPI</h4>
<div class="paragraph">
<p>The SPI to implement type conversion logic is simple and strongly typed, as the following
interface definition shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package org.springframework.core.convert.converter;

public interface Converter&lt;S, T&gt; {

    T convert(S source);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To create your own converter, implement the <code>Converter</code> interface and parameterize <code>S</code>
as the type you are converting from and <code>T</code> as the type you are converting to. You can also transparently apply such a
converter if a collection or array of <code>S</code> needs to be
converted to an array or collection of <code>T</code>, provided that a delegating array or collection
converter has been registered as well (which <code>DefaultConversionService</code> does by default).</p>
</div>
<div class="paragraph">
<p>For each call to <code>convert(S)</code>, the source argument is guaranteed to not be null. Your
<code>Converter</code> may throw any unchecked exception if conversion fails. Specifically, it should throw an
<code>IllegalArgumentException</code> to report an invalid source value.
Take care to ensure that your <code>Converter</code> implementation is thread-safe.</p>
</div>
<div class="paragraph">
<p>Several converter implementations are provided in the <code>core.convert.support</code> package as
a convenience. These include converters from strings to numbers and other common types.
The following listing shows the <code>StringToInteger</code> class, which is a typical <code>Converter</code> implementation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package org.springframework.core.convert.support;

final class StringToInteger implements Converter&lt;String, Integer&gt; {

    public Integer convert(String source) {
        return Integer.valueOf(source);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-ConverterFactory-SPI"><a class="anchor" href="#core-convert-ConverterFactory-SPI"></a>3.4.2. Using <code>ConverterFactory</code></h4>
<div class="paragraph">
<p>When you need to centralize the conversion logic for an entire class hierarchy
(for example, when converting from <code>String</code> to <code>Enum</code> objects), you can implement
<code>ConverterFactory</code>, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package org.springframework.core.convert.converter;

public interface ConverterFactory&lt;S, R&gt; {

    &lt;T extends R&gt; Converter&lt;S, T&gt; getConverter(Class&lt;T&gt; targetType);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Parameterize S to be the type you are converting from and R to be the base type defining
the <em>range</em> of classes you can convert to. Then implement <code>getConverter(Class&lt;T&gt;)</code>,
where T is a subclass of R.</p>
</div>
<div class="paragraph">
<p>Consider the <code>StringToEnumConverterFactory</code> as an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package org.springframework.core.convert.support;

final class StringToEnumConverterFactory implements ConverterFactory&lt;String, Enum&gt; {

    public &lt;T extends Enum&gt; Converter&lt;String, T&gt; getConverter(Class&lt;T&gt; targetType) {
        return new StringToEnumConverter(targetType);
    }

    private final class StringToEnumConverter&lt;T extends Enum&gt; implements Converter&lt;String, T&gt; {

        private Class&lt;T&gt; enumType;

        public StringToEnumConverter(Class&lt;T&gt; enumType) {
            this.enumType = enumType;
        }

        public T convert(String source) {
            return (T) Enum.valueOf(this.enumType, source.trim());
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-GenericConverter-SPI"><a class="anchor" href="#core-convert-GenericConverter-SPI"></a>3.4.3. Using <code>GenericConverter</code></h4>
<div class="paragraph">
<p>When you require a sophisticated <code>Converter</code> implementation, consider using the
<code>GenericConverter</code> interface. With a more flexible but less strongly typed signature
than <code>Converter</code>, a <code>GenericConverter</code> supports converting between multiple source and
target types. In addition, a <code>GenericConverter</code> makes available source and target field
context that you can use when you implement your conversion logic. Such context lets a
type conversion be driven by a field annotation or by generic information declared on a
field signature. The following listing shows the interface definition of <code>GenericConverter</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package org.springframework.core.convert.converter;

public interface GenericConverter {

    public Set&lt;ConvertiblePair&gt; getConvertibleTypes();

    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To implement a <code>GenericConverter</code>, have <code>getConvertibleTypes()</code> return the supported
source&#8594;target type pairs. Then implement <code>convert(Object, TypeDescriptor,
TypeDescriptor)</code> to contain your conversion logic. The source <code>TypeDescriptor</code> provides
access to the source field that holds the value being converted. The target <code>TypeDescriptor</code>
provides access to the target field where the converted value is to be set.</p>
</div>
<div class="paragraph">
<p>A good example of a <code>GenericConverter</code> is a converter that converts between a Java array
and a collection. Such an <code>ArrayToCollectionConverter</code> introspects the field that declares
the target collection type to resolve the collection&#8217;s element type. This lets each
element in the source array be converted to the collection element type before the
collection is set on the target field.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Because <code>GenericConverter</code> is a more complex SPI interface, you should use
it only when you need it. Favor <code>Converter</code> or <code>ConverterFactory</code> for basic type
conversion needs.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="core-convert-ConditionalGenericConverter-SPI"><a class="anchor" href="#core-convert-ConditionalGenericConverter-SPI"></a>Using <code>ConditionalGenericConverter</code></h5>
<div class="paragraph">
<p>Sometimes, you want a <code>Converter</code> to run only if a specific condition holds true. For
example, you might want to run a <code>Converter</code> only if a specific annotation is present
on the target field, or you might want to run a <code>Converter</code> only if a specific method
(such as a <code>static valueOf</code> method) is defined on the target class.
<code>ConditionalGenericConverter</code> is the union of the <code>GenericConverter</code> and
<code>ConditionalConverter</code> interfaces that lets you define such custom matching criteria:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface ConditionalConverter {

    boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);
}

public interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A good example of a <code>ConditionalGenericConverter</code> is an <code>IdToEntityConverter</code> that converts
between a persistent entity identifier and an entity reference. Such an <code>IdToEntityConverter</code>
might match only if the target entity type declares a static finder method (for example,
<code>findAccount(Long)</code>). You might perform such a finder method check in the implementation of
<code>matches(TypeDescriptor, TypeDescriptor)</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-ConversionService-API"><a class="anchor" href="#core-convert-ConversionService-API"></a>3.4.4. The <code>ConversionService</code> API</h4>
<div class="paragraph">
<p><code>ConversionService</code> defines a unified API for executing type conversion logic at
runtime. Converters are often run behind the following facade interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package org.springframework.core.convert;

public interface ConversionService {

    boolean canConvert(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType);

    &lt;T&gt; T convert(Object source, Class&lt;T&gt; targetType);

    boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType);

    Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most <code>ConversionService</code> implementations also implement <code>ConverterRegistry</code>, which
provides an SPI for registering converters. Internally, a <code>ConversionService</code>
implementation delegates to its registered converters to carry out type conversion logic.</p>
</div>
<div class="paragraph">
<p>A robust <code>ConversionService</code> implementation is provided in the <code>core.convert.support</code>
package. <code>GenericConversionService</code> is the general-purpose implementation suitable for
use in most environments. <code>ConversionServiceFactory</code> provides a convenient factory for
creating common <code>ConversionService</code> configurations.</p>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-Spring-config"><a class="anchor" href="#core-convert-Spring-config"></a>3.4.5. Configuring a <code>ConversionService</code></h4>
<div class="paragraph">
<p>A <code>ConversionService</code> is a stateless object designed to be instantiated at application
startup and then shared between multiple threads. In a Spring application, you typically
configure a <code>ConversionService</code> instance for each Spring container (or <code>ApplicationContext</code>).
Spring picks up that <code>ConversionService</code> and uses it whenever a type
conversion needs to be performed by the framework. You can also inject this
<code>ConversionService</code> into any of your beans and invoke it directly.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If no <code>ConversionService</code> is registered with Spring, the original <code>PropertyEditor</code>-based
system is used.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To register a default <code>ConversionService</code> with Spring, add the following bean definition
with an <code>id</code> of <code>conversionService</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="conversionService"
    class="org.springframework.context.support.ConversionServiceFactoryBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>A default <code>ConversionService</code> can convert between strings, numbers, enums, collections,
maps, and other common types. To supplement or override the default converters with your
own custom converters, set the <code>converters</code> property. Property values can implement
any of the <code>Converter</code>, <code>ConverterFactory</code>, or <code>GenericConverter</code> interfaces.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="conversionService"
        class="org.springframework.context.support.ConversionServiceFactoryBean"&gt;
    &lt;property name="converters"&gt;
        &lt;set&gt;
            &lt;bean class="example.MyCustomConverter"/&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also common to use a <code>ConversionService</code> within a Spring MVC application. See
<a href="web.html#mvc-config-conversion">Conversion and Formatting</a> in the Spring MVC chapter.</p>
</div>
<div class="paragraph">
<p>In certain situations, you may wish to apply formatting during conversion. See
<a href="#format-FormatterRegistry-SPI">The <code>FormatterRegistry</code> SPI</a> for details on using <code>FormattingConversionServiceFactoryBean</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="core-convert-programmatic-usage"><a class="anchor" href="#core-convert-programmatic-usage"></a>3.4.6. Using a <code>ConversionService</code> Programmatically</h4>
<div class="paragraph">
<p>To work with a <code>ConversionService</code> instance programmatically, you can inject a reference to
it like you would for any other bean. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Service
public class MyService {

    public MyService(ConversionService conversionService) {
        this.conversionService = conversionService;
    }

    public void doIt() {
        this.conversionService.convert(...)
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Service
class MyService(private val conversionService: ConversionService) {

    fun doIt() {
        conversionService.convert(...)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For most use cases, you can use the <code>convert</code> method that specifies the <code>targetType</code>, but it
does not work with more complex types, such as a collection of a parameterized element.
For example, if you want to convert a <code>List</code> of <code>Integer</code> to a <code>List</code> of <code>String</code> programmatically,
you need to provide a formal definition of the source and target types.</p>
</div>
<div class="paragraph">
<p>Fortunately, <code>TypeDescriptor</code> provides various options to make doing so straightforward,
as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">DefaultConversionService cs = new DefaultConversionService();

List&lt;Integer&gt; input = ...
cs.convert(input,
    TypeDescriptor.forObject(input), // List&lt;Integer&gt; type descriptor
    TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class)));</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val cs = DefaultConversionService()

val input: List&lt;Integer&gt; = ...
cs.convert(input,
        TypeDescriptor.forObject(input), // List&lt;Integer&gt; type descriptor
        TypeDescriptor.collection(List::class.java, TypeDescriptor.valueOf(String::class.java)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that <code>DefaultConversionService</code> automatically registers converters that are
appropriate for most environments. This includes collection converters, scalar
converters, and basic <code>Object</code>-to-<code>String</code> converters. You can register the same converters
with any <code>ConverterRegistry</code> by using the static <code>addDefaultConverters</code>
method on the <code>DefaultConversionService</code> class.</p>
</div>
<div class="paragraph">
<p>Converters for value types are reused for arrays and collections, so there is
no need to create a specific converter to convert from a <code>Collection</code> of <code>S</code> to a
<code>Collection</code> of <code>T</code>, assuming that standard collection handling is appropriate.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="format"><a class="anchor" href="#format"></a>3.5. Spring Field Formatting</h3>
<div class="paragraph">
<p>As discussed in the previous section, <a href="#core-convert"><code>core.convert</code></a> is a
general-purpose type conversion system. It provides a unified <code>ConversionService</code> API as
well as a strongly typed <code>Converter</code> SPI for implementing conversion logic from one type
to another. A Spring container uses this system to bind bean property values. In
addition, both the Spring Expression Language (SpEL) and <code>DataBinder</code> use this system to
bind field values. For example, when SpEL needs to coerce a <code>Short</code> to a <code>Long</code> to
complete an <code>expression.setValue(Object bean, Object value)</code> attempt, the <code>core.convert</code>
system performs the coercion.</p>
</div>
<div class="paragraph">
<p>Now consider the type conversion requirements of a typical client environment, such as a
web or desktop application. In such environments, you typically convert from <code>String</code>
to support the client postback process, as well as back to <code>String</code> to support the
view rendering process. In addition, you often need to localize <code>String</code> values. The more
general <code>core.convert</code> <code>Converter</code> SPI does not address such formatting requirements
directly. To directly address them, Spring 3 introduced a convenient <code>Formatter</code> SPI that
provides a simple and robust alternative to <code>PropertyEditor</code> implementations for client environments.</p>
</div>
<div class="paragraph">
<p>In general, you can use the <code>Converter</code> SPI when you need to implement general-purpose type
conversion logic&#8201;&#8212;&#8201;for example, for converting between a <code>java.util.Date</code> and a <code>Long</code>.
You can use the <code>Formatter</code> SPI when you work in a client environment (such as a web
application) and need to parse and print localized field values. The <code>ConversionService</code>
provides a unified type conversion API for both SPIs.</p>
</div>
<div class="sect3">
<h4 id="format-Formatter-SPI"><a class="anchor" href="#format-Formatter-SPI"></a>3.5.1. The <code>Formatter</code> SPI</h4>
<div class="paragraph">
<p>The <code>Formatter</code> SPI to implement field formatting logic is simple and strongly typed. The
following listing shows the <code>Formatter</code> interface definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package org.springframework.format;

public interface Formatter&lt;T&gt; extends Printer&lt;T&gt;, Parser&lt;T&gt; {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Formatter</code> extends from the <code>Printer</code> and <code>Parser</code> building-block interfaces. The
following listing shows the definitions of those two interfaces:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface Printer&lt;T&gt; {

    String print(T fieldValue, Locale locale);
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import java.text.ParseException;

public interface Parser&lt;T&gt; {

    T parse(String clientValue, Locale locale) throws ParseException;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To create your own <code>Formatter</code>, implement the <code>Formatter</code> interface shown earlier.
Parameterize <code>T</code> to be the type of object you wish to format&#8201;&#8212;&#8201;for example,
<code>java.util.Date</code>. Implement the <code>print()</code> operation to print an instance of <code>T</code> for
display in the client locale. Implement the <code>parse()</code> operation to parse an instance of
<code>T</code> from the formatted representation returned from the client locale. Your <code>Formatter</code>
should throw a <code>ParseException</code> or an <code>IllegalArgumentException</code> if a parse attempt fails. Take
care to ensure that your <code>Formatter</code> implementation is thread-safe.</p>
</div>
<div class="paragraph">
<p>The <code>format</code> subpackages provide several <code>Formatter</code> implementations as a convenience.
The <code>number</code> package provides <code>NumberStyleFormatter</code>, <code>CurrencyStyleFormatter</code>, and
<code>PercentStyleFormatter</code> to format <code>Number</code> objects that use a <code>java.text.NumberFormat</code>.
The <code>datetime</code> package provides a <code>DateFormatter</code> to format <code>java.util.Date</code> objects with
a <code>java.text.DateFormat</code>.</p>
</div>
<div class="paragraph">
<p>The following <code>DateFormatter</code> is an example <code>Formatter</code> implementation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package org.springframework.format.datetime;

public final class DateFormatter implements Formatter&lt;Date&gt; {

    private String pattern;

    public DateFormatter(String pattern) {
        this.pattern = pattern;
    }

    public String print(Date date, Locale locale) {
        if (date == null) {
            return "";
        }
        return getDateFormat(locale).format(date);
    }

    public Date parse(String formatted, Locale locale) throws ParseException {
        if (formatted.length() == 0) {
            return null;
        }
        return getDateFormat(locale).parse(formatted);
    }

    protected DateFormat getDateFormat(Locale locale) {
        DateFormat dateFormat = new SimpleDateFormat(this.pattern, locale);
        dateFormat.setLenient(false);
        return dateFormat;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class DateFormatter(private val pattern: String) : Formatter&lt;Date&gt; {

    override fun print(date: Date, locale: Locale)
            = getDateFormat(locale).format(date)

    @Throws(ParseException::class)
    override fun parse(formatted: String, locale: Locale)
            = getDateFormat(locale).parse(formatted)

    protected fun getDateFormat(locale: Locale): DateFormat {
        val dateFormat = SimpleDateFormat(this.pattern, locale)
        dateFormat.isLenient = false
        return dateFormat
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Spring team welcomes community-driven <code>Formatter</code> contributions. See
<a href="https://github.com/spring-projects/spring-framework/issues">GitHub Issues</a> to contribute.</p>
</div>
</div>
<div class="sect3">
<h4 id="format-CustomFormatAnnotations"><a class="anchor" href="#format-CustomFormatAnnotations"></a>3.5.2. Annotation-driven Formatting</h4>
<div class="paragraph">
<p>Field formatting can be configured by field type or annotation. To bind
an annotation to a <code>Formatter</code>, implement <code>AnnotationFormatterFactory</code>. The following
listing shows the definition of the <code>AnnotationFormatterFactory</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package org.springframework.format;

public interface AnnotationFormatterFactory&lt;A extends Annotation&gt; {

    Set&lt;Class&lt;?&gt;&gt; getFieldTypes();

    Printer&lt;?&gt; getPrinter(A annotation, Class&lt;?&gt; fieldType);

    Parser&lt;?&gt; getParser(A annotation, Class&lt;?&gt; fieldType);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To create an implementation:
. Parameterize A to be the field <code>annotationType</code> with which you wish to associate
formatting logic&#8201;&#8212;&#8201;for example <code>org.springframework.format.annotation.DateTimeFormat</code>.
. Have <code>getFieldTypes()</code> return the types of fields on which the annotation can be used.
. Have <code>getPrinter()</code> return a <code>Printer</code> to print the value of an annotated field.
. Have <code>getParser()</code> return a <code>Parser</code> to parse a <code>clientValue</code> for an annotated field.</p>
</div>
<div class="paragraph">
<p>The following example <code>AnnotationFormatterFactory</code> implementation binds the <code>@NumberFormat</code>
annotation to a formatter to let a number style or pattern be
specified:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public final class NumberFormatAnnotationFormatterFactory
        implements AnnotationFormatterFactory&lt;NumberFormat&gt; {

    public Set&lt;Class&lt;?&gt;&gt; getFieldTypes() {
        return new HashSet&lt;Class&lt;?&gt;&gt;(asList(new Class&lt;?&gt;[] {
            Short.class, Integer.class, Long.class, Float.class,
            Double.class, BigDecimal.class, BigInteger.class }));
    }

    public Printer&lt;Number&gt; getPrinter(NumberFormat annotation, Class&lt;?&gt; fieldType) {
        return configureFormatterFrom(annotation, fieldType);
    }

    public Parser&lt;Number&gt; getParser(NumberFormat annotation, Class&lt;?&gt; fieldType) {
        return configureFormatterFrom(annotation, fieldType);
    }

    private Formatter&lt;Number&gt; configureFormatterFrom(NumberFormat annotation, Class&lt;?&gt; fieldType) {
        if (!annotation.pattern().isEmpty()) {
            return new NumberStyleFormatter(annotation.pattern());
        } else {
            Style style = annotation.style();
            if (style == Style.PERCENT) {
                return new PercentStyleFormatter();
            } else if (style == Style.CURRENCY) {
                return new CurrencyStyleFormatter();
            } else {
                return new NumberStyleFormatter();
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class NumberFormatAnnotationFormatterFactory : AnnotationFormatterFactory&lt;NumberFormat&gt; {

    override fun getFieldTypes(): Set&lt;Class&lt;*&gt;&gt; {
        return setOf(Short::class.java, Int::class.java, Long::class.java, Float::class.java, Double::class.java, BigDecimal::class.java, BigInteger::class.java)
    }

    override fun getPrinter(annotation: NumberFormat, fieldType: Class&lt;*&gt;): Printer&lt;Number&gt; {
        return configureFormatterFrom(annotation, fieldType)
    }

    override fun getParser(annotation: NumberFormat, fieldType: Class&lt;*&gt;): Parser&lt;Number&gt; {
        return configureFormatterFrom(annotation, fieldType)
    }

    private fun configureFormatterFrom(annotation: NumberFormat, fieldType: Class&lt;*&gt;): Formatter&lt;Number&gt; {
        return if (annotation.pattern.isNotEmpty()) {
            NumberStyleFormatter(annotation.pattern)
        } else {
            val style = annotation.style
            when {
                style === NumberFormat.Style.PERCENT -&gt; PercentStyleFormatter()
                style === NumberFormat.Style.CURRENCY -&gt; CurrencyStyleFormatter()
                else -&gt; NumberStyleFormatter()
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To trigger formatting, you can annotate fields with @NumberFormat, as the following
example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class MyModel {

    @NumberFormat(style=Style.CURRENCY)
    private BigDecimal decimal;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class MyModel(
    @field:NumberFormat(style = Style.CURRENCY) private val decimal: BigDecimal
)</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="format-annotations-api"><a class="anchor" href="#format-annotations-api"></a>Format Annotation API</h5>
<div class="paragraph">
<p>A portable format annotation API exists in the <code>org.springframework.format.annotation</code>
package. You can use <code>@NumberFormat</code> to format <code>Number</code> fields such as <code>Double</code> and
<code>Long</code>, and <code>@DateTimeFormat</code> to format <code>java.util.Date</code>, <code>java.util.Calendar</code>, <code>Long</code>
(for millisecond timestamps) as well as JSR-310 <code>java.time</code>.</p>
</div>
<div class="paragraph">
<p>The following example uses <code>@DateTimeFormat</code> to format a <code>java.util.Date</code> as an ISO Date
(yyyy-MM-dd):</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class MyModel {

    @DateTimeFormat(iso=ISO.DATE)
    private Date date;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class MyModel(
    @DateTimeFormat(iso= ISO.DATE) private val date: Date
)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="format-FormatterRegistry-SPI"><a class="anchor" href="#format-FormatterRegistry-SPI"></a>3.5.3. The <code>FormatterRegistry</code> SPI</h4>
<div class="paragraph">
<p>The <code>FormatterRegistry</code> is an SPI for registering formatters and converters.
<code>FormattingConversionService</code> is an implementation of <code>FormatterRegistry</code> suitable for
most environments. You can programmatically or declaratively configure this variant
as a Spring bean, e.g. by using <code>FormattingConversionServiceFactoryBean</code>. Because this
implementation also implements <code>ConversionService</code>, you can directly configure it
for use with Spring&#8217;s <code>DataBinder</code> and the Spring Expression Language (SpEL).</p>
</div>
<div class="paragraph">
<p>The following listing shows the <code>FormatterRegistry</code> SPI:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package org.springframework.format;

public interface FormatterRegistry extends ConverterRegistry {

    void addPrinter(Printer&lt;?&gt; printer);

    void addParser(Parser&lt;?&gt; parser);

    void addFormatter(Formatter&lt;?&gt; formatter);

    void addFormatterForFieldType(Class&lt;?&gt; fieldType, Formatter&lt;?&gt; formatter);

    void addFormatterForFieldType(Class&lt;?&gt; fieldType, Printer&lt;?&gt; printer, Parser&lt;?&gt; parser);

    void addFormatterForFieldAnnotation(AnnotationFormatterFactory&lt;? extends Annotation&gt; annotationFormatterFactory);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As shown in the preceding listing, you can register formatters by field type or by annotation.</p>
</div>
<div class="paragraph">
<p>The <code>FormatterRegistry</code> SPI lets you configure formatting rules centrally, instead of
duplicating such configuration across your controllers. For example, you might want to
enforce that all date fields are formatted a certain way or that fields with a specific
annotation are formatted in a certain way. With a shared <code>FormatterRegistry</code>, you define
these rules once, and they are applied whenever formatting is needed.</p>
</div>
</div>
<div class="sect3">
<h4 id="format-FormatterRegistrar-SPI"><a class="anchor" href="#format-FormatterRegistrar-SPI"></a>3.5.4. The <code>FormatterRegistrar</code> SPI</h4>
<div class="paragraph">
<p><code>FormatterRegistrar</code> is an SPI for registering formatters and converters through the
FormatterRegistry. The following listing shows its interface definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package org.springframework.format;

public interface FormatterRegistrar {

    void registerFormatters(FormatterRegistry registry);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>FormatterRegistrar</code> is useful when registering multiple related converters and
formatters for a given formatting category, such as date formatting. It can also be
useful where declarative registration is insufficient&#8201;&#8212;&#8201;for example, when a formatter
needs to be indexed under a specific field type different from its own <code>&lt;T&gt;</code> or when
registering a <code>Printer</code>/<code>Parser</code> pair. The next section provides more information on
converter and formatter registration.</p>
</div>
</div>
<div class="sect3">
<h4 id="format-configuring-formatting-mvc"><a class="anchor" href="#format-configuring-formatting-mvc"></a>3.5.5. Configuring Formatting in Spring MVC</h4>
<div class="paragraph">
<p>See <a href="web.html#mvc-config-conversion">Conversion and Formatting</a> in the Spring MVC chapter.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="format-configuring-formatting-globaldatetimeformat"><a class="anchor" href="#format-configuring-formatting-globaldatetimeformat"></a>3.6. Configuring a Global Date and Time Format</h3>
<div class="paragraph">
<p>By default, date and time fields not annotated with <code>@DateTimeFormat</code> are converted from
strings by using the <code>DateFormat.SHORT</code> style. If you prefer, you can change this by
defining your own global format.</p>
</div>
<div class="paragraph">
<p>To do that, ensure that Spring does not register default formatters. Instead, register
formatters manually with the help of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.springframework.format.datetime.standard.DateTimeFormatterRegistrar</code></p>
</li>
<li>
<p><code>org.springframework.format.datetime.DateFormatterRegistrar</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, the following Java configuration registers a global <code>yyyyMMdd</code> format:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
public class AppConfig {

    @Bean
    public FormattingConversionService conversionService() {

        // Use the DefaultFormattingConversionService but do not register defaults
        DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService(false);

        // Ensure @NumberFormat is still supported
        conversionService.addFormatterForFieldAnnotation(new NumberFormatAnnotationFormatterFactory());

        // Register JSR-310 date conversion with a specific global format
        DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar();
        registrar.setDateFormatter(DateTimeFormatter.ofPattern("yyyyMMdd"));
        registrar.registerFormatters(conversionService);

        // Register date conversion with a specific global format
        DateFormatterRegistrar registrar = new DateFormatterRegistrar();
        registrar.setFormatter(new DateFormatter("yyyyMMdd"));
        registrar.registerFormatters(conversionService);

        return conversionService;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
class AppConfig {

    @Bean
    fun conversionService(): FormattingConversionService {
        // Use the DefaultFormattingConversionService but do not register defaults
        return DefaultFormattingConversionService(false).apply {

            // Ensure @NumberFormat is still supported
            addFormatterForFieldAnnotation(NumberFormatAnnotationFormatterFactory())

            // Register JSR-310 date conversion with a specific global format
            val registrar = DateTimeFormatterRegistrar()
            registrar.setDateFormatter(DateTimeFormatter.ofPattern("yyyyMMdd"))
            registrar.registerFormatters(this)

            // Register date conversion with a specific global format
            val registrar = DateFormatterRegistrar()
            registrar.setFormatter(DateFormatter("yyyyMMdd"))
            registrar.registerFormatters(this)
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you prefer XML-based configuration, you can use a
<code>FormattingConversionServiceFactoryBean</code>. The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&gt;

    &lt;bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt;
        &lt;property name="registerDefaultFormatters" value="false" /&gt;
        &lt;property name="formatters"&gt;
            &lt;set&gt;
                &lt;bean class="org.springframework.format.number.NumberFormatAnnotationFormatterFactory" /&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        &lt;property name="formatterRegistrars"&gt;
            &lt;set&gt;
                &lt;bean class="org.springframework.format.datetime.standard.DateTimeFormatterRegistrar"&gt;
                    &lt;property name="dateFormatter"&gt;
                        &lt;bean class="org.springframework.format.datetime.standard.DateTimeFormatterFactoryBean"&gt;
                            &lt;property name="pattern" value="yyyyMMdd"/&gt;
                        &lt;/bean&gt;
                    &lt;/property&gt;
                &lt;/bean&gt;
            &lt;/set&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note there are extra considerations when configuring date and time formats in web
applications. Please see
<a href="web.html#mvc-config-conversion">WebMVC Conversion and Formatting</a> or
<a href="web-reactive.html#webflux-config-conversion">WebFlux Conversion and Formatting</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="validation-beanvalidation"><a class="anchor" href="#validation-beanvalidation"></a>3.7. Java Bean Validation</h3>
<div class="paragraph">
<p>The Spring Framework provides support for the
<a href="https://beanvalidation.org/">Java Bean Validation</a> API.</p>
</div>
<div class="sect3">
<h4 id="validation-beanvalidation-overview"><a class="anchor" href="#validation-beanvalidation-overview"></a>3.7.1. Overview of Bean Validation</h4>
<div class="paragraph">
<p>Bean Validation provides a common way of validation through constraint declaration and
metadata for Java applications. To use it, you annotate domain model properties with
declarative validation constraints which are then enforced by the runtime. There are
built-in constraints, and you can also define your own custom constraints.</p>
</div>
<div class="paragraph">
<p>Consider the following example, which shows a simple <code>PersonForm</code> model with two properties:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class PersonForm {
    private String name;
    private int age;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class PersonForm(
        private val name: String,
        private val age: Int
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Bean Validation lets you declare constraints as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class PersonForm {

    @NotNull
    @Size(max=64)
    private String name;

    @Min(0)
    private int age;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class PersonForm(
    @get:NotNull @get:Size(max=64)
    private val name: String,
    @get:Min(0)
    private val age: Int
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A Bean Validation validator then validates instances of this class based on the declared
constraints. See <a href="https://beanvalidation.org/">Bean Validation</a> for general information about
the API. See the <a href="https://hibernate.org/validator/">Hibernate Validator</a> documentation for
specific constraints. To learn how to set up a bean validation provider as a Spring
bean, keep reading.</p>
</div>
</div>
<div class="sect3">
<h4 id="validation-beanvalidation-spring"><a class="anchor" href="#validation-beanvalidation-spring"></a>3.7.2. Configuring a Bean Validation Provider</h4>
<div class="paragraph">
<p>Spring provides full support for the Bean Validation API including the bootstrapping of a
Bean Validation provider as a Spring bean. This lets you inject a
<code>javax.validation.ValidatorFactory</code> or <code>javax.validation.Validator</code> wherever validation is
needed in your application.</p>
</div>
<div class="paragraph">
<p>You can use the <code>LocalValidatorFactoryBean</code> to configure a default Validator as a Spring
bean, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import org.springframework.validation.beanvalidation.LocalValidatorFactoryBean;

@Configuration
public class AppConfig {

    @Bean
    public LocalValidatorFactoryBean validator() {
        return new LocalValidatorFactoryBean();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="validator"
    class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The basic configuration in the preceding example triggers bean validation to initialize by
using its default bootstrap mechanism. A Bean Validation provider, such as the Hibernate
Validator, is expected to be present in the classpath and is automatically detected.</p>
</div>
<div class="sect4">
<h5 id="validation-beanvalidation-spring-inject"><a class="anchor" href="#validation-beanvalidation-spring-inject"></a>Injecting a Validator</h5>
<div class="paragraph">
<p><code>LocalValidatorFactoryBean</code> implements both <code>javax.validation.ValidatorFactory</code> and
<code>javax.validation.Validator</code>, as well as Spring&#8217;s <code>org.springframework.validation.Validator</code>.
You can inject a reference to either of these interfaces into beans that need to invoke
validation logic.</p>
</div>
<div class="paragraph">
<p>You can inject a reference to <code>javax.validation.Validator</code> if you prefer to work with the Bean
Validation API directly, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import javax.validation.Validator;

@Service
public class MyService {

    @Autowired
    private Validator validator;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import javax.validation.Validator;

@Service
class MyService(@Autowired private val validator: Validator)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can inject a reference to <code>org.springframework.validation.Validator</code> if your bean
requires the Spring Validation API, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import org.springframework.validation.Validator;

@Service
public class MyService {

    @Autowired
    private Validator validator;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.springframework.validation.Validator

@Service
class MyService(@Autowired private val validator: Validator)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="validation-beanvalidation-spring-constraints"><a class="anchor" href="#validation-beanvalidation-spring-constraints"></a>Configuring Custom Constraints</h5>
<div class="paragraph">
<p>Each bean validation constraint consists of two parts:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>@Constraint</code> annotation that declares the constraint and its configurable properties.</p>
</li>
<li>
<p>An implementation of the <code>javax.validation.ConstraintValidator</code> interface that implements
the constraint&#8217;s behavior.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To associate a declaration with an implementation, each <code>@Constraint</code> annotation
references a corresponding <code>ConstraintValidator</code> implementation class. At runtime, a
<code>ConstraintValidatorFactory</code> instantiates the referenced implementation when the
constraint annotation is encountered in your domain model.</p>
</div>
<div class="paragraph">
<p>By default, the <code>LocalValidatorFactoryBean</code> configures a <code>SpringConstraintValidatorFactory</code>
that uses Spring to create <code>ConstraintValidator</code> instances. This lets your custom
<code>ConstraintValidators</code> benefit from dependency injection like any other Spring bean.</p>
</div>
<div class="paragraph">
<p>The following example shows a custom <code>@Constraint</code> declaration followed by an associated
<code>ConstraintValidator</code> implementation that uses Spring for dependency injection:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Target({ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy=MyConstraintValidator.class)
public @interface MyConstraint {
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Target(AnnotationTarget.FUNCTION, AnnotationTarget.FIELD)
@Retention(AnnotationRetention.RUNTIME)
@Constraint(validatedBy = MyConstraintValidator::class)
annotation class MyConstraint</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import javax.validation.ConstraintValidator;

public class MyConstraintValidator implements ConstraintValidator {

    @Autowired;
    private Foo aDependency;

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import javax.validation.ConstraintValidator

class MyConstraintValidator(private val aDependency: Foo) : ConstraintValidator {

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As the preceding example shows, a <code>ConstraintValidator</code> implementation can have its dependencies
<code>@Autowired</code> as any other Spring bean.</p>
</div>
</div>
<div class="sect4">
<h5 id="validation-beanvalidation-spring-method"><a class="anchor" href="#validation-beanvalidation-spring-method"></a>Spring-driven Method Validation</h5>
<div class="paragraph">
<p>You can integrate the method validation feature supported by Bean Validation 1.1 (and, as
a custom extension, also by Hibernate Validator 4.3) into a Spring context through a
<code>MethodValidationPostProcessor</code> bean definition:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import org.springframework.validation.beanvalidation.MethodValidationPostProcessor;

@Configuration
public class AppConfig {

    @Bean
    public MethodValidationPostProcessor validationPostProcessor() {
        return new MethodValidationPostProcessor();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean class="org.springframework.validation.beanvalidation.MethodValidationPostProcessor"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To be eligible for Spring-driven method validation, all target classes need to be annotated
with Spring&#8217;s <code>@Validated</code> annotation, which can optionally also declare the validation
groups to use. See
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/validation/beanvalidation/MethodValidationPostProcessor.html"><code>MethodValidationPostProcessor</code></a>
for setup details with the Hibernate Validator and Bean Validation 1.1 providers.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Method validation relies on <a href="#aop-introduction-proxies">AOP Proxies</a> around the
target classes, either JDK dynamic proxies for methods on interfaces or CGLIB proxies.
There are certain limitations with the use of proxies, some of which are described in
<a href="#aop-understanding-aop-proxies">Understanding AOP Proxies</a>. In addition remember
to always use methods and accessors on proxied classes; direct field access will not work.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="validation-beanvalidation-spring-other"><a class="anchor" href="#validation-beanvalidation-spring-other"></a>Additional Configuration Options</h5>
<div class="paragraph">
<p>The default <code>LocalValidatorFactoryBean</code> configuration suffices for most
cases. There are a number of configuration options for various Bean Validation
constructs, from message interpolation to traversal resolution. See the
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/validation/beanvalidation/LocalValidatorFactoryBean.html"><code>LocalValidatorFactoryBean</code></a>
javadoc for more information on these options.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="validation-binder"><a class="anchor" href="#validation-binder"></a>3.7.3. Configuring a <code>DataBinder</code></h4>
<div class="paragraph">
<p>Since Spring 3, you can configure a <code>DataBinder</code> instance with a <code>Validator</code>. Once
configured, you can invoke the <code>Validator</code> by calling <code>binder.validate()</code>. Any validation
<code>Errors</code> are automatically added to the binder&#8217;s <code>BindingResult</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows how to use a <code>DataBinder</code> programmatically to invoke validation
logic after binding to a target object:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Foo target = new Foo();
DataBinder binder = new DataBinder(target);
binder.setValidator(new FooValidator());

// bind to the target object
binder.bind(propertyValues);

// validate the target object
binder.validate();

// get BindingResult that includes any validation errors
BindingResult results = binder.getBindingResult();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val target = Foo()
val binder = DataBinder(target)
binder.validator = FooValidator()

// bind to the target object
binder.bind(propertyValues)

// validate the target object
binder.validate()

// get BindingResult that includes any validation errors
val results = binder.bindingResult</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also configure a <code>DataBinder</code> with multiple <code>Validator</code> instances through
<code>dataBinder.addValidators</code> and <code>dataBinder.replaceValidators</code>. This is useful when
combining globally configured bean validation with a Spring <code>Validator</code> configured
locally on a DataBinder instance. See
<a href="web.html#mvc-config-validation">Spring MVC Validation Configuration</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="validation-mvc"><a class="anchor" href="#validation-mvc"></a>3.7.4. Spring MVC 3 Validation</h4>
<div class="paragraph">
<p>See <a href="web.html#mvc-config-validation">Validation</a> in the Spring MVC chapter.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="expressions"><a class="anchor" href="#expressions"></a>4. Spring Expression Language (SpEL)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Spring Expression Language (&#8220;SpEL&#8221; for short) is a powerful expression language that
supports querying and manipulating an object graph at runtime. The language syntax is
similar to Unified EL but offers additional features, most notably method invocation and
basic string templating functionality.</p>
</div>
<div class="paragraph">
<p>While there are several other Java expression languages available&#8201;&#8212;&#8201;OGNL, MVEL, and JBoss
EL, to name a few&#8201;&#8212;&#8201;the Spring Expression Language was created to provide the Spring
community with a single well supported expression language that can be used across all
the products in the Spring portfolio. Its language features are driven by the
requirements of the projects in the Spring portfolio, including tooling requirements
for code completion support within the <a href="https://spring.io/tools">Spring Tools for Eclipse</a>.
That said, SpEL is based on a technology-agnostic API that lets other expression language
implementations be integrated, should the need arise.</p>
</div>
<div class="paragraph">
<p>While SpEL serves as the foundation for expression evaluation within the Spring
portfolio, it is not directly tied to Spring and can be used independently. To
be self contained, many of the examples in this chapter use SpEL as if it were an
independent expression language. This requires creating a few bootstrapping
infrastructure classes, such as the parser. Most Spring users need not deal with
this infrastructure and can, instead, author only expression strings for evaluation.
An example of this typical use is the integration of SpEL into creating XML or
annotation-based bean definitions, as shown in
<a href="#expressions-beandef">Expression support for defining bean definitions</a>.</p>
</div>
<div class="paragraph">
<p>This chapter covers the features of the expression language, its API, and its language
syntax. In several places, <code>Inventor</code> and <code>Society</code> classes are used as the target
objects for expression evaluation. These class declarations and the data used to
populate them are listed at the end of the chapter.</p>
</div>
<div class="paragraph">
<p>The expression language supports the following functionality:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Literal expressions</p>
</li>
<li>
<p>Boolean and relational operators</p>
</li>
<li>
<p>Regular expressions</p>
</li>
<li>
<p>Class expressions</p>
</li>
<li>
<p>Accessing properties, arrays, lists, and maps</p>
</li>
<li>
<p>Method invocation</p>
</li>
<li>
<p>Relational operators</p>
</li>
<li>
<p>Assignment</p>
</li>
<li>
<p>Calling constructors</p>
</li>
<li>
<p>Bean references</p>
</li>
<li>
<p>Array construction</p>
</li>
<li>
<p>Inline lists</p>
</li>
<li>
<p>Inline maps</p>
</li>
<li>
<p>Ternary operator</p>
</li>
<li>
<p>Variables</p>
</li>
<li>
<p>User-defined functions</p>
</li>
<li>
<p>Collection projection</p>
</li>
<li>
<p>Collection selection</p>
</li>
<li>
<p>Templated expressions</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="expressions-evaluation"><a class="anchor" href="#expressions-evaluation"></a>4.1. Evaluation</h3>
<div class="paragraph">
<p>This section introduces the simple use of SpEL interfaces and its expression language.
The complete language reference can be found in
<a href="#expressions-language-ref">Language Reference</a>.</p>
</div>
<div class="paragraph">
<p>The following code introduces the SpEL API to evaluate the literal string expression,
<code>Hello World</code>.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression("'Hello World'"); <i class="conum" data-value="1"></i><b>(1)</b>
String message = (String) exp.getValue();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The value of the message variable is <code>'Hello World'</code>.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val parser = SpelExpressionParser()
val exp = parser.parseExpression("'Hello World'") <i class="conum" data-value="1"></i><b>(1)</b>
val message = exp.value as String</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The value of the message variable is <code>'Hello World'</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The SpEL classes and interfaces you are most likely to use are located in the
<code>org.springframework.expression</code> package and its sub-packages, such as <code>spel.support</code>.</p>
</div>
<div class="paragraph">
<p>The <code>ExpressionParser</code> interface is responsible for parsing an expression string. In
the preceding example, the expression string is a string literal denoted by the surrounding single
quotation marks. The <code>Expression</code> interface is responsible for evaluating the previously defined
expression string. Two exceptions that can be thrown, <code>ParseException</code> and
<code>EvaluationException</code>, when calling <code>parser.parseExpression</code> and <code>exp.getValue</code>,
respectively.</p>
</div>
<div class="paragraph">
<p>SpEL supports a wide range of features, such as calling methods, accessing properties,
and calling constructors.</p>
</div>
<div class="paragraph">
<p>In the following example of method invocation, we call the <code>concat</code> method on the string literal:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression("'Hello World'.concat('!')"); <i class="conum" data-value="1"></i><b>(1)</b>
String message = (String) exp.getValue();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The value of <code>message</code> is now 'Hello World!'.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val parser = SpelExpressionParser()
val exp = parser.parseExpression("'Hello World'.concat('!')") <i class="conum" data-value="1"></i><b>(1)</b>
val message = exp.value as String</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The value of <code>message</code> is now 'Hello World!'.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example of calling a JavaBean property calls the <code>String</code> property <code>Bytes</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ExpressionParser parser = new SpelExpressionParser();

// invokes 'getBytes()'
Expression exp = parser.parseExpression("'Hello World'.bytes"); <i class="conum" data-value="1"></i><b>(1)</b>
byte[] bytes = (byte[]) exp.getValue();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This line converts the literal to a byte array.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val parser = SpelExpressionParser()

// invokes 'getBytes()'
val exp = parser.parseExpression("'Hello World'.bytes") <i class="conum" data-value="1"></i><b>(1)</b>
val bytes = exp.value as ByteArray</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This line converts the literal to a byte array.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>SpEL also supports nested properties by using the standard dot notation (such as
<code>prop1.prop2.prop3</code>) and also the corresponding setting of property values.
Public fields may also be accessed.</p>
</div>
<div class="paragraph">
<p>The following example shows how to use dot notation to get the length of a literal:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ExpressionParser parser = new SpelExpressionParser();

// invokes 'getBytes().length'
Expression exp = parser.parseExpression("'Hello World'.bytes.length"); <i class="conum" data-value="1"></i><b>(1)</b>
int length = (Integer) exp.getValue();</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>'Hello World'.bytes.length</code> gives the length of the literal.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val parser = SpelExpressionParser()

// invokes 'getBytes().length'
val exp = parser.parseExpression("'Hello World'.bytes.length") <i class="conum" data-value="1"></i><b>(1)</b>
val length = exp.value as Int</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>'Hello World'.bytes.length</code> gives the length of the literal.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The String&#8217;s constructor can be called instead of using a string literal, as the following
example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression("new String('hello world').toUpperCase()"); <i class="conum" data-value="1"></i><b>(1)</b>
String message = exp.getValue(String.class);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Construct a new <code>String</code> from the literal and make it be upper case.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val parser = SpelExpressionParser()
val exp = parser.parseExpression("new String('hello world').toUpperCase()")  <i class="conum" data-value="1"></i><b>(1)</b>
val message = exp.getValue(String::class.java)</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Construct a new <code>String</code> from the literal and make it be upper case.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note the use of the generic method: <code>public &lt;T&gt; T getValue(Class&lt;T&gt; desiredResultType)</code>.
Using this method removes the need to cast the value of the expression to the desired
result type. An <code>EvaluationException</code> is thrown if the value cannot be cast to the
type <code>T</code> or converted by using the registered type converter.</p>
</div>
<div class="paragraph">
<p>The more common usage of SpEL is to provide an expression string that is evaluated
against a specific object instance (called the root object). The following example shows
how to retrieve the <code>name</code> property from an instance of the <code>Inventor</code> class or
create a boolean condition:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// Create and set a calendar
GregorianCalendar c = new GregorianCalendar();
c.set(1856, 7, 9);

// The constructor arguments are name, birthday, and nationality.
Inventor tesla = new Inventor("Nikola Tesla", c.getTime(), "Serbian");

ExpressionParser parser = new SpelExpressionParser();

Expression exp = parser.parseExpression("name"); // Parse name as an expression
String name = (String) exp.getValue(tesla);
// name == "Nikola Tesla"

exp = parser.parseExpression("name == 'Nikola Tesla'");
boolean result = exp.getValue(tesla, Boolean.class);
// result == true</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Create and set a calendar
val c = GregorianCalendar()
c.set(1856, 7, 9)

// The constructor arguments are name, birthday, and nationality.
val tesla = Inventor("Nikola Tesla", c.time, "Serbian")

val parser = SpelExpressionParser()

var exp = parser.parseExpression("name") // Parse name as an expression
val name = exp.getValue(tesla) as String
// name == "Nikola Tesla"

exp = parser.parseExpression("name == 'Nikola Tesla'")
val result = exp.getValue(tesla, Boolean::class.java)
// result == true</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="expressions-evaluation-context"><a class="anchor" href="#expressions-evaluation-context"></a>4.1.1. Understanding <code>EvaluationContext</code></h4>
<div class="paragraph">
<p>The <code>EvaluationContext</code> interface is used when evaluating an expression to resolve
properties, methods, or fields and to help perform type conversion. Spring provides two
implementations.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SimpleEvaluationContext</code>: Exposes a subset of essential SpEL language features and
configuration options, for categories of expressions that do not require the full extent
of the SpEL language syntax and should be meaningfully restricted. Examples include but
are not limited to data binding expressions and property-based filters.</p>
</li>
<li>
<p><code>StandardEvaluationContext</code>: Exposes the full set of SpEL language features and
configuration options. You can use it to specify a default root object and to configure
every available evaluation-related strategy.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>SimpleEvaluationContext</code> is designed to support only a subset of the SpEL language syntax.
It excludes Java type references, constructors, and bean references. It also requires
you to explicitly choose the level of support for properties and methods in expressions.
By default, the <code>create()</code> static factory method enables only read access to properties.
You can also obtain a builder to configure the exact level of support needed, targeting
one or some combination of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Custom <code>PropertyAccessor</code> only (no reflection)</p>
</li>
<li>
<p>Data binding properties for read-only access</p>
</li>
<li>
<p>Data binding properties for read and write</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="expressions-type-conversion"><a class="anchor" href="#expressions-type-conversion"></a>Type Conversion</h5>
<div class="paragraph">
<p>By default, SpEL uses the conversion service available in Spring core
(<code>org.springframework.core.convert.ConversionService</code>). This conversion service comes
with many built-in converters for common conversions but is also fully extensible so that
you can add custom conversions between types. Additionally, it is
generics-aware. This means that, when you work with generic types in
expressions, SpEL attempts conversions to maintain type correctness for any objects
it encounters.</p>
</div>
<div class="paragraph">
<p>What does this mean in practice? Suppose assignment, using <code>setValue()</code>, is being used
to set a <code>List</code> property. The type of the property is actually <code>List&lt;Boolean&gt;</code>. SpEL
recognizes that the elements of the list need to be converted to <code>Boolean</code> before
being placed in it. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">class Simple {
    public List&lt;Boolean&gt; booleanList = new ArrayList&lt;Boolean&gt;();
}

Simple simple = new Simple();
simple.booleanList.add(true);

EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();

// "false" is passed in here as a String. SpEL and the conversion service
// will recognize that it needs to be a Boolean and convert it accordingly.
parser.parseExpression("booleanList[0]").setValue(context, simple, "false");

// b is false
Boolean b = simple.booleanList.get(0);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class Simple {
    var booleanList: MutableList&lt;Boolean&gt; = ArrayList()
}

val simple = Simple()
simple.booleanList.add(true)

val context = SimpleEvaluationContext.forReadOnlyDataBinding().build()

// "false" is passed in here as a String. SpEL and the conversion service
// will recognize that it needs to be a Boolean and convert it accordingly.
parser.parseExpression("booleanList[0]").setValue(context, simple, "false")

// b is false
val b = simple.booleanList[0]</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-parser-configuration"><a class="anchor" href="#expressions-parser-configuration"></a>4.1.2. Parser Configuration</h4>
<div class="paragraph">
<p>It is possible to configure the SpEL expression parser by using a parser configuration
object (<code>org.springframework.expression.spel.SpelParserConfiguration</code>). The configuration
object controls the behavior of some of the expression components. For example, if you
index into an array or collection and the element at the specified index is <code>null</code>, SpEL
can automatically create the element. This is useful when using expressions made up of a
chain of property references. If you index into an array or list and specify an index
that is beyond the end of the current size of the array or list, SpEL can automatically
grow the array or list to accommodate that index. In order to add an element at the
specified index, SpEL will try to create the element using the element type&#8217;s default
constructor before setting the specified value. If the element type does not have a
default constructor, <code>null</code> will be added to the array or list. If there is no built-in
or custom converter that knows how to set the value, <code>null</code> will remain in the array or
list at the specified index. The following example demonstrates how to automatically grow
the list:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">class Demo {
    public List&lt;String&gt; list;
}

// Turn on:
// - auto null reference initialization
// - auto collection growing
SpelParserConfiguration config = new SpelParserConfiguration(true,true);

ExpressionParser parser = new SpelExpressionParser(config);

Expression expression = parser.parseExpression("list[3]");

Demo demo = new Demo();

Object o = expression.getValue(demo);

// demo.list will now be a real collection of 4 entries
// Each entry is a new empty String</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class Demo {
    var list: List&lt;String&gt;? = null
}

// Turn on:
// - auto null reference initialization
// - auto collection growing
val config = SpelParserConfiguration(true, true)

val parser = SpelExpressionParser(config)

val expression = parser.parseExpression("list[3]")

val demo = Demo()

val o = expression.getValue(demo)

// demo.list will now be a real collection of 4 entries
// Each entry is a new empty String</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-spel-compilation"><a class="anchor" href="#expressions-spel-compilation"></a>4.1.3. SpEL Compilation</h4>
<div class="paragraph">
<p>Spring Framework 4.1 includes a basic expression compiler. Expressions are usually
interpreted, which provides a lot of dynamic flexibility during evaluation but
does not provide optimum performance. For occasional expression usage,
this is fine, but, when used by other components such as Spring Integration,
performance can be very important, and there is no real need for the dynamism.</p>
</div>
<div class="paragraph">
<p>The SpEL compiler is intended to address this need. During evaluation, the compiler
generates a Java class that embodies the expression behavior at runtime and uses that
class to achieve much faster expression evaluation. Due to the lack of typing around
expressions, the compiler uses information gathered during the interpreted evaluations
of an expression when performing compilation. For example, it does not know the type
of a property reference purely from the expression, but during the first interpreted
evaluation, it finds out what it is. Of course, basing compilation on such derived
information can cause trouble later if the types of the various expression elements
change over time. For this reason, compilation is best suited to expressions whose
type information is not going to change on repeated evaluations.</p>
</div>
<div class="paragraph">
<p>Consider the following basic expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>someArray[0].someProperty.someOtherProperty &lt; 0.1</pre>
</div>
</div>
<div class="paragraph">
<p>Because the preceding expression involves array access, some property de-referencing,
and numeric operations, the performance gain can be very noticeable. In an example
micro benchmark run of 50000 iterations, it took 75ms to evaluate by using the
interpreter and only 3ms using the compiled version of the expression.</p>
</div>
<div class="sect4">
<h5 id="expressions-compiler-configuration"><a class="anchor" href="#expressions-compiler-configuration"></a>Compiler Configuration</h5>
<div class="paragraph">
<p>The compiler is not turned on by default, but you can turn it on in either of two
different ways. You can turn it on by using the parser configuration process
(<a href="#expressions-parser-configuration">discussed earlier</a>) or by using a Spring property
when SpEL usage is embedded inside another component. This section discusses both of
these options.</p>
</div>
<div class="paragraph">
<p>The compiler can operate in one of three modes, which are captured in the
<code>org.springframework.expression.spel.SpelCompilerMode</code> enum. The modes are as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>OFF</code> (default): The compiler is switched off.</p>
</li>
<li>
<p><code>IMMEDIATE</code>: In immediate mode, the expressions are compiled as soon as possible. This
is typically after the first interpreted evaluation. If the compiled expression fails
(typically due to a type changing, as described earlier), the caller of the expression
evaluation receives an exception.</p>
</li>
<li>
<p><code>MIXED</code>: In mixed mode, the expressions silently switch between interpreted and compiled
mode over time. After some number of interpreted runs, they switch to compiled
form and, if something goes wrong with the compiled form (such as a type changing, as
described earlier), the expression automatically switches back to interpreted form
again. Sometime later, it may generate another compiled form and switch to it. Basically,
the exception that the user gets in <code>IMMEDIATE</code> mode is instead handled internally.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>IMMEDIATE</code> mode exists because <code>MIXED</code> mode could cause issues for expressions that
have side effects. If a compiled expression blows up after partially succeeding, it
may have already done something that has affected the state of the system. If this
has happened, the caller may not want it to silently re-run in interpreted mode,
since part of the expression may be running twice.</p>
</div>
<div class="paragraph">
<p>After selecting a mode, use the <code>SpelParserConfiguration</code> to configure the parser. The
following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">SpelParserConfiguration config = new SpelParserConfiguration(SpelCompilerMode.IMMEDIATE,
    this.getClass().getClassLoader());

SpelExpressionParser parser = new SpelExpressionParser(config);

Expression expr = parser.parseExpression("payload");

MyMessage message = new MyMessage();

Object payload = expr.getValue(message);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val config = SpelParserConfiguration(SpelCompilerMode.IMMEDIATE,
        this.javaClass.classLoader)

val parser = SpelExpressionParser(config)

val expr = parser.parseExpression("payload")

val message = MyMessage()

val payload = expr.getValue(message)</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you specify the compiler mode, you can also specify a classloader (passing null is allowed).
Compiled expressions are defined in a child classloader created under any that is supplied.
It is important to ensure that, if a classloader is specified, it can see all the types involved in
the expression evaluation process. If you do not specify a classloader, a default classloader is used
(typically the context classloader for the thread that is running during expression evaluation).</p>
</div>
<div class="paragraph">
<p>The second way to configure the compiler is for use when SpEL is embedded inside some
other component and it may not be possible to configure it through a configuration
object. In these cases, it is possible to set the <code>spring.expression.compiler.mode</code>
property via a JVM system property (or via the
<a href="appendix.html#appendix-spring-properties"><code>SpringProperties</code></a> mechanism) to one of the
<code>SpelCompilerMode</code> enum values (<code>off</code>, <code>immediate</code>, or <code>mixed</code>).</p>
</div>
</div>
<div class="sect4">
<h5 id="expressions-compiler-limitations"><a class="anchor" href="#expressions-compiler-limitations"></a>Compiler Limitations</h5>
<div class="paragraph">
<p>Since Spring Framework 4.1, the basic compilation framework is in place. However, the framework
does not yet support compiling every kind of expression. The initial focus has been on the
common expressions that are likely to be used in performance-critical contexts. The following
kinds of expression cannot be compiled at the moment:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Expressions involving assignment</p>
</li>
<li>
<p>Expressions relying on the conversion service</p>
</li>
<li>
<p>Expressions using custom resolvers or accessors</p>
</li>
<li>
<p>Expressions using selection or projection</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>More types of expressions will be compilable in the future.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="expressions-beandef"><a class="anchor" href="#expressions-beandef"></a>4.2. Expressions in Bean Definitions</h3>
<div class="paragraph">
<p>You can use SpEL expressions with XML-based or annotation-based configuration metadata for
defining <code>BeanDefinition</code> instances. In both cases, the syntax to define the expression is of the
form <code>#{ &lt;expression string&gt; }</code>.</p>
</div>
<div class="sect3">
<h4 id="expressions-beandef-xml-based"><a class="anchor" href="#expressions-beandef-xml-based"></a>4.2.1. XML Configuration</h4>
<div class="paragraph">
<p>A property or constructor argument value can be set by using expressions, as the following
example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="numberGuess" class="org.spring.samples.NumberGuess"&gt;
    &lt;property name="randomNumber" value="#{ T(java.lang.Math).random() * 100.0 }"/&gt;

    &lt;!-- other properties --&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>All beans in the application context are available as predefined variables with their
common bean name. This includes standard context beans such as <code>environment</code> (of type
<code>org.springframework.core.env.Environment</code>) as well as <code>systemProperties</code> and
<code>systemEnvironment</code> (of type <code>Map&lt;String, Object&gt;</code>) for access to the runtime environment.</p>
</div>
<div class="paragraph">
<p>The following example shows access to the <code>systemProperties</code> bean as a SpEL variable:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="taxCalculator" class="org.spring.samples.TaxCalculator"&gt;
    &lt;property name="defaultLocale" value="#{ systemProperties['user.region'] }"/&gt;

    &lt;!-- other properties --&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that you do not have to prefix the predefined variable with the <code>#</code> symbol here.</p>
</div>
<div class="paragraph">
<p>You can also refer to other bean properties by name, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="numberGuess" class="org.spring.samples.NumberGuess"&gt;
    &lt;property name="randomNumber" value="#{ T(java.lang.Math).random() * 100.0 }"/&gt;

    &lt;!-- other properties --&gt;
&lt;/bean&gt;

&lt;bean id="shapeGuess" class="org.spring.samples.ShapeGuess"&gt;
    &lt;property name="initialShapeSeed" value="#{ numberGuess.randomNumber }"/&gt;

    &lt;!-- other properties --&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-beandef-annotation-based"><a class="anchor" href="#expressions-beandef-annotation-based"></a>4.2.2. Annotation Configuration</h4>
<div class="paragraph">
<p>To specify a default value, you can place the <code>@Value</code> annotation on fields, methods,
and method or constructor parameters.</p>
</div>
<div class="paragraph">
<p>The following example sets the default value of a field:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class FieldValueTestBean {

    @Value("#{ systemProperties['user.region'] }")
    private String defaultLocale;

    public void setDefaultLocale(String defaultLocale) {
        this.defaultLocale = defaultLocale;
    }

    public String getDefaultLocale() {
        return this.defaultLocale;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class FieldValueTestBean {

    @Value("#{ systemProperties['user.region'] }")
    var defaultLocale: String? = null
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the equivalent but on a property setter method:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class PropertyValueTestBean {

    private String defaultLocale;

    @Value("#{ systemProperties['user.region'] }")
    public void setDefaultLocale(String defaultLocale) {
        this.defaultLocale = defaultLocale;
    }

    public String getDefaultLocale() {
        return this.defaultLocale;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class PropertyValueTestBean {

    @Value("#{ systemProperties['user.region'] }")
    var defaultLocale: String? = null
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Autowired methods and constructors can also use the <code>@Value</code> annotation, as the following
examples show:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class SimpleMovieLister {

    private MovieFinder movieFinder;
    private String defaultLocale;

    @Autowired
    public void configure(MovieFinder movieFinder,
            @Value("#{ systemProperties['user.region'] }") String defaultLocale) {
        this.movieFinder = movieFinder;
        this.defaultLocale = defaultLocale;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class SimpleMovieLister {

    private lateinit var movieFinder: MovieFinder
    private lateinit var defaultLocale: String

    @Autowired
    fun configure(movieFinder: MovieFinder,
                @Value("#{ systemProperties['user.region'] }") defaultLocale: String) {
        this.movieFinder = movieFinder
        this.defaultLocale = defaultLocale
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class MovieRecommender {

    private String defaultLocale;

    private CustomerPreferenceDao customerPreferenceDao;

    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao,
            @Value("#{systemProperties['user.country']}") String defaultLocale) {
        this.customerPreferenceDao = customerPreferenceDao;
        this.defaultLocale = defaultLocale;
    }

    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class MovieRecommender(private val customerPreferenceDao: CustomerPreferenceDao,
            @Value("#{systemProperties['user.country']}") private val defaultLocale: String) {
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="expressions-language-ref"><a class="anchor" href="#expressions-language-ref"></a>4.3. Language Reference</h3>
<div class="paragraph">
<p>This section describes how the Spring Expression Language works. It covers the following
topics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#expressions-ref-literal">Literal Expressions</a></p>
</li>
<li>
<p><a href="#expressions-properties-arrays">Properties, Arrays, Lists, Maps, and Indexers</a></p>
</li>
<li>
<p><a href="#expressions-inline-lists">Inline Lists</a></p>
</li>
<li>
<p><a href="#expressions-inline-maps">Inline Maps</a></p>
</li>
<li>
<p><a href="#expressions-array-construction">Array Construction</a></p>
</li>
<li>
<p><a href="#expressions-methods">Methods</a></p>
</li>
<li>
<p><a href="#expressions-operators">Operators</a></p>
</li>
<li>
<p><a href="#expressions-types">Types</a></p>
</li>
<li>
<p><a href="#expressions-constructors">Constructors</a></p>
</li>
<li>
<p><a href="#expressions-ref-variables">Variables</a></p>
</li>
<li>
<p><a href="#expressions-ref-functions">Functions</a></p>
</li>
<li>
<p><a href="#expressions-bean-references">Bean References</a></p>
</li>
<li>
<p><a href="#expressions-operator-ternary">Ternary Operator (If-Then-Else)</a></p>
</li>
<li>
<p><a href="#expressions-operator-elvis">The Elvis Operator</a></p>
</li>
<li>
<p><a href="#expressions-operator-safe-navigation">Safe Navigation Operator</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="expressions-ref-literal"><a class="anchor" href="#expressions-ref-literal"></a>4.3.1. Literal Expressions</h4>
<div class="paragraph">
<p>The types of literal expressions supported are strings, numeric values (int, real, hex),
boolean, and null. Strings are delimited by single quotation marks. To put a single quotation mark itself
in a string, use two single quotation mark characters.</p>
</div>
<div class="paragraph">
<p>The following listing shows simple usage of literals. Typically, they are not used
in isolation like this but, rather, as part of a more complex expression&#8201;&#8212;&#8201;for example,
using a literal on one side of a logical comparison operator.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ExpressionParser parser = new SpelExpressionParser();

// evals to "Hello World"
String helloWorld = (String) parser.parseExpression("'Hello World'").getValue();

double avogadrosNumber = (Double) parser.parseExpression("6.0221415E+23").getValue();

// evals to 2147483647
int maxValue = (Integer) parser.parseExpression("0x7FFFFFFF").getValue();

boolean trueValue = (Boolean) parser.parseExpression("true").getValue();

Object nullValue = parser.parseExpression("null").getValue();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val parser = SpelExpressionParser()

// evals to "Hello World"
val helloWorld = parser.parseExpression("'Hello World'").value as String

val avogadrosNumber = parser.parseExpression("6.0221415E+23").value as Double

// evals to 2147483647
val maxValue = parser.parseExpression("0x7FFFFFFF").value as Int

val trueValue = parser.parseExpression("true").value as Boolean

val nullValue = parser.parseExpression("null").value</code></pre>
</div>
</div>
<div class="paragraph">
<p>Numbers support the use of the negative sign, exponential notation, and decimal points.
By default, real numbers are parsed by using <code>Double.parseDouble()</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-properties-arrays"><a class="anchor" href="#expressions-properties-arrays"></a>4.3.2. Properties, Arrays, Lists, Maps, and Indexers</h4>
<div class="paragraph">
<p>Navigating with property references is easy. To do so, use a period to indicate a nested
property value. The instances of the <code>Inventor</code> class, <code>pupin</code> and <code>tesla</code>, were
populated with data listed in the <a href="#expressions-example-classes">Classes used in the
examples</a> section. To navigate "down" the object graph and get Tesla&#8217;s year of birth and
Pupin&#8217;s city of birth, we use the following expressions:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// evals to 1856
int year = (Integer) parser.parseExpression("birthdate.year + 1900").getValue(context);

String city = (String) parser.parseExpression("placeOfBirth.city").getValue(context);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// evals to 1856
val year = parser.parseExpression("birthdate.year + 1900").getValue(context) as Int

val city = parser.parseExpression("placeOfBirth.city").getValue(context) as String</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Case insensitivity is allowed for the first letter of property names. Thus, the
expressions in the above example may be written as <code>Birthdate.Year + 1900</code> and
<code>PlaceOfBirth.City</code>, respectively. In addition, properties may optionally be accessed via
method invocations&#8201;&#8212;&#8201;for example, <code>getPlaceOfBirth().getCity()</code> instead of
<code>placeOfBirth.city</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The contents of arrays and lists are obtained by using square bracket notation, as the
following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ExpressionParser parser = new SpelExpressionParser();
EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();

// Inventions Array

// evaluates to "Induction motor"
String invention = parser.parseExpression("inventions[3]").getValue(
        context, tesla, String.class);

// Members List

// evaluates to "Nikola Tesla"
String name = parser.parseExpression("members[0].name").getValue(
        context, ieee, String.class);

// List and Array navigation
// evaluates to "Wireless communication"
String invention = parser.parseExpression("members[0].inventions[6]").getValue(
        context, ieee, String.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val parser = SpelExpressionParser()
val context = SimpleEvaluationContext.forReadOnlyDataBinding().build()

// Inventions Array

// evaluates to "Induction motor"
val invention = parser.parseExpression("inventions[3]").getValue(
        context, tesla, String::class.java)

// Members List

// evaluates to "Nikola Tesla"
val name = parser.parseExpression("members[0].name").getValue(
        context, ieee, String::class.java)

// List and Array navigation
// evaluates to "Wireless communication"
val invention = parser.parseExpression("members[0].inventions[6]").getValue(
        context, ieee, String::class.java)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The contents of maps are obtained by specifying the literal key value within the
brackets. In the following example, because keys for the <code>officers</code> map are strings, we can specify
string literals:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// Officer's Dictionary

Inventor pupin = parser.parseExpression("officers['president']").getValue(
        societyContext, Inventor.class);

// evaluates to "Idvor"
String city = parser.parseExpression("officers['president'].placeOfBirth.city").getValue(
        societyContext, String.class);

// setting values
parser.parseExpression("officers['advisors'][0].placeOfBirth.country").setValue(
        societyContext, "Croatia");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Officer's Dictionary

val pupin = parser.parseExpression("officers['president']").getValue(
        societyContext, Inventor::class.java)

// evaluates to "Idvor"
val city = parser.parseExpression("officers['president'].placeOfBirth.city").getValue(
        societyContext, String::class.java)

// setting values
parser.parseExpression("officers['advisors'][0].placeOfBirth.country").setValue(
        societyContext, "Croatia")</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-inline-lists"><a class="anchor" href="#expressions-inline-lists"></a>4.3.3. Inline Lists</h4>
<div class="paragraph">
<p>You can directly express lists in an expression by using <code>{}</code> notation.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// evaluates to a Java list containing the four numbers
List numbers = (List) parser.parseExpression("{1,2,3,4}").getValue(context);

List listOfLists = (List) parser.parseExpression("{{'a','b'},{'x','y'}}").getValue(context);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// evaluates to a Java list containing the four numbers
val numbers = parser.parseExpression("{1,2,3,4}").getValue(context) as List&lt;*&gt;

val listOfLists = parser.parseExpression("{{'a','b'},{'x','y'}}").getValue(context) as List&lt;*&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>{}</code> by itself means an empty list. For performance reasons, if the list is itself
entirely composed of fixed literals, a constant list is created to represent the
expression (rather than building a new list on each evaluation).</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-inline-maps"><a class="anchor" href="#expressions-inline-maps"></a>4.3.4. Inline Maps</h4>
<div class="paragraph">
<p>You can also directly express maps in an expression by using <code>{key:value}</code> notation. The
following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// evaluates to a Java map containing the two entries
Map inventorInfo = (Map) parser.parseExpression("{name:'Nikola',dob:'10-July-1856'}").getValue(context);

Map mapOfMaps = (Map) parser.parseExpression("{name:{first:'Nikola',last:'Tesla'},dob:{day:10,month:'July',year:1856}}").getValue(context);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// evaluates to a Java map containing the two entries
val inventorInfo = parser.parseExpression("{name:'Nikola',dob:'10-July-1856'}").getValue(context) as Map&lt;*, *&gt;

val mapOfMaps = parser.parseExpression("{name:{first:'Nikola',last:'Tesla'},dob:{day:10,month:'July',year:1856}}").getValue(context) as Map&lt;*, *&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>{:}</code> by itself means an empty map. For performance reasons, if the map is itself
composed of fixed literals or other nested constant structures (lists or maps), a
constant map is created to represent the expression (rather than building a new map on
each evaluation). Quoting of the map keys is optional (unless the key contains a period
(<code>.</code>)). The examples above do not use quoted keys.</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-array-construction"><a class="anchor" href="#expressions-array-construction"></a>4.3.5. Array Construction</h4>
<div class="paragraph">
<p>You can build arrays by using the familiar Java syntax, optionally supplying an initializer
to have the array populated at construction time. The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">int[] numbers1 = (int[]) parser.parseExpression("new int[4]").getValue(context);

// Array with initializer
int[] numbers2 = (int[]) parser.parseExpression("new int[]{1,2,3}").getValue(context);

// Multi dimensional array
int[][] numbers3 = (int[][]) parser.parseExpression("new int[4][5]").getValue(context);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val numbers1 = parser.parseExpression("new int[4]").getValue(context) as IntArray

// Array with initializer
val numbers2 = parser.parseExpression("new int[]{1,2,3}").getValue(context) as IntArray

// Multi dimensional array
val numbers3 = parser.parseExpression("new int[4][5]").getValue(context) as Array&lt;IntArray&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You cannot currently supply an initializer when you construct a multi-dimensional array.</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-methods"><a class="anchor" href="#expressions-methods"></a>4.3.6. Methods</h4>
<div class="paragraph">
<p>You can invoke methods by using typical Java programming syntax. You can also invoke methods
on literals. Variable arguments are also supported. The following examples show how to
invoke methods:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// string literal, evaluates to "bc"
String bc = parser.parseExpression("'abc'.substring(1, 3)").getValue(String.class);

// evaluates to true
boolean isMember = parser.parseExpression("isMember('Mihajlo Pupin')").getValue(
        societyContext, Boolean.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// string literal, evaluates to "bc"
val bc = parser.parseExpression("'abc'.substring(1, 3)").getValue(String::class.java)

// evaluates to true
val isMember = parser.parseExpression("isMember('Mihajlo Pupin')").getValue(
        societyContext, Boolean::class.java)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-operators"><a class="anchor" href="#expressions-operators"></a>4.3.7. Operators</h4>
<div class="paragraph">
<p>The Spring Expression Language supports the following kinds of operators:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#expressions-operators-relational">Relational Operators</a></p>
</li>
<li>
<p><a href="#expressions-operators-logical">Logical Operators</a></p>
</li>
<li>
<p><a href="#expressions-operators-mathematical">Mathematical Operators</a></p>
</li>
<li>
<p><a href="#expressions-assignment">The Assignment Operator</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="expressions-operators-relational"><a class="anchor" href="#expressions-operators-relational"></a>Relational Operators</h5>
<div class="paragraph">
<p>The relational operators (equal, not equal, less than, less than or equal, greater than,
and greater than or equal) are supported by using standard operator notation. The
following listing shows a few examples of operators:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// evaluates to true
boolean trueValue = parser.parseExpression("2 == 2").getValue(Boolean.class);

// evaluates to false
boolean falseValue = parser.parseExpression("2 &lt; -5.0").getValue(Boolean.class);

// evaluates to true
boolean trueValue = parser.parseExpression("'black' &lt; 'block'").getValue(Boolean.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// evaluates to true
val trueValue = parser.parseExpression("2 == 2").getValue(Boolean::class.java)

// evaluates to false
val falseValue = parser.parseExpression("2 &lt; -5.0").getValue(Boolean::class.java)

// evaluates to true
val trueValue = parser.parseExpression("'black' &lt; 'block'").getValue(Boolean::class.java)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Greater-than and less-than comparisons against <code>null</code> follow a simple rule: <code>null</code> is treated as
nothing (that is NOT as zero). As a consequence, any other value is always greater
than <code>null</code> (<code>X &gt; null</code> is always <code>true</code>) and no other value is ever less than nothing
(<code>X &lt; null</code> is always <code>false</code>).</p>
</div>
<div class="paragraph">
<p>If you prefer numeric comparisons instead, avoid number-based <code>null</code> comparisons
in favor of comparisons against zero (for example, <code>X &gt; 0</code> or <code>X &lt; 0</code>).</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In addition to the standard relational operators, SpEL supports the <code>instanceof</code> and regular
expression-based <code>matches</code> operator. The following listing shows examples of both:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// evaluates to false
boolean falseValue = parser.parseExpression(
        "'xyz' instanceof T(Integer)").getValue(Boolean.class);

// evaluates to true
boolean trueValue = parser.parseExpression(
        "'5.00' matches '^-?\\d+(\\.\\d{2})?$'").getValue(Boolean.class);

// evaluates to false
boolean falseValue = parser.parseExpression(
        "'5.0067' matches '^-?\\d+(\\.\\d{2})?$'").getValue(Boolean.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// evaluates to false
val falseValue = parser.parseExpression(
        "'xyz' instanceof T(Integer)").getValue(Boolean::class.java)

// evaluates to true
val trueValue = parser.parseExpression(
        "'5.00' matches '^-?\\d+(\\.\\d{2})?$'").getValue(Boolean::class.java)

// evaluates to false
val falseValue = parser.parseExpression(
        "'5.0067' matches '^-?\\d+(\\.\\d{2})?$'").getValue(Boolean::class.java)</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Be careful with primitive types, as they are immediately boxed up to their
wrapper types. For example, <code>1 instanceof T(int)</code> evaluates to <code>false</code>, while
<code>1 instanceof T(Integer)</code> evaluates to <code>true</code>, as expected.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Each symbolic operator can also be specified as a purely alphabetic equivalent. This
avoids problems where the symbols used have special meaning for the document type in
which the expression is embedded (such as in an XML document). The textual equivalents are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>lt</code> (<code>&lt;</code>)</p>
</li>
<li>
<p><code>gt</code> (<code>&gt;</code>)</p>
</li>
<li>
<p><code>le</code> (<code>&lt;=</code>)</p>
</li>
<li>
<p><code>ge</code> (<code>&gt;=</code>)</p>
</li>
<li>
<p><code>eq</code> (<code>==</code>)</p>
</li>
<li>
<p><code>ne</code> (<code>!=</code>)</p>
</li>
<li>
<p><code>div</code> (<code>/</code>)</p>
</li>
<li>
<p><code>mod</code> (<code>%</code>)</p>
</li>
<li>
<p><code>not</code> (<code>!</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All of the textual operators are case-insensitive.</p>
</div>
</div>
<div class="sect4">
<h5 id="expressions-operators-logical"><a class="anchor" href="#expressions-operators-logical"></a>Logical Operators</h5>
<div class="paragraph">
<p>SpEL supports the following logical operators:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>and</code> (<code>&amp;&amp;</code>)</p>
</li>
<li>
<p><code>or</code> (<code>||</code>)</p>
</li>
<li>
<p><code>not</code> (<code>!</code>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example shows how to use the logical operators:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// -- AND --

// evaluates to false
boolean falseValue = parser.parseExpression("true and false").getValue(Boolean.class);

// evaluates to true
String expression = "isMember('Nikola Tesla') and isMember('Mihajlo Pupin')";
boolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);

// -- OR --

// evaluates to true
boolean trueValue = parser.parseExpression("true or false").getValue(Boolean.class);

// evaluates to true
String expression = "isMember('Nikola Tesla') or isMember('Albert Einstein')";
boolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);

// -- NOT --

// evaluates to false
boolean falseValue = parser.parseExpression("!true").getValue(Boolean.class);

// -- AND and NOT --
String expression = "isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')";
boolean falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// -- AND --

// evaluates to false
val falseValue = parser.parseExpression("true and false").getValue(Boolean::class.java)

// evaluates to true
val expression = "isMember('Nikola Tesla') and isMember('Mihajlo Pupin')"
val trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean::class.java)

// -- OR --

// evaluates to true
val trueValue = parser.parseExpression("true or false").getValue(Boolean::class.java)

// evaluates to true
val expression = "isMember('Nikola Tesla') or isMember('Albert Einstein')"
val trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean::class.java)

// -- NOT --

// evaluates to false
val falseValue = parser.parseExpression("!true").getValue(Boolean::class.java)

// -- AND and NOT --
val expression = "isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')"
val falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean::class.java)</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="expressions-operators-mathematical"><a class="anchor" href="#expressions-operators-mathematical"></a>Mathematical Operators</h5>
<div class="paragraph">
<p>You can use the addition operator (<code>+</code>) on both numbers and strings. You can use the
subtraction (<code>-</code>), multiplication (<code>*</code>), and division (<code>/</code>) operators only on numbers.
You can also use the modulus (<code>%</code>) and exponential power (<code>^</code>) operators on numbers.
Standard operator precedence is enforced. The following example shows the mathematical
operators in use:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// Addition
int two = parser.parseExpression("1 + 1").getValue(Integer.class);  // 2

String testString = parser.parseExpression(
        "'test' + ' ' + 'string'").getValue(String.class);  // 'test string'

// Subtraction
int four = parser.parseExpression("1 - -3").getValue(Integer.class);  // 4

double d = parser.parseExpression("1000.00 - 1e4").getValue(Double.class);  // -9000

// Multiplication
int six = parser.parseExpression("-2 * -3").getValue(Integer.class);  // 6

double twentyFour = parser.parseExpression("2.0 * 3e0 * 4").getValue(Double.class);  // 24.0

// Division
int minusTwo = parser.parseExpression("6 / -3").getValue(Integer.class);  // -2

double one = parser.parseExpression("8.0 / 4e0 / 2").getValue(Double.class);  // 1.0

// Modulus
int three = parser.parseExpression("7 % 4").getValue(Integer.class);  // 3

int one = parser.parseExpression("8 / 5 % 2").getValue(Integer.class);  // 1

// Operator precedence
int minusTwentyOne = parser.parseExpression("1+2-3*8").getValue(Integer.class);  // -21</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// Addition
val two = parser.parseExpression("1 + 1").getValue(Int::class.java)  // 2

val testString = parser.parseExpression(
        "'test' + ' ' + 'string'").getValue(String::class.java)  // 'test string'

// Subtraction
val four = parser.parseExpression("1 - -3").getValue(Int::class.java)  // 4

val d = parser.parseExpression("1000.00 - 1e4").getValue(Double::class.java)  // -9000

// Multiplication
val six = parser.parseExpression("-2 * -3").getValue(Int::class.java)  // 6

val twentyFour = parser.parseExpression("2.0 * 3e0 * 4").getValue(Double::class.java)  // 24.0

// Division
val minusTwo = parser.parseExpression("6 / -3").getValue(Int::class.java)  // -2

val one = parser.parseExpression("8.0 / 4e0 / 2").getValue(Double::class.java)  // 1.0

// Modulus
val three = parser.parseExpression("7 % 4").getValue(Int::class.java)  // 3

val one = parser.parseExpression("8 / 5 % 2").getValue(Int::class.java)  // 1

// Operator precedence
val minusTwentyOne = parser.parseExpression("1+2-3*8").getValue(Int::class.java)  // -21</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="expressions-assignment"><a class="anchor" href="#expressions-assignment"></a>The Assignment Operator</h5>
<div class="paragraph">
<p>To set a property, use the assignment operator (<code>=</code>). This is typically done within a
call to <code>setValue</code> but can also be done inside a call to <code>getValue</code>. The following
listing shows both ways to use the assignment operator:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Inventor inventor = new Inventor();
EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();

parser.parseExpression("name").setValue(context, inventor, "Aleksandar Seovic");

// alternatively
String aleks = parser.parseExpression(
        "name = 'Aleksandar Seovic'").getValue(context, inventor, String.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val inventor = Inventor()
val context = SimpleEvaluationContext.forReadWriteDataBinding().build()

parser.parseExpression("name").setValue(context, inventor, "Aleksandar Seovic")

// alternatively
val aleks = parser.parseExpression(
        "name = 'Aleksandar Seovic'").getValue(context, inventor, String::class.java)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-types"><a class="anchor" href="#expressions-types"></a>4.3.8. Types</h4>
<div class="paragraph">
<p>You can use the special <code>T</code> operator to specify an instance of <code>java.lang.Class</code> (the
type). Static methods are invoked by using this operator as well. The
<code>StandardEvaluationContext</code> uses a <code>TypeLocator</code> to find types, and the
<code>StandardTypeLocator</code> (which can be replaced) is built with an understanding of the
<code>java.lang</code> package. This means that <code>T()</code> references to types within the <code>java.lang</code>
package do not need to be fully qualified, but all other type references must be. The
following example shows how to use the <code>T</code> operator:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Class dateClass = parser.parseExpression("T(java.util.Date)").getValue(Class.class);

Class stringClass = parser.parseExpression("T(String)").getValue(Class.class);

boolean trueValue = parser.parseExpression(
        "T(java.math.RoundingMode).CEILING &lt; T(java.math.RoundingMode).FLOOR")
        .getValue(Boolean.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val dateClass = parser.parseExpression("T(java.util.Date)").getValue(Class::class.java)

val stringClass = parser.parseExpression("T(String)").getValue(Class::class.java)

val trueValue = parser.parseExpression(
        "T(java.math.RoundingMode).CEILING &lt; T(java.math.RoundingMode).FLOOR")
        .getValue(Boolean::class.java)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-constructors"><a class="anchor" href="#expressions-constructors"></a>4.3.9. Constructors</h4>
<div class="paragraph">
<p>You can invoke constructors by using the <code>new</code> operator. You should use the fully
qualified class name for all types except those located in the <code>java.lang</code> package
(<code>Integer</code>, <code>Float</code>, <code>String</code>, and so on). The following example shows how to use the
<code>new</code> operator to invoke constructors:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Inventor einstein = p.parseExpression(
        "new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German')")
        .getValue(Inventor.class);

// create new Inventor instance within the add() method of List
p.parseExpression(
        "Members.add(new org.spring.samples.spel.inventor.Inventor(
            'Albert Einstein', 'German'))").getValue(societyContext);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val einstein = p.parseExpression(
        "new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German')")
        .getValue(Inventor::class.java)

// create new Inventor instance within the add() method of List
p.parseExpression(
        "Members.add(new org.spring.samples.spel.inventor.Inventor('Albert Einstein', 'German'))")
        .getValue(societyContext)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-ref-variables"><a class="anchor" href="#expressions-ref-variables"></a>4.3.10. Variables</h4>
<div class="paragraph">
<p>You can reference variables in the expression by using the <code>#variableName</code> syntax. Variables
are set by using the <code>setVariable</code> method on <code>EvaluationContext</code> implementations.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Valid variable names must be composed of one or more of the following supported
characters.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>letters: <code>A</code> to <code>Z</code> and <code>a</code> to <code>z</code></p>
</li>
<li>
<p>digits: <code>0</code> to <code>9</code></p>
</li>
<li>
<p>underscore: <code>_</code></p>
</li>
<li>
<p>dollar sign: <code>$</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows how to use variables.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Inventor tesla = new Inventor("Nikola Tesla", "Serbian");

EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build();
context.setVariable("newName", "Mike Tesla");

parser.parseExpression("name = #newName").getValue(context, tesla);
System.out.println(tesla.getName())  // "Mike Tesla"</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val tesla = Inventor("Nikola Tesla", "Serbian")

val context = SimpleEvaluationContext.forReadWriteDataBinding().build()
context.setVariable("newName", "Mike Tesla")

parser.parseExpression("name = #newName").getValue(context, tesla)
println(tesla.name)  // "Mike Tesla"</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="expressions-this-root"><a class="anchor" href="#expressions-this-root"></a>The <code>#this</code> and <code>#root</code> Variables</h5>
<div class="paragraph">
<p>The <code>#this</code> variable is always defined and refers to the current evaluation object
(against which unqualified references are resolved). The <code>#root</code> variable is always
defined and refers to the root context object. Although <code>#this</code> may vary as components of
an expression are evaluated, <code>#root</code> always refers to the root. The following examples
show how to use the <code>#this</code> and <code>#root</code> variables:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// create an array of integers
List&lt;Integer&gt; primes = new ArrayList&lt;Integer&gt;();
primes.addAll(Arrays.asList(2,3,5,7,11,13,17));

// create parser and set variable 'primes' as the array of integers
ExpressionParser parser = new SpelExpressionParser();
EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataAccess();
context.setVariable("primes", primes);

// all prime numbers &gt; 10 from the list (using selection ?{...})
// evaluates to [11, 13, 17]
List&lt;Integer&gt; primesGreaterThanTen = (List&lt;Integer&gt;) parser.parseExpression(
        "#primes.?[#this&gt;10]").getValue(context);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// create an array of integers
val primes = ArrayList&lt;Int&gt;()
primes.addAll(listOf(2, 3, 5, 7, 11, 13, 17))

// create parser and set variable 'primes' as the array of integers
val parser = SpelExpressionParser()
val context = SimpleEvaluationContext.forReadOnlyDataAccess()
context.setVariable("primes", primes)

// all prime numbers &gt; 10 from the list (using selection ?{...})
// evaluates to [11, 13, 17]
val primesGreaterThanTen = parser.parseExpression(
        "#primes.?[#this&gt;10]").getValue(context) as List&lt;Int&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-ref-functions"><a class="anchor" href="#expressions-ref-functions"></a>4.3.11. Functions</h4>
<div class="paragraph">
<p>You can extend SpEL by registering user-defined functions that can be called within the
expression string. The function is registered through the <code>EvaluationContext</code>. The
following example shows how to register a user-defined function:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Method method = ...;

EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();
context.setVariable("myFunction", method);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val method: Method = ...

val context = SimpleEvaluationContext.forReadOnlyDataBinding().build()
context.setVariable("myFunction", method)</code></pre>
</div>
</div>
<div class="paragraph">
<p>For example, consider the following utility method that reverses a string:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public abstract class StringUtils {

    public static String reverseString(String input) {
        StringBuilder backwards = new StringBuilder(input.length());
        for (int i = 0; i &lt; input.length(); i++) {
            backwards.append(input.charAt(input.length() - 1 - i));
        }
        return backwards.toString();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun reverseString(input: String): String {
    val backwards = StringBuilder(input.length)
    for (i in 0 until input.length) {
        backwards.append(input[input.length - 1 - i])
    }
    return backwards.toString()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can then register and use the preceding method, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ExpressionParser parser = new SpelExpressionParser();

EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();
context.setVariable("reverseString",
        StringUtils.class.getDeclaredMethod("reverseString", String.class));

String helloWorldReversed = parser.parseExpression(
        "#reverseString('hello')").getValue(context, String.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val parser = SpelExpressionParser()

val context = SimpleEvaluationContext.forReadOnlyDataBinding().build()
context.setVariable("reverseString", ::reverseString::javaMethod)

val helloWorldReversed = parser.parseExpression(
        "#reverseString('hello')").getValue(context, String::class.java)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-bean-references"><a class="anchor" href="#expressions-bean-references"></a>4.3.12. Bean References</h4>
<div class="paragraph">
<p>If the evaluation context has been configured with a bean resolver, you can
look up beans from an expression by using the <code>@</code> symbol. The following example shows how
to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ExpressionParser parser = new SpelExpressionParser();
StandardEvaluationContext context = new StandardEvaluationContext();
context.setBeanResolver(new MyBeanResolver());

// This will end up calling resolve(context,"something") on MyBeanResolver during evaluation
Object bean = parser.parseExpression("@something").getValue(context);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val parser = SpelExpressionParser()
val context = StandardEvaluationContext()
context.setBeanResolver(MyBeanResolver())

// This will end up calling resolve(context,"something") on MyBeanResolver during evaluation
val bean = parser.parseExpression("@something").getValue(context)</code></pre>
</div>
</div>
<div class="paragraph">
<p>To access a factory bean itself, you should instead prefix the bean name with an <code>&amp;</code> symbol.
The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ExpressionParser parser = new SpelExpressionParser();
StandardEvaluationContext context = new StandardEvaluationContext();
context.setBeanResolver(new MyBeanResolver());

// This will end up calling resolve(context,"&amp;foo") on MyBeanResolver during evaluation
Object bean = parser.parseExpression("&amp;foo").getValue(context);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val parser = SpelExpressionParser()
val context = StandardEvaluationContext()
context.setBeanResolver(MyBeanResolver())

// This will end up calling resolve(context,"&amp;foo") on MyBeanResolver during evaluation
val bean = parser.parseExpression("&amp;foo").getValue(context)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-operator-ternary"><a class="anchor" href="#expressions-operator-ternary"></a>4.3.13. Ternary Operator (If-Then-Else)</h4>
<div class="paragraph">
<p>You can use the ternary operator for performing if-then-else conditional logic inside
the expression. The following listing shows a minimal example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">String falseString = parser.parseExpression(
        "false ? 'trueExp' : 'falseExp'").getValue(String.class);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val falseString = parser.parseExpression(
        "false ? 'trueExp' : 'falseExp'").getValue(String::class.java)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, the boolean <code>false</code> results in returning the string value <code>'falseExp'</code>. A more
realistic example follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">parser.parseExpression("name").setValue(societyContext, "IEEE");
societyContext.setVariable("queryName", "Nikola Tesla");

expression = "isMember(#queryName)? #queryName + ' is a member of the ' " +
        "+ Name + ' Society' : #queryName + ' is not a member of the ' + Name + ' Society'";

String queryResultString = parser.parseExpression(expression)
        .getValue(societyContext, String.class);
// queryResultString = "Nikola Tesla is a member of the IEEE Society"</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">parser.parseExpression("name").setValue(societyContext, "IEEE")
societyContext.setVariable("queryName", "Nikola Tesla")

expression = "isMember(#queryName)? #queryName + ' is a member of the ' " + "+ Name + ' Society' : #queryName + ' is not a member of the ' + Name + ' Society'"

val queryResultString = parser.parseExpression(expression)
        .getValue(societyContext, String::class.java)
// queryResultString = "Nikola Tesla is a member of the IEEE Society"</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the next section on the Elvis operator for an even shorter syntax for the
ternary operator.</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-operator-elvis"><a class="anchor" href="#expressions-operator-elvis"></a>4.3.14. The Elvis Operator</h4>
<div class="paragraph">
<p>The Elvis operator is a shortening of the ternary operator syntax and is used in the
<a href="http://www.groovy-lang.org/operators.html#_elvis_operator">Groovy</a> language.
With the ternary operator syntax, you usually have to repeat a variable twice, as the
following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="groovy" class="language-groovy hljs">String name = "Elvis Presley";
String displayName = (name != null ? name : "Unknown");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instead, you can use the Elvis operator (named for the resemblance to Elvis' hair style).
The following example shows how to use the Elvis operator:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ExpressionParser parser = new SpelExpressionParser();

String name = parser.parseExpression("name?:'Unknown'").getValue(new Inventor(), String.class);
System.out.println(name);  // 'Unknown'</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val parser = SpelExpressionParser()

val name = parser.parseExpression("name?:'Unknown'").getValue(Inventor(), String::class.java)
println(name)  // 'Unknown'</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following listing shows a more complex example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ExpressionParser parser = new SpelExpressionParser();
EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();

Inventor tesla = new Inventor("Nikola Tesla", "Serbian");
String name = parser.parseExpression("name?:'Elvis Presley'").getValue(context, tesla, String.class);
System.out.println(name);  // Nikola Tesla

tesla.setName(null);
name = parser.parseExpression("name?:'Elvis Presley'").getValue(context, tesla, String.class);
System.out.println(name);  // Elvis Presley</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val parser = SpelExpressionParser()
val context = SimpleEvaluationContext.forReadOnlyDataBinding().build()

val tesla = Inventor("Nikola Tesla", "Serbian")
var name = parser.parseExpression("name?:'Elvis Presley'").getValue(context, tesla, String::class.java)
println(name)  // Nikola Tesla

tesla.setName(null)
name = parser.parseExpression("name?:'Elvis Presley'").getValue(context, tesla, String::class.java)
println(name)  // Elvis Presley</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can use the Elvis operator to apply default values in expressions. The following
example shows how to use the Elvis operator in a <code>@Value</code> expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Value("#{systemProperties['pop3.port'] ?: 25}")</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will inject a system property <code>pop3.port</code> if it is defined or 25 if not.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="expressions-operator-safe-navigation"><a class="anchor" href="#expressions-operator-safe-navigation"></a>4.3.15. Safe Navigation Operator</h4>
<div class="paragraph">
<p>The safe navigation operator is used to avoid a <code>NullPointerException</code> and comes from
the <a href="http://www.groovy-lang.org/operators.html#_safe_navigation_operator">Groovy</a>
language. Typically, when you have a reference to an object, you might need to verify that
it is not null before accessing methods or properties of the object. To avoid this, the
safe navigation operator returns null instead of throwing an exception. The following
example shows how to use the safe navigation operator:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ExpressionParser parser = new SpelExpressionParser();
EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();

Inventor tesla = new Inventor("Nikola Tesla", "Serbian");
tesla.setPlaceOfBirth(new PlaceOfBirth("Smiljan"));

String city = parser.parseExpression("placeOfBirth?.city").getValue(context, tesla, String.class);
System.out.println(city);  // Smiljan

tesla.setPlaceOfBirth(null);
city = parser.parseExpression("placeOfBirth?.city").getValue(context, tesla, String.class);
System.out.println(city);  // null - does not throw NullPointerException!!!</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val parser = SpelExpressionParser()
val context = SimpleEvaluationContext.forReadOnlyDataBinding().build()

val tesla = Inventor("Nikola Tesla", "Serbian")
tesla.setPlaceOfBirth(PlaceOfBirth("Smiljan"))

var city = parser.parseExpression("placeOfBirth?.city").getValue(context, tesla, String::class.java)
println(city)  // Smiljan

tesla.setPlaceOfBirth(null)
city = parser.parseExpression("placeOfBirth?.city").getValue(context, tesla, String::class.java)
println(city)  // null - does not throw NullPointerException!!!</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="expressions-collection-selection"><a class="anchor" href="#expressions-collection-selection"></a>4.3.16. Collection Selection</h4>
<div class="paragraph">
<p>Selection is a powerful expression language feature that lets you transform a
source collection into another collection by selecting from its entries.</p>
</div>
<div class="paragraph">
<p>Selection uses a syntax of <code>.?[selectionExpression]</code>. It filters the collection and
returns a new collection that contains a subset of the original elements. For example,
selection lets us easily get a list of Serbian inventors, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">List&lt;Inventor&gt; list = (List&lt;Inventor&gt;) parser.parseExpression(
        "members.?[nationality == 'Serbian']").getValue(societyContext);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val list = parser.parseExpression(
        "members.?[nationality == 'Serbian']").getValue(societyContext) as List&lt;Inventor&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Selection is supported for arrays and anything that implements <code>java.lang.Iterable</code> or
<code>java.util.Map</code>. For a list or array, the selection criteria is evaluated against each
individual element. Against a map, the selection criteria is evaluated against each map
entry (objects of the Java type <code>Map.Entry</code>). Each map entry has its <code>key</code> and <code>value</code>
accessible as properties for use in the selection.</p>
</div>
<div class="paragraph">
<p>The following expression returns a new map that consists of those elements of the
original map where the entry&#8217;s value is less than 27:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Map newMap = parser.parseExpression("map.?[value&lt;27]").getValue();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val newMap = parser.parseExpression("map.?[value&lt;27]").getValue()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In addition to returning all the selected elements, you can retrieve only the first or
the last element. To obtain the first element matching the selection, the syntax is
<code>.^[selectionExpression]</code>. To obtain the last matching selection, the syntax is
<code>.$[selectionExpression]</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-collection-projection"><a class="anchor" href="#expressions-collection-projection"></a>4.3.17. Collection Projection</h4>
<div class="paragraph">
<p>Projection lets a collection drive the evaluation of a sub-expression, and the result is
a new collection. The syntax for projection is <code>.![projectionExpression]</code>. For example,
suppose we have a list of inventors but want the list of cities where they were born.
Effectively, we want to evaluate 'placeOfBirth.city' for every entry in the inventor
list. The following example uses projection to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// returns ['Smiljan', 'Idvor' ]
List placesOfBirth = (List)parser.parseExpression("members.![placeOfBirth.city]");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// returns ['Smiljan', 'Idvor' ]
val placesOfBirth = parser.parseExpression("members.![placeOfBirth.city]") as List&lt;*&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Projection is supported for arrays and anything that implements <code>java.lang.Iterable</code> or
<code>java.util.Map</code>. When using a map to drive projection, the projection expression is
evaluated against each entry in the map (represented as a Java <code>Map.Entry</code>). The result
of a projection across a map is a list that consists of the evaluation of the projection
expression against each map entry.</p>
</div>
</div>
<div class="sect3">
<h4 id="expressions-templating"><a class="anchor" href="#expressions-templating"></a>4.3.18. Expression templating</h4>
<div class="paragraph">
<p>Expression templates allow mixing literal text with one or more evaluation blocks.
Each evaluation block is delimited with prefix and suffix characters that you can
define. A common choice is to use <code>#{ }</code> as the delimiters, as the following example
shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">String randomPhrase = parser.parseExpression(
        "random number is #{T(java.lang.Math).random()}",
        new TemplateParserContext()).getValue(String.class);

// evaluates to "random number is 0.7038186818312008"</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val randomPhrase = parser.parseExpression(
        "random number is #{T(java.lang.Math).random()}",
        TemplateParserContext()).getValue(String::class.java)

// evaluates to "random number is 0.7038186818312008"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The string is evaluated by concatenating the literal text <code>'random number is '</code> with the
result of evaluating the expression inside the <code>#{ }</code> delimiter (in this case, the result
of calling that <code>random()</code> method). The second argument to the <code>parseExpression()</code> method
is of the type <code>ParserContext</code>. The <code>ParserContext</code> interface is used to influence how
the expression is parsed in order to support the expression templating functionality.
The definition of <code>TemplateParserContext</code> follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class TemplateParserContext implements ParserContext {

    public String getExpressionPrefix() {
        return "#{";
    }

    public String getExpressionSuffix() {
        return "}";
    }

    public boolean isTemplate() {
        return true;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class TemplateParserContext : ParserContext {

    override fun getExpressionPrefix(): String {
        return "#{"
    }

    override fun getExpressionSuffix(): String {
        return "}"
    }

    override fun isTemplate(): Boolean {
        return true
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="expressions-example-classes"><a class="anchor" href="#expressions-example-classes"></a>4.4. Classes Used in the Examples</h3>
<div class="paragraph">
<p>This section lists the classes used in the examples throughout this chapter.</p>
</div>
<div class="listingblock primary">
<div class="title">Inventor.Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package org.spring.samples.spel.inventor;

import java.util.Date;
import java.util.GregorianCalendar;

public class Inventor {

    private String name;
    private String nationality;
    private String[] inventions;
    private Date birthdate;
    private PlaceOfBirth placeOfBirth;

    public Inventor(String name, String nationality) {
        GregorianCalendar c= new GregorianCalendar();
        this.name = name;
        this.nationality = nationality;
        this.birthdate = c.getTime();
    }

    public Inventor(String name, Date birthdate, String nationality) {
        this.name = name;
        this.nationality = nationality;
        this.birthdate = birthdate;
    }

    public Inventor() {
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getNationality() {
        return nationality;
    }

    public void setNationality(String nationality) {
        this.nationality = nationality;
    }

    public Date getBirthdate() {
        return birthdate;
    }

    public void setBirthdate(Date birthdate) {
        this.birthdate = birthdate;
    }

    public PlaceOfBirth getPlaceOfBirth() {
        return placeOfBirth;
    }

    public void setPlaceOfBirth(PlaceOfBirth placeOfBirth) {
        this.placeOfBirth = placeOfBirth;
    }

    public void setInventions(String[] inventions) {
        this.inventions = inventions;
    }

    public String[] getInventions() {
        return inventions;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Inventor.kt</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class Inventor(
    var name: String,
    var nationality: String,
    var inventions: Array&lt;String&gt;? = null,
    var birthdate: Date =  GregorianCalendar().time,
    var placeOfBirth: PlaceOfBirth? = null)</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">PlaceOfBirth.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package org.spring.samples.spel.inventor;

public class PlaceOfBirth {

    private String city;
    private String country;

    public PlaceOfBirth(String city) {
        this.city=city;
    }

    public PlaceOfBirth(String city, String country) {
        this(city);
        this.country = country;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String s) {
        this.city = s;
    }

    public String getCountry() {
        return country;
    }

    public void setCountry(String country) {
        this.country = country;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">PlaceOfBirth.kt</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class PlaceOfBirth(var city: String, var country: String? = null) {</code></pre>
</div>
</div>
<div class="listingblock primary">
<div class="title">Society.java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package org.spring.samples.spel.inventor;

import java.util.*;

public class Society {

    private String name;

    public static String Advisors = "advisors";
    public static String President = "president";

    private List&lt;Inventor&gt; members = new ArrayList&lt;Inventor&gt;();
    private Map officers = new HashMap();

    public List getMembers() {
        return members;
    }

    public Map getOfficers() {
        return officers;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public boolean isMember(String name) {
        for (Inventor inventor : members) {
            if (inventor.getName().equals(name)) {
                return true;
            }
        }
        return false;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Society.kt</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package org.spring.samples.spel.inventor

import java.util.*

class Society {

    val Advisors = "advisors"
    val President = "president"

    var name: String? = null

    val members = ArrayList&lt;Inventor&gt;()
    val officers = mapOf&lt;Any, Any&gt;()

    fun isMember(name: String): Boolean {
        for (inventor in members) {
            if (inventor.name == name) {
                return true
            }
        }
        return false
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop"><a class="anchor" href="#aop"></a>5. Aspect Oriented Programming with Spring</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Aspect-oriented Programming (AOP) complements Object-oriented Programming (OOP) by
providing another way of thinking about program structure. The key unit of modularity
in OOP is the class, whereas in AOP the unit of modularity is the aspect. Aspects
enable the modularization of concerns (such as transaction management) that cut across
multiple types and objects. (Such concerns are often termed &#8220;crosscutting&#8221; concerns
in AOP literature.)</p>
</div>
<div class="paragraph">
<p>One of the key components of Spring is the AOP framework. While the Spring IoC
container does not depend on AOP (meaning you do not need to use AOP if you don&#8217;t want
to), AOP complements Spring IoC to provide a very capable middleware solution.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Spring AOP with AspectJ pointcuts</div>
<div class="paragraph">
<p>Spring provides simple and powerful ways of writing custom aspects by using either a
<a href="#aop-schema">schema-based approach</a> or the <a href="#aop-ataspectj">@AspectJ annotation style</a>.
Both of these styles offer fully typed advice and use of the AspectJ pointcut language
while still using Spring AOP for weaving.</p>
</div>
<div class="paragraph">
<p>This chapter discusses the schema- and @AspectJ-based AOP support.
The lower-level AOP support is discussed in <a href="#aop-api">the following chapter</a>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>AOP is used in the Spring Framework to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Provide declarative enterprise services. The most important such service is
<a href="data-access.html#transaction-declarative">declarative transaction management</a>.</p>
</li>
<li>
<p>Let users implement custom aspects, complementing their use of OOP with AOP.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you are interested only in generic declarative services or other pre-packaged
declarative middleware services such as pooling, you do not need to work directly with
Spring AOP, and can skip most of this chapter.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="aop-introduction-defn"><a class="anchor" href="#aop-introduction-defn"></a>5.1. AOP Concepts</h3>
<div class="paragraph">
<p>Let us begin by defining some central AOP concepts and terminology. These terms are not
Spring-specific. Unfortunately, AOP terminology is not particularly intuitive.
However, it would be even more confusing if Spring used its own terminology.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Aspect: A modularization of a concern that cuts across multiple classes.
Transaction management is a good example of a crosscutting concern in enterprise Java
applications. In Spring AOP, aspects are implemented by using regular classes
(the <a href="#aop-schema">schema-based approach</a>) or regular classes annotated with the
<code>@Aspect</code> annotation (the <a href="#aop-ataspectj">@AspectJ style</a>).</p>
</li>
<li>
<p>Join point: A point during the execution of a program, such as the execution of a
method or the handling of an exception. In Spring AOP, a join point always
represents a method execution.</p>
</li>
<li>
<p>Advice: Action taken by an aspect at a particular join point. Different types of
advice include &#8220;around&#8221;, &#8220;before&#8221; and &#8220;after&#8221; advice. (Advice types are discussed
later.) Many AOP frameworks, including Spring, model an advice as an interceptor and
maintain a chain of interceptors around the join point.</p>
</li>
<li>
<p>Pointcut: A predicate that matches join points. Advice is associated with a
pointcut expression and runs at any join point matched by the pointcut (for example,
the execution of a method with a certain name). The concept of join points as matched
by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut
expression language by default.</p>
</li>
<li>
<p>Introduction: Declaring additional methods or fields on behalf of a type. Spring
AOP lets you introduce new interfaces (and a corresponding implementation) to any
advised object. For example, you could use an introduction to make a bean implement an
<code>IsModified</code> interface, to simplify caching. (An introduction is known as an
inter-type declaration in the AspectJ community.)</p>
</li>
<li>
<p>Target object: An object being advised by one or more aspects. Also referred to as
the &#8220;advised object&#8221;. Since Spring AOP is implemented by using runtime proxies, this
object is always a proxied object.</p>
</li>
<li>
<p>AOP proxy: An object created by the AOP framework in order to implement the aspect
contracts (advise method executions and so on). In the Spring Framework, an AOP proxy
is a JDK dynamic proxy or a CGLIB proxy.</p>
</li>
<li>
<p>Weaving: linking aspects with other application types or objects to create an
advised object. This can be done at compile time (using the AspectJ compiler, for
example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks,
performs weaving at runtime.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring AOP includes the following types of advice:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Before advice: Advice that runs before a join point but that does not have
the ability to prevent execution flow proceeding to the join point (unless it throws
an exception).</p>
</li>
<li>
<p>After returning advice: Advice to be run after a join point completes
normally (for example, if a method returns without throwing an exception).</p>
</li>
<li>
<p>After throwing advice: Advice to be run if a method exits by throwing an
exception.</p>
</li>
<li>
<p>After (finally) advice: Advice to be run regardless of the means by which a
join point exits (normal or exceptional return).</p>
</li>
<li>
<p>Around advice: Advice that surrounds a join point such as a method invocation.
This is the most powerful kind of advice. Around advice can perform custom behavior
before and after the method invocation. It is also responsible for choosing whether to
proceed to the join point or to shortcut the advised method execution by returning its
own return value or throwing an exception.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Around advice is the most general kind of advice. Since Spring AOP, like AspectJ,
provides a full range of advice types, we recommend that you use the least powerful
advice type that can implement the required behavior. For example, if you need only to
update a cache with the return value of a method, you are better off implementing an
after returning advice than an around advice, although an around advice can accomplish
the same thing. Using the most specific advice type provides a simpler programming model
with less potential for errors. For example, you do not need to invoke the <code>proceed()</code>
method on the <code>JoinPoint</code> used for around advice, and, hence, you cannot fail to invoke it.</p>
</div>
<div class="paragraph">
<p>All advice parameters are statically typed so that you work with advice parameters of
the appropriate type (e.g. the type of the return value from a method execution) rather
than <code>Object</code> arrays.</p>
</div>
<div class="paragraph">
<p>The concept of join points matched by pointcuts is the key to AOP, which distinguishes
it from older technologies offering only interception. Pointcuts enable advice to be
targeted independently of the object-oriented hierarchy. For example, you can apply an
around advice providing declarative transaction management to a set of methods that span
multiple objects (such as all business operations in the service layer).</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-introduction-spring-defn"><a class="anchor" href="#aop-introduction-spring-defn"></a>5.2. Spring AOP Capabilities and Goals</h3>
<div class="paragraph">
<p>Spring AOP is implemented in pure Java. There is no need for a special compilation
process. Spring AOP does not need to control the class loader hierarchy and is thus
suitable for use in a servlet container or application server.</p>
</div>
<div class="paragraph">
<p>Spring AOP currently supports only method execution join points (advising the execution
of methods on Spring beans). Field interception is not implemented, although support for
field interception could be added without breaking the core Spring AOP APIs. If you need
to advise field access and update join points, consider a language such as AspectJ.</p>
</div>
<div class="paragraph">
<p>Spring AOP&#8217;s approach to AOP differs from that of most other AOP frameworks. The aim is
not to provide the most complete AOP implementation (although Spring AOP is quite
capable). Rather, the aim is to provide a close integration between AOP implementation and
Spring IoC, to help solve common problems in enterprise applications.</p>
</div>
<div class="paragraph">
<p>Thus, for example, the Spring Framework&#8217;s AOP functionality is normally used in
conjunction with the Spring IoC container. Aspects are configured by using normal bean
definition syntax (although this allows powerful &#8220;auto-proxying&#8221; capabilities). This is a
crucial difference from other AOP implementations. You cannot do some things
easily or efficiently with Spring AOP, such as advise very fine-grained objects (typically,
domain objects). AspectJ is the best choice in such cases. However, our
experience is that Spring AOP provides an excellent solution to most problems in
enterprise Java applications that are amenable to AOP.</p>
</div>
<div class="paragraph">
<p>Spring AOP never strives to compete with AspectJ to provide a comprehensive AOP
solution. We believe that both proxy-based frameworks such as Spring AOP and full-blown
frameworks such as AspectJ are valuable and that they are complementary, rather than in
competition. Spring seamlessly integrates Spring AOP and IoC with AspectJ, to enable
all uses of AOP within a consistent Spring-based application
architecture. This integration does not affect the Spring AOP API or the AOP Alliance
API. Spring AOP remains backward-compatible. See <a href="#aop-api">the following chapter</a>
for a discussion of the Spring AOP APIs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>One of the central tenets of the Spring Framework is that of non-invasiveness. This
is the idea that you should not be forced to introduce framework-specific classes and
interfaces into your business or domain model. However, in some places, the Spring Framework
does give you the option to introduce Spring Framework-specific dependencies into your
codebase. The rationale in giving you such options is because, in certain scenarios, it
might be just plain easier to read or code some specific piece of functionality in such
a way. However, the Spring Framework (almost) always offers you the choice: You have the
freedom to make an informed decision as to which option best suits your particular use
case or scenario.</p>
</div>
<div class="paragraph">
<p>One such choice that is relevant to this chapter is that of which AOP framework (and
which AOP style) to choose. You have the choice of AspectJ, Spring AOP, or both. You
also have the choice of either the @AspectJ annotation-style approach or the Spring XML
configuration-style approach. The fact that this chapter chooses to introduce the
@AspectJ-style approach first should not be taken as an indication that the Spring team
favors the @AspectJ annotation-style approach over the Spring XML configuration-style.</p>
</div>
<div class="paragraph">
<p>See <a href="#aop-choosing">Choosing which AOP Declaration Style to Use</a> for a more complete discussion of the &#8220;whys and wherefores&#8221; of
each style.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="aop-introduction-proxies"><a class="anchor" href="#aop-introduction-proxies"></a>5.3. AOP Proxies</h3>
<div class="paragraph">
<p>Spring AOP defaults to using standard JDK dynamic proxies for AOP proxies. This
enables any interface (or set of interfaces) to be proxied.</p>
</div>
<div class="paragraph">
<p>Spring AOP can also use CGLIB proxies. This is necessary to proxy classes rather than
interfaces. By default, CGLIB is used if a business object does not implement an
interface. As it is good practice to program to interfaces rather than classes, business
classes normally implement one or more business interfaces. It is possible to
<a href="#aop-proxying">force the use of CGLIB</a>, in those (hopefully rare) cases where you
need to advise a method that is not declared on an interface or where you need to
pass a proxied object to a method as a concrete type.</p>
</div>
<div class="paragraph">
<p>It is important to grasp the fact that Spring AOP is proxy-based. See
<a href="#aop-understanding-aop-proxies">Understanding AOP Proxies</a> for a thorough examination of exactly what this
implementation detail actually means.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-ataspectj"><a class="anchor" href="#aop-ataspectj"></a>5.4. @AspectJ support</h3>
<div class="paragraph">
<p>@AspectJ refers to a style of declaring aspects as regular Java classes annotated with
annotations. The @AspectJ style was introduced by the
<a href="https://www.eclipse.org/aspectj">AspectJ project</a> as part of the AspectJ 5 release. Spring
interprets the same annotations as AspectJ 5, using a library supplied by AspectJ
for pointcut parsing and matching. The AOP runtime is still pure Spring AOP, though, and
there is no dependency on the AspectJ compiler or weaver.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Using the AspectJ compiler and weaver enables use of the full AspectJ language and
is discussed in <a href="#aop-using-aspectj">Using AspectJ with Spring Applications</a>.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="aop-aspectj-support"><a class="anchor" href="#aop-aspectj-support"></a>5.4.1. Enabling @AspectJ Support</h4>
<div class="paragraph">
<p>To use @AspectJ aspects in a Spring configuration, you need to enable Spring support for
configuring Spring AOP based on @AspectJ aspects and auto-proxying beans based on
whether or not they are advised by those aspects. By auto-proxying, we mean that, if Spring
determines that a bean is advised by one or more aspects, it automatically generates
a proxy for that bean to intercept method invocations and ensures that advice is run
as needed.</p>
</div>
<div class="paragraph">
<p>The @AspectJ support can be enabled with XML- or Java-style configuration. In either
case, you also need to ensure that AspectJ&#8217;s <code>aspectjweaver.jar</code> library is on the
classpath of your application (version 1.8 or later). This library is available in the
<code>lib</code> directory of an AspectJ distribution or from the Maven Central repository.</p>
</div>
<div class="sect4">
<h5 id="aop-enable-aspectj-java"><a class="anchor" href="#aop-enable-aspectj-java"></a>Enabling @AspectJ Support with Java Configuration</h5>
<div class="paragraph">
<p>To enable @AspectJ support with Java <code>@Configuration</code>, add the <code>@EnableAspectJAutoProxy</code>
annotation, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@EnableAspectJAutoProxy
public class AppConfig {

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@EnableAspectJAutoProxy
class AppConfig</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-enable-aspectj-xml"><a class="anchor" href="#aop-enable-aspectj-xml"></a>Enabling @AspectJ Support with XML Configuration</h5>
<div class="paragraph">
<p>To enable @AspectJ support with XML-based configuration, use the <code>aop:aspectj-autoproxy</code>
element, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:aspectj-autoproxy/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This assumes that you use schema support as described in
<a href="#xsd-schemas">XML Schema-based configuration</a>.
See <a href="#xsd-schemas-aop">the AOP schema</a> for how to
import the tags in the <code>aop</code> namespace.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-at-aspectj"><a class="anchor" href="#aop-at-aspectj"></a>5.4.2. Declaring an Aspect</h4>
<div class="paragraph">
<p>With @AspectJ support enabled, any bean defined in your application context with a
class that is an @AspectJ aspect (has the <code>@Aspect</code> annotation) is automatically
detected by Spring and used to configure Spring AOP. The next two examples show the
minimal definition required for a not-very-useful aspect.</p>
</div>
<div class="paragraph">
<p>The first of the two example shows a regular bean definition in the application
context that points to a bean class that has the <code>@Aspect</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="myAspect" class="org.xyz.NotVeryUsefulAspect"&gt;
    &lt;!-- configure properties of the aspect here --&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second of the two examples shows the <code>NotVeryUsefulAspect</code> class definition,
which is annotated with the <code>org.aspectj.lang.annotation.Aspect</code> annotation;</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package org.xyz;
import org.aspectj.lang.annotation.Aspect;

@Aspect
public class NotVeryUsefulAspect {

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package org.xyz

import org.aspectj.lang.annotation.Aspect;

@Aspect
class NotVeryUsefulAspect</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aspects (classes annotated with <code>@Aspect</code>) can have methods and fields, the same as any
other class. They can also contain pointcut, advice, and introduction (inter-type)
declarations.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Autodetecting aspects through component scanning</div>
You can register aspect classes as regular beans in your Spring XML configuration,
via <code>@Bean</code> methods in <code>@Configuration</code> classes, or have Spring autodetect them through
classpath scanning&#8201;&#8212;&#8201;the same as any other Spring-managed bean. However, note that the
<code>@Aspect</code> annotation is not sufficient for autodetection in the classpath. For that
purpose, you need to add a separate <code>@Component</code> annotation (or, alternatively, a custom
stereotype annotation that qualifies, as per the rules of Spring&#8217;s component scanner).
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Advising aspects with other aspects?</div>
In Spring AOP, aspects themselves cannot be the targets of advice from other
aspects. The <code>@Aspect</code> annotation on a class marks it as an aspect and, hence, excludes
it from auto-proxying.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="aop-pointcuts"><a class="anchor" href="#aop-pointcuts"></a>5.4.3. Declaring a Pointcut</h4>
<div class="paragraph">
<p>Pointcuts determine join points of interest and thus enable us to control
when advice runs. Spring AOP only supports method execution join points for Spring
beans, so you can think of a pointcut as matching the execution of methods on Spring
beans. A pointcut declaration has two parts: a signature comprising a name and any
parameters and a pointcut expression that determines exactly which method
executions we are interested in. In the @AspectJ annotation-style of AOP, a pointcut
signature is provided by a regular method definition, and the pointcut expression is
indicated by using the <code>@Pointcut</code> annotation (the method serving as the pointcut signature
must have a <code>void</code> return type).</p>
</div>
<div class="paragraph">
<p>An example may help make this distinction between a pointcut signature and a pointcut
expression clear. The following example defines a pointcut named <code>anyOldTransfer</code> that
matches the execution of any method named <code>transfer</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Pointcut("execution(* transfer(..))") // the pointcut expression
private void anyOldTransfer() {} // the pointcut signature</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Pointcut("execution(* transfer(..))") // the pointcut expression
private fun anyOldTransfer() {} // the pointcut signature</code></pre>
</div>
</div>
<div class="paragraph">
<p>The pointcut expression that forms the value of the <code>@Pointcut</code> annotation is a regular
AspectJ pointcut expression. For a full discussion of AspectJ&#8217;s pointcut language, see
the <a href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html">AspectJ
Programming Guide</a> (and, for extensions, the
<a href="https://www.eclipse.org/aspectj/doc/released/adk15notebook/index.html">AspectJ 5
Developer&#8217;s Notebook</a>) or one of the books on AspectJ (such as <em>Eclipse AspectJ</em>, by Colyer
et. al., or <em>AspectJ in Action</em>, by Ramnivas Laddad).</p>
</div>
<div class="sect4">
<h5 id="aop-pointcuts-designators"><a class="anchor" href="#aop-pointcuts-designators"></a>Supported Pointcut Designators</h5>
<div class="paragraph">
<p>Spring AOP supports the following AspectJ pointcut designators (PCD) for use in pointcut
expressions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>execution</code>: For matching method execution join points. This is the primary
pointcut designator to use when working with Spring AOP.</p>
</li>
<li>
<p><code>within</code>: Limits matching to join points within certain types (the execution
of a method declared within a matching type when using Spring AOP).</p>
</li>
<li>
<p><code>this</code>: Limits matching to join points (the execution of methods when using Spring
AOP) where the bean reference (Spring AOP proxy) is an instance of the given type.</p>
</li>
<li>
<p><code>target</code>: Limits matching to join points (the execution of methods when using
Spring AOP) where the target object (application object being proxied) is an instance
of the given type.</p>
</li>
<li>
<p><code>args</code>: Limits matching to join points (the execution of methods when using Spring
AOP) where the arguments are instances of the given types.</p>
</li>
<li>
<p><code>@target</code>: Limits matching to join points (the execution of methods when using
Spring AOP) where the class of the executing object has an annotation of the given type.</p>
</li>
<li>
<p><code>@args</code>: Limits matching to join points (the execution of methods when using Spring
AOP) where the runtime type of the actual arguments passed have annotations of the
given types.</p>
</li>
<li>
<p><code>@within</code>: Limits matching to join points within types that have the given
annotation (the execution of methods declared in types with the given annotation when
using Spring AOP).</p>
</li>
<li>
<p><code>@annotation</code>: Limits matching to join points where the subject of the join point
(the method being run in Spring AOP) has the given annotation.</p>
</li>
</ul>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Other pointcut types</div>
<div class="paragraph">
<p>The full AspectJ pointcut language supports additional pointcut designators that are not
supported in Spring: <code>call</code>, <code>get</code>, <code>set</code>, <code>preinitialization</code>,
<code>staticinitialization</code>, <code>initialization</code>, <code>handler</code>, <code>adviceexecution</code>, <code>withincode</code>, <code>cflow</code>,
<code>cflowbelow</code>, <code>if</code>, <code>@this</code>, and <code>@withincode</code>. Use of these pointcut designators in pointcut
expressions interpreted by Spring AOP results in an <code>IllegalArgumentException</code> being
thrown.</p>
</div>
<div class="paragraph">
<p>The set of pointcut designators supported by Spring AOP may be extended in future
releases to support more of the AspectJ pointcut designators.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Because Spring AOP limits matching to only method execution join points, the preceding discussion
of the pointcut designators gives a narrower definition than you can find in the
AspectJ programming guide. In addition, AspectJ itself has type-based semantics and, at
an execution join point, both <code>this</code> and <code>target</code> refer to the same object: the
object executing the method. Spring AOP is a proxy-based system and differentiates
between the proxy object itself (which is bound to <code>this</code>) and the target object behind the
proxy (which is bound to <code>target</code>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Due to the proxy-based nature of Spring&#8217;s AOP framework, calls within the target object
are, by definition, not intercepted. For JDK proxies, only public interface method
calls on the proxy can be intercepted. With CGLIB, public and protected method calls on
the proxy are intercepted (and even package-visible methods, if necessary). However,
common interactions through proxies should always be designed through public signatures.</p>
</div>
<div class="paragraph">
<p>Note that pointcut definitions are generally matched against any intercepted method.
If a pointcut is strictly meant to be public-only, even in a CGLIB proxy scenario with
potential non-public interactions through proxies, it needs to be defined accordingly.</p>
</div>
<div class="paragraph">
<p>If your interception needs include method calls or even constructors within the target
class, consider the use of Spring-driven <a href="#aop-aj-ltw">native AspectJ weaving</a> instead
of Spring&#8217;s proxy-based AOP framework. This constitutes a different mode of AOP usage
with different characteristics, so be sure to make yourself familiar with weaving
before making a decision.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring AOP also supports an additional PCD named <code>bean</code>. This PCD lets you limit
the matching of join points to a particular named Spring bean or to a set of named
Spring beans (when using wildcards). The <code>bean</code> PCD has the following form:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">bean(idOrNameOfBean)</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">bean(idOrNameOfBean)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>idOrNameOfBean</code> token can be the name of any Spring bean. Limited wildcard
support that uses the <code>*</code> character is provided, so, if you establish some naming
conventions for your Spring beans, you can write a <code>bean</code> PCD expression
to select them. As is the case with other pointcut designators, the <code>bean</code> PCD can
be used with the <code>&amp;&amp;</code> (and), <code>||</code> (or), and <code>!</code> (negation) operators, too.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>bean</code> PCD is supported only in Spring AOP and not in
native AspectJ weaving. It is a Spring-specific extension to the standard PCDs that
AspectJ defines and is, therefore, not available for aspects declared in the <code>@Aspect</code> model.</p>
</div>
<div class="paragraph">
<p>The <code>bean</code> PCD operates at the instance level (building on the Spring bean name
concept) rather than at the type level only (to which weaving-based AOP is limited).
Instance-based pointcut designators are a special capability of Spring&#8217;s
proxy-based AOP framework and its close integration with the Spring bean factory, where
it is natural and straightforward to identify specific beans by name.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-pointcuts-combining"><a class="anchor" href="#aop-pointcuts-combining"></a>Combining Pointcut Expressions</h5>
<div class="paragraph">
<p>You can combine pointcut expressions by using <code>&amp;&amp;,</code> <code>||</code> and <code>!</code>. You can also refer to
pointcut expressions by name. The following example shows three pointcut expressions:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Pointcut("execution(public * *(..))")
private void anyPublicOperation() {} <i class="conum" data-value="1"></i><b>(1)</b>

@Pointcut("within(com.xyz.myapp.trading..*)")
private void inTrading() {} <i class="conum" data-value="2"></i><b>(2)</b>

@Pointcut("anyPublicOperation() &amp;&amp; inTrading()")
private void tradingOperation() {} <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>anyPublicOperation</code> matches if a method execution join point represents the execution
of any public method.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>inTrading</code> matches if a method execution is in the trading module.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>tradingOperation</code> matches if a method execution represents any public method in the
trading module.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Pointcut("execution(public * *(..))")
private fun anyPublicOperation() {} <i class="conum" data-value="1"></i><b>(1)</b>

@Pointcut("within(com.xyz.myapp.trading..*)")
private fun inTrading() {} <i class="conum" data-value="2"></i><b>(2)</b>

@Pointcut("anyPublicOperation() &amp;&amp; inTrading()")
private fun tradingOperation() {} <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>anyPublicOperation</code> matches if a method execution join point represents the execution
of any public method.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>inTrading</code> matches if a method execution is in the trading module.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>tradingOperation</code> matches if a method execution represents any public method in the
trading module.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is a best practice to build more complex pointcut expressions out of smaller named
components, as shown earlier. When referring to pointcuts by name, normal Java visibility
rules apply (you can see private pointcuts in the same type, protected pointcuts in the
hierarchy, public pointcuts anywhere, and so on). Visibility does not affect pointcut
matching.</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-common-pointcuts"><a class="anchor" href="#aop-common-pointcuts"></a>Sharing Common Pointcut Definitions</h5>
<div class="paragraph">
<p>When working with enterprise applications, developers often want to refer to modules of
the application and particular sets of operations from within several aspects. We
recommend defining a <code>CommonPointcuts</code> aspect that captures common pointcut expressions
for this purpose. Such an aspect typically resembles the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package com.xyz.myapp;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;

@Aspect
public class CommonPointcuts {

    /**
     * A join point is in the web layer if the method is defined
     * in a type in the com.xyz.myapp.web package or any sub-package
     * under that.
     */
    @Pointcut("within(com.xyz.myapp.web..*)")
    public void inWebLayer() {}

    /**
     * A join point is in the service layer if the method is defined
     * in a type in the com.xyz.myapp.service package or any sub-package
     * under that.
     */
    @Pointcut("within(com.xyz.myapp.service..*)")
    public void inServiceLayer() {}

    /**
     * A join point is in the data access layer if the method is defined
     * in a type in the com.xyz.myapp.dao package or any sub-package
     * under that.
     */
    @Pointcut("within(com.xyz.myapp.dao..*)")
    public void inDataAccessLayer() {}

    /**
     * A business service is the execution of any method defined on a service
     * interface. This definition assumes that interfaces are placed in the
     * "service" package, and that implementation types are in sub-packages.
     *
     * If you group service interfaces by functional area (for example,
     * in packages com.xyz.myapp.abc.service and com.xyz.myapp.def.service) then
     * the pointcut expression "execution(* com.xyz.myapp..service.*.*(..))"
     * could be used instead.
     *
     * Alternatively, you can write the expression using the 'bean'
     * PCD, like so "bean(*Service)". (This assumes that you have
     * named your Spring service beans in a consistent fashion.)
     */
    @Pointcut("execution(* com.xyz.myapp..service.*.*(..))")
    public void businessService() {}

    /**
     * A data access operation is the execution of any method defined on a
     * dao interface. This definition assumes that interfaces are placed in the
     * "dao" package, and that implementation types are in sub-packages.
     */
    @Pointcut("execution(* com.xyz.myapp.dao.*.*(..))")
    public void dataAccessOperation() {}

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package com.xyz.myapp

import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.Pointcut

@Aspect
class CommonPointcuts {

    /**
    * A join point is in the web layer if the method is defined
    * in a type in the com.xyz.myapp.web package or any sub-package
    * under that.
    */
    @Pointcut("within(com.xyz.myapp.web..*)")
    fun inWebLayer() {
    }

    /**
    * A join point is in the service layer if the method is defined
    * in a type in the com.xyz.myapp.service package or any sub-package
    * under that.
    */
    @Pointcut("within(com.xyz.myapp.service..*)")
    fun inServiceLayer() {
    }

    /**
    * A join point is in the data access layer if the method is defined
    * in a type in the com.xyz.myapp.dao package or any sub-package
    * under that.
    */
    @Pointcut("within(com.xyz.myapp.dao..*)")
    fun inDataAccessLayer() {
    }

    /**
    * A business service is the execution of any method defined on a service
    * interface. This definition assumes that interfaces are placed in the
    * "service" package, and that implementation types are in sub-packages.
    *
    * If you group service interfaces by functional area (for example,
    * in packages com.xyz.myapp.abc.service and com.xyz.myapp.def.service) then
    * the pointcut expression "execution(* com.xyz.myapp..service.*.*(..))"
    * could be used instead.
    *
    * Alternatively, you can write the expression using the 'bean'
    * PCD, like so "bean(*Service)". (This assumes that you have
    * named your Spring service beans in a consistent fashion.)
    */
    @Pointcut("execution(* com.xyz.myapp..service.*.*(..))")
    fun businessService() {
    }

    /**
    * A data access operation is the execution of any method defined on a
    * dao interface. This definition assumes that interfaces are placed in the
    * "dao" package, and that implementation types are in sub-packages.
    */
    @Pointcut("execution(* com.xyz.myapp.dao.*.*(..))")
    fun dataAccessOperation() {
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can refer to the pointcuts defined in such an aspect anywhere you need a
pointcut expression. For example, to make the service layer transactional, you could
write the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:config&gt;
    &lt;aop:advisor
        pointcut="com.xyz.myapp.CommonPointcuts.businessService()"
        advice-ref="tx-advice"/&gt;
&lt;/aop:config&gt;

&lt;tx:advice id="tx-advice"&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name="*" propagation="REQUIRED"/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>&lt;aop:config&gt;</code> and <code>&lt;aop:advisor&gt;</code> elements are discussed in <a href="#aop-schema">Schema-based AOP Support</a>. The
transaction elements are discussed in <a href="data-access.html#transaction">Transaction Management</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-pointcuts-examples"><a class="anchor" href="#aop-pointcuts-examples"></a>Examples</h5>
<div class="paragraph">
<p>Spring AOP users are likely to use the <code>execution</code> pointcut designator the most often.
The format of an execution expression follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>    execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)
                throws-pattern?)</pre>
</div>
</div>
<div class="paragraph">
<p>All parts except the returning type pattern (<code>ret-type-pattern</code> in the preceding snippet),
the name pattern, and the parameters pattern are optional. The returning type pattern determines
what the return type of the method must be in order for a join point to be matched.
<code>*</code> is most frequently used as the returning type pattern. It matches any return
type. A fully-qualified type name matches only when the method returns the given
type. The name pattern matches the method name. You can use the <code>*</code> wildcard as all or
part of a name pattern. If you specify a declaring type pattern,
include a trailing <code>.</code> to join it to the name pattern component.
The parameters pattern is slightly more complex: <code>()</code> matches a
method that takes no parameters, whereas <code>(..)</code> matches any number (zero or more) of parameters.
The <code>(*)</code> pattern matches a method that takes one parameter of any type.
<code>(*,String)</code> matches a method that takes two parameters. The first can be of any type, while the
second must be a <code>String</code>. Consult the
<a href="https://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html">Language
Semantics</a> section of the AspectJ Programming Guide for more information.</p>
</div>
<div class="paragraph">
<p>The following examples show some common pointcut expressions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The execution of any public method:</p>
<div class="literalblock">
<div class="content">
<pre>    execution(public * *(..))</pre>
</div>
</div>
</li>
<li>
<p>The execution of any method with a name that begins with <code>set</code>:</p>
<div class="literalblock">
<div class="content">
<pre>    execution(* set*(..))</pre>
</div>
</div>
</li>
<li>
<p>The execution of any method defined by the <code>AccountService</code> interface:</p>
<div class="literalblock">
<div class="content">
<pre>    execution(* com.xyz.service.AccountService.*(..))</pre>
</div>
</div>
</li>
<li>
<p>The execution of any method defined in the <code>service</code> package:</p>
<div class="literalblock">
<div class="content">
<pre>    execution(* com.xyz.service.*.*(..))</pre>
</div>
</div>
</li>
<li>
<p>The execution of any method defined in the service package or one of its sub-packages:</p>
<div class="literalblock">
<div class="content">
<pre>    execution(* com.xyz.service..*.*(..))</pre>
</div>
</div>
</li>
<li>
<p>Any join point (method execution only in Spring AOP) within the service package:</p>
<div class="literalblock">
<div class="content">
<pre>    within(com.xyz.service.*)</pre>
</div>
</div>
</li>
<li>
<p>Any join point (method execution only in Spring AOP) within the service package or one of its
sub-packages:</p>
<div class="literalblock">
<div class="content">
<pre>    within(com.xyz.service..*)</pre>
</div>
</div>
</li>
<li>
<p>Any join point (method execution only in Spring AOP) where the proxy implements the
<code>AccountService</code> interface:</p>
<div class="literalblock">
<div class="content">
<pre>    this(com.xyz.service.AccountService)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
'this' is more commonly used in a binding form. See the section on <a href="#aop-advice">Declaring Advice</a>
for how to make the proxy object available in the advice body.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Any join point (method execution only in Spring AOP) where the target object
implements the <code>AccountService</code> interface:</p>
<div class="literalblock">
<div class="content">
<pre>    target(com.xyz.service.AccountService)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
'target' is more commonly used in a binding form. See the <a href="#aop-advice">Declaring Advice</a> section
for how to make the target object available in the advice body.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Any join point (method execution only in Spring AOP) that takes a single parameter
and where the argument passed at runtime is <code>Serializable</code>:</p>
<div class="literalblock">
<div class="content">
<pre>    args(java.io.Serializable)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
'args' is more commonly used in a binding form. See the <a href="#aop-advice">Declaring Advice</a> section
for how to make the method arguments available in the advice body.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that the pointcut given in this example is different from <code>execution(*
*(java.io.Serializable))</code>. The args version matches if the argument passed at runtime is
<code>Serializable</code>, and the execution version matches if the method signature declares a single
parameter of type <code>Serializable</code>.</p>
</div>
</li>
<li>
<p>Any join point (method execution only in Spring AOP) where the target object has a
<code>@Transactional</code> annotation:</p>
<div class="literalblock">
<div class="content">
<pre>    @target(org.springframework.transaction.annotation.Transactional)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can also use '@target' in a binding form. See the <a href="#aop-advice">Declaring Advice</a> section for
how to make the annotation object available in the advice body.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Any join point (method execution only in Spring AOP) where the declared type of the
target object has an <code>@Transactional</code> annotation:</p>
<div class="literalblock">
<div class="content">
<pre>    @within(org.springframework.transaction.annotation.Transactional)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can also use '@within' in a binding form. See the <a href="#aop-advice">Declaring Advice</a> section for
how to make the annotation object available in the advice body.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Any join point (method execution only in Spring AOP) where the executing method has an
<code>@Transactional</code> annotation:</p>
<div class="literalblock">
<div class="content">
<pre>    @annotation(org.springframework.transaction.annotation.Transactional)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can also use '@annotation' in a binding form. See the <a href="#aop-advice">Declaring Advice</a> section
for how to make the annotation object available in the advice body.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Any join point (method execution only in Spring AOP) which takes a single parameter,
and where the runtime type of the argument passed has the <code>@Classified</code> annotation:</p>
<div class="literalblock">
<div class="content">
<pre>    @args(com.xyz.security.Classified)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can also use '@args' in a binding form. See the <a href="#aop-advice">Declaring Advice</a> section
how to make the annotation object(s) available in the advice body.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Any join point (method execution only in Spring AOP) on a Spring bean named
<code>tradeService</code>:</p>
<div class="literalblock">
<div class="content">
<pre>    bean(tradeService)</pre>
</div>
</div>
</li>
<li>
<p>Any join point (method execution only in Spring AOP) on Spring beans having names that
match the wildcard expression <code>*Service</code>:</p>
<div class="literalblock">
<div class="content">
<pre>    bean(*Service)</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="writing-good-pointcuts"><a class="anchor" href="#writing-good-pointcuts"></a>Writing Good Pointcuts</h5>
<div class="paragraph">
<p>During compilation, AspectJ processes pointcuts in order to optimize matching
performance. Examining code and determining if each join point matches (statically or
dynamically) a given pointcut is a costly process. (A dynamic match means the match
cannot be fully determined from static analysis and that a test is placed in the code to
determine if there is an actual match when the code is running). On first encountering a
pointcut declaration, AspectJ rewrites it into an optimal form for the matching
process. What does this mean? Basically, pointcuts are rewritten in DNF (Disjunctive
Normal Form) and the components of the pointcut are sorted such that those components
that are cheaper to evaluate are checked first. This means you do not have to worry
about understanding the performance of various pointcut designators and may supply them
in any order in a pointcut declaration.</p>
</div>
<div class="paragraph">
<p>However, AspectJ can work only with what it is told. For optimal performance of
matching, you should think about what they are trying to achieve and narrow the search
space for matches as much as possible in the definition. The existing designators
naturally fall into one of three groups: kinded, scoping, and contextual:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Kinded designators select a particular kind of join point:
<code>execution</code>, <code>get</code>, <code>set</code>, <code>call</code>, and <code>handler</code>.</p>
</li>
<li>
<p>Scoping designators select a group of join points of interest
(probably of many kinds): <code>within</code> and <code>withincode</code></p>
</li>
<li>
<p>Contextual designators match (and optionally bind) based on context:
<code>this</code>, <code>target</code>, and <code>@annotation</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A well written pointcut should include at least the first two types (kinded and
scoping). You can include the contextual designators to match based on
join point context or bind that context for use in the advice. Supplying only a
kinded designator or only a contextual designator works but could affect weaving
performance (time and memory used), due to extra processing and analysis. Scoping
designators are very fast to match, and using them usage means AspectJ can very quickly
dismiss groups of join points that should not be further processed. A good
pointcut should always include one if possible.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-advice"><a class="anchor" href="#aop-advice"></a>5.4.4. Declaring Advice</h4>
<div class="paragraph">
<p>Advice is associated with a pointcut expression and runs before, after, or around
method executions matched by the pointcut. The pointcut expression may be either a
simple reference to a named pointcut or a pointcut expression declared in place.</p>
</div>
<div class="sect4">
<h5 id="aop-advice-before"><a class="anchor" href="#aop-advice-before"></a>Before Advice</h5>
<div class="paragraph">
<p>You can declare before advice in an aspect by using the <code>@Before</code> annotation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect
public class BeforeExample {

    @Before("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")
    public void doAccessCheck() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.Before

@Aspect
class BeforeExample {

    @Before("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")
    fun doAccessCheck() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If we use an in-place pointcut expression, we could rewrite the preceding example as the
following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect
public class BeforeExample {

    @Before("execution(* com.xyz.myapp.dao.*.*(..))")
    public void doAccessCheck() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.Before

@Aspect
class BeforeExample {

    @Before("execution(* com.xyz.myapp.dao.*.*(..))")
    fun doAccessCheck() {
        // ...
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-advice-after-returning"><a class="anchor" href="#aop-advice-after-returning"></a>After Returning Advice</h5>
<div class="paragraph">
<p>After returning advice runs when a matched method execution returns normally.
You can declare it by using the <code>@AfterReturning</code> annotation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterReturning;

@Aspect
public class AfterReturningExample {

    @AfterReturning("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")
    public void doAccessCheck() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.AfterReturning

@Aspect
class AfterReturningExample {

    @AfterReturning("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")
    fun doAccessCheck() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You can have multiple advice declarations (and other members as well),
all inside the same aspect. We show only a single advice declaration in these
examples to focus the effect of each one.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Sometimes, you need access in the advice body to the actual value that was returned.
You can use the form of <code>@AfterReturning</code> that binds the return value to get that
access, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterReturning;

@Aspect
public class AfterReturningExample {

    @AfterReturning(
        pointcut="com.xyz.myapp.CommonPointcuts.dataAccessOperation()",
        returning="retVal")
    public void doAccessCheck(Object retVal) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.AfterReturning

@Aspect
class AfterReturningExample {

    @AfterReturning(
        pointcut = "com.xyz.myapp.CommonPointcuts.dataAccessOperation()",
        returning = "retVal")
    fun doAccessCheck(retVal: Any) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The name used in the <code>returning</code> attribute must correspond to the name of a parameter
in the advice method. When a method execution returns, the return value is passed to
the advice method as the corresponding argument value. A <code>returning</code> clause also
restricts matching to only those method executions that return a value of the
specified type (in this case, <code>Object</code>, which matches any return value).</p>
</div>
<div class="paragraph">
<p>Please note that it is not possible to return a totally different reference when
using after returning advice.</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-advice-after-throwing"><a class="anchor" href="#aop-advice-after-throwing"></a>After Throwing Advice</h5>
<div class="paragraph">
<p>After throwing advice runs when a matched method execution exits by throwing an
exception. You can declare it by using the <code>@AfterThrowing</code> annotation, as the
following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterThrowing;

@Aspect
public class AfterThrowingExample {

    @AfterThrowing("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")
    public void doRecoveryActions() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.AfterThrowing

@Aspect
class AfterThrowingExample {

    @AfterThrowing("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")
    fun doRecoveryActions() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Often, you want the advice to run only when exceptions of a given type are thrown,
and you also often need access to the thrown exception in the advice body. You can
use the <code>throwing</code> attribute to both restrict matching (if desired&#8201;&#8212;&#8201;use <code>Throwable</code>
as the exception type otherwise) and bind the thrown exception to an advice parameter.
The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterThrowing;

@Aspect
public class AfterThrowingExample {

    @AfterThrowing(
        pointcut="com.xyz.myapp.CommonPointcuts.dataAccessOperation()",
        throwing="ex")
    public void doRecoveryActions(DataAccessException ex) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.AfterThrowing

@Aspect
class AfterThrowingExample {

    @AfterThrowing(
        pointcut = "com.xyz.myapp.CommonPointcuts.dataAccessOperation()",
        throwing = "ex")
    fun doRecoveryActions(ex: DataAccessException) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The name used in the <code>throwing</code> attribute must correspond to the name of a parameter in
the advice method. When a method execution exits by throwing an exception, the exception
is passed to the advice method as the corresponding argument value. A <code>throwing</code> clause
also restricts matching to only those method executions that throw an exception of the
specified type (<code>DataAccessException</code>, in this case).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Note that <code>@AfterThrowing</code> does not indicate a general exception handling callback.
Specifically, an <code>@AfterThrowing</code> advice method is only supposed to receive exceptions
from the join point (user-declared target method) itself but not from an accompanying
<code>@After</code>/<code>@AfterReturning</code> method.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-advice-after-finally"><a class="anchor" href="#aop-advice-after-finally"></a>After (Finally) Advice</h5>
<div class="paragraph">
<p>After (finally) advice runs when a matched method execution exits. It is declared by
using the <code>@After</code> annotation. After advice must be prepared to handle both normal and
exception return conditions. It is typically used for releasing resources and similar
purposes. The following example shows how to use after finally advice:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.After;

@Aspect
public class AfterFinallyExample {

    @After("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")
    public void doReleaseLock() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.After

@Aspect
class AfterFinallyExample {

    @After("com.xyz.myapp.CommonPointcuts.dataAccessOperation()")
    fun doReleaseLock() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Note that <code>@After</code> advice in AspectJ is defined as "after finally advice", analogous
to a finally block in a try-catch statement. It will be invoked for any outcome,
normal return or exception thrown from the join point (user-declared target method),
in contrast to <code>@AfterReturning</code> which only applies to successful normal returns.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-ataspectj-around-advice"><a class="anchor" href="#aop-ataspectj-around-advice"></a>Around Advice</h5>
<div class="paragraph">
<p>The last kind of advice is around advice. Around advice runs &#8220;around&#8221; a matched
method&#8217;s execution. It has the opportunity to do work both before and after the method
runs and to determine when, how, and even if the method actually gets to run at all.
Around advice is often used if you need to share state before and after a method
execution in a thread-safe manner (starting and stopping a timer, for example).
Always use the least powerful form of advice that meets your requirements (that is,
do not use around advice if before advice would do).</p>
</div>
<div class="paragraph">
<p>Around advice is declared by using the <code>@Around</code> annotation. The first parameter of the
advice method must be of type <code>ProceedingJoinPoint</code>. Within the body of the advice,
calling <code>proceed()</code> on the <code>ProceedingJoinPoint</code> causes the underlying method to run.
The <code>proceed</code> method can also pass in an <code>Object[]</code>. The values in the array are used
as the arguments to the method execution when it proceeds.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The behavior of <code>proceed</code> when called with an <code>Object[]</code> is a little different than
the behavior of <code>proceed</code> for around advice compiled by the AspectJ compiler. For around
advice written using the traditional AspectJ language, the number of arguments passed to
<code>proceed</code> must match the number of arguments passed to the around advice (not the number
of arguments taken by the underlying join point), and the value passed to proceed in a
given argument position supplants the original value at the join point for the entity
the value was bound to (do not worry if this does not make sense right now). The approach
taken by Spring is simpler and a better match to its proxy-based, execution-only
semantics. You only need to be aware of this difference if you compile @AspectJ
aspects written for Spring and use <code>proceed</code> with arguments with the AspectJ compiler
and weaver. There is a way to write such aspects that is 100% compatible across both
Spring AOP and AspectJ, and this is discussed in the
<a href="#aop-ataspectj-advice-params">following section on advice parameters</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows how to use around advice:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.ProceedingJoinPoint;

@Aspect
public class AroundExample {

    @Around("com.xyz.myapp.CommonPointcuts.businessService()")
    public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {
        // start stopwatch
        Object retVal = pjp.proceed();
        // stop stopwatch
        return retVal;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.Around
import org.aspectj.lang.ProceedingJoinPoint

@Aspect
class AroundExample {

    @Around("com.xyz.myapp.CommonPointcuts.businessService()")
    fun doBasicProfiling(pjp: ProceedingJoinPoint): Any {
        // start stopwatch
        val retVal = pjp.proceed()
        // stop stopwatch
        return retVal
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value returned by the around advice is the return value seen by the caller of the
method. For example, a simple caching aspect could return a value from a cache if it
has one and invoke <code>proceed()</code> if it does not. Note that <code>proceed</code> may be invoked once,
many times, or not at all within the body of the around advice. All of these are legal.</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-ataspectj-advice-params"><a class="anchor" href="#aop-ataspectj-advice-params"></a>Advice Parameters</h5>
<div class="paragraph">
<p>Spring offers fully typed advice, meaning that you declare the parameters you need in the
advice signature (as we saw earlier for the returning and throwing examples) rather than
work with <code>Object[]</code> arrays all the time. We see how to make argument and other contextual
values available to the advice body later in this section. First, we take a look at how to
write generic advice that can find out about the method the advice is currently advising.</p>
</div>
<div class="sect5">
<h6 id="aop-ataspectj-advice-params-the-joinpoint"><a class="anchor" href="#aop-ataspectj-advice-params-the-joinpoint"></a>Access to the Current <code>JoinPoint</code></h6>
<div class="paragraph">
<p>Any advice method may declare, as its first parameter, a parameter of type
<code>org.aspectj.lang.JoinPoint</code> (note that around advice is required to declare a first
parameter of type <code>ProceedingJoinPoint</code>, which is a subclass of <code>JoinPoint</code>.
The <code>JoinPoint</code> interface provides a number of useful methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getArgs()</code>: Returns the method arguments.</p>
</li>
<li>
<p><code>getThis()</code>: Returns the proxy object.</p>
</li>
<li>
<p><code>getTarget()</code>: Returns the target object.</p>
</li>
<li>
<p><code>getSignature()</code>: Returns a description of the method that is being advised.</p>
</li>
<li>
<p><code>toString()</code>: Prints a useful description of the method being advised.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the <a href="https://www.eclipse.org/aspectj/doc/released/runtime-api/org/aspectj/lang/JoinPoint.html">javadoc</a> for more detail.</p>
</div>
</div>
<div class="sect5">
<h6 id="aop-ataspectj-advice-params-passing"><a class="anchor" href="#aop-ataspectj-advice-params-passing"></a>Passing Parameters to Advice</h6>
<div class="paragraph">
<p>We have already seen how to bind the returned value or exception value (using after
returning and after throwing advice). To make argument values available to the advice
body, you can use the binding form of <code>args</code>. If you use a parameter name in place of a
type name in an args expression, the value of the corresponding argument is passed as
the parameter value when the advice is invoked. An example should make this clearer.
Suppose you want to advise the execution of DAO operations that take an <code>Account</code>
object as the first parameter, and you need access to the account in the advice body.
You could write the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Before("com.xyz.myapp.CommonPointcuts.dataAccessOperation() &amp;&amp; args(account,..)")
public void validateAccount(Account account) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Before("com.xyz.myapp.CommonPointcuts.dataAccessOperation() &amp;&amp; args(account,..)")
fun validateAccount(account: Account) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>args(account,..)</code> part of the pointcut expression serves two purposes. First, it
restricts matching to only those method executions where the method takes at least one
parameter, and the argument passed to that parameter is an instance of <code>Account</code>.
Second, it makes the actual <code>Account</code> object available to the advice through the <code>account</code>
parameter.</p>
</div>
<div class="paragraph">
<p>Another way of writing this is to declare a pointcut that &#8220;provides&#8221; the <code>Account</code>
object value when it matches a join point, and then refer to the named pointcut
from the advice. This would look as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Pointcut("com.xyz.myapp.CommonPointcuts.dataAccessOperation() &amp;&amp; args(account,..)")
private void accountDataAccessOperation(Account account) {}

@Before("accountDataAccessOperation(account)")
public void validateAccount(Account account) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Pointcut("com.xyz.myapp.CommonPointcuts.dataAccessOperation() &amp;&amp; args(account,..)")
private fun accountDataAccessOperation(account: Account) {
}

@Before("accountDataAccessOperation(account)")
fun validateAccount(account: Account) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the AspectJ programming guide for more
details.</p>
</div>
<div class="paragraph">
<p>The proxy object ( <code>this</code>), target object ( <code>target</code>), and annotations ( <code>@within</code>,
<code>@target</code>, <code>@annotation</code>, and <code>@args</code>) can all be bound in a similar fashion. The next two
examples show how to match the execution of methods annotated with an
<code>@Auditable</code> annotation and extract the audit code:</p>
</div>
<div class="paragraph">
<p>The first of the two examples shows the definition of the <code>@Auditable</code> annotation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Auditable {
    AuditCode value();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Retention(AnnotationRetention.RUNTIME)
@Target(AnnotationTarget.FUNCTION)
annotation class Auditable(val value: AuditCode)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second of the two examples shows the advice that matches the execution of <code>@Auditable</code> methods:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Before("com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; @annotation(auditable)")
public void audit(Auditable auditable) {
    AuditCode code = auditable.value();
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Before("com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; @annotation(auditable)")
fun audit(auditable: Auditable) {
    val code = auditable.value()
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="aop-ataspectj-advice-params-generics"><a class="anchor" href="#aop-ataspectj-advice-params-generics"></a>Advice Parameters and Generics</h6>
<div class="paragraph">
<p>Spring AOP can handle generics used in class declarations and method parameters. Suppose
you have a generic type like the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface Sample&lt;T&gt; {
    void sampleGenericMethod(T param);
    void sampleGenericCollectionMethod(Collection&lt;T&gt; param);
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">interface Sample&lt;T&gt; {
    fun sampleGenericMethod(param: T)
    fun sampleGenericCollectionMethod(param: Collection&lt;T&gt;)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can restrict interception of method types to certain parameter types by
typing the advice parameter to the parameter type for which you want to intercept the method:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Before("execution(* ..Sample+.sampleGenericMethod(*)) &amp;&amp; args(param)")
public void beforeSampleMethod(MyType param) {
    // Advice implementation
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Before("execution(* ..Sample+.sampleGenericMethod(*)) &amp;&amp; args(param)")
fun beforeSampleMethod(param: MyType) {
    // Advice implementation
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This approach does not work for generic collections. So you cannot define a
pointcut as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Before("execution(* ..Sample+.sampleGenericCollectionMethod(*)) &amp;&amp; args(param)")
public void beforeSampleMethod(Collection&lt;MyType&gt; param) {
    // Advice implementation
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Before("execution(* ..Sample+.sampleGenericCollectionMethod(*)) &amp;&amp; args(param)")
fun beforeSampleMethod(param: Collection&lt;MyType&gt;) {
    // Advice implementation
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To make this work, we would have to inspect every element of the collection, which is not
reasonable, as we also cannot decide how to treat <code>null</code> values in general. To achieve
something similar to this, you have to type the parameter to <code>Collection&lt;?&gt;</code> and manually
check the type of the elements.</p>
</div>
</div>
<div class="sect5">
<h6 id="aop-ataspectj-advice-params-names"><a class="anchor" href="#aop-ataspectj-advice-params-names"></a>Determining Argument Names</h6>
<div class="paragraph">
<p>The parameter binding in advice invocations relies on matching names used in pointcut
expressions to declared parameter names in advice and pointcut method signatures.
Parameter names are not available through Java reflection, so Spring AOP uses the
following strategy to determine parameter names:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the parameter names have been explicitly specified by the user, the specified
parameter names are used. Both the advice and the pointcut annotations have
an optional <code>argNames</code> attribute that you can use to specify the argument names of
the annotated method. These argument names are available at runtime. The following example
shows how to use the <code>argNames</code> attribute:</p>
</li>
</ul>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Before(value="com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)",
        argNames="bean,auditable")
public void audit(Object bean, Auditable auditable) {
    AuditCode code = auditable.value();
    // ... use code and bean
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Before(value = "com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)", argNames = "bean,auditable")
fun audit(bean: Any, auditable: Auditable) {
    val code = auditable.value()
    // ... use code and bean
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the first parameter is of the <code>JoinPoint</code>, <code>ProceedingJoinPoint</code>, or
<code>JoinPoint.StaticPart</code> type, you can leave out the name of the parameter from the value
of the <code>argNames</code> attribute. For example, if you modify the preceding advice to receive
the join point object, the <code>argNames</code> attribute need not include it:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Before(value="com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)",
        argNames="bean,auditable")
public void audit(JoinPoint jp, Object bean, Auditable auditable) {
    AuditCode code = auditable.value();
    // ... use code, bean, and jp
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Before(value = "com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)", argNames = "bean,auditable")
fun audit(jp: JoinPoint, bean: Any, auditable: Auditable) {
    val code = auditable.value()
    // ... use code, bean, and jp
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The special treatment given to the first parameter of the <code>JoinPoint</code>,
<code>ProceedingJoinPoint</code>, and <code>JoinPoint.StaticPart</code> types is particularly convenient for
advice instances that do not collect any other join point context. In such situations, you may
omit the <code>argNames</code> attribute. For example, the following advice need not declare
the <code>argNames</code> attribute:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Before("com.xyz.lib.Pointcuts.anyPublicMethod()")
public void audit(JoinPoint jp) {
    // ... use jp
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Before("com.xyz.lib.Pointcuts.anyPublicMethod()")
fun audit(jp: JoinPoint) {
    // ... use jp
}</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Using the <code>'argNames'</code> attribute is a little clumsy, so if the <code>'argNames'</code> attribute
has not been specified, Spring AOP looks at the debug information for the
class and tries to determine the parameter names from the local variable table. This
information is present as long as the classes have been compiled with debug
information ( <code>'-g:vars'</code> at a minimum). The consequences of compiling with this flag
on are: (1) your code is slightly easier to understand (reverse engineer), (2)
the class file sizes are very slightly bigger (typically inconsequential), (3) the
optimization to remove unused local variables is not applied by your compiler. In
other words, you should encounter no difficulties by building with this flag on.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If an @AspectJ aspect has been compiled by the AspectJ compiler (ajc) even without the
debug information, you need not add the <code>argNames</code> attribute, as the compiler
retain the needed information.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>If the code has been compiled without the necessary debug information, Spring AOP
tries to deduce the pairing of binding variables to parameters (for example, if
only one variable is bound in the pointcut expression, and the advice method
takes only one parameter, the pairing is obvious). If the binding of variables is
ambiguous given the available information, an <code>AmbiguousBindingException</code> is
thrown.</p>
</li>
<li>
<p>If all of the above strategies fail, an <code>IllegalArgumentException</code> is thrown.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="aop-ataspectj-advice-proceeding-with-the-call"><a class="anchor" href="#aop-ataspectj-advice-proceeding-with-the-call"></a>Proceeding with Arguments</h6>
<div class="paragraph">
<p>We remarked earlier that we would describe how to write a <code>proceed</code> call with
arguments that works consistently across Spring AOP and AspectJ. The solution is
to ensure that the advice signature binds each of the method parameters in order.
The following example shows how to do so:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Around("execution(List&lt;Account&gt; find*(..)) &amp;&amp; " +
        "com.xyz.myapp.CommonPointcuts.inDataAccessLayer() &amp;&amp; " +
        "args(accountHolderNamePattern)")
public Object preProcessQueryPattern(ProceedingJoinPoint pjp,
        String accountHolderNamePattern) throws Throwable {
    String newPattern = preProcess(accountHolderNamePattern);
    return pjp.proceed(new Object[] {newPattern});
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Around("execution(List&lt;Account&gt; find*(..)) &amp;&amp; " +
        "com.xyz.myapp.CommonPointcuts.inDataAccessLayer() &amp;&amp; " +
        "args(accountHolderNamePattern)")
fun preProcessQueryPattern(pjp: ProceedingJoinPoint,
                        accountHolderNamePattern: String): Any {
    val newPattern = preProcess(accountHolderNamePattern)
    return pjp.proceed(arrayOf&lt;Any&gt;(newPattern))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In many cases, you do this binding anyway (as in the preceding example).</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-ataspectj-advice-ordering"><a class="anchor" href="#aop-ataspectj-advice-ordering"></a>Advice Ordering</h5>
<div class="paragraph">
<p>What happens when multiple pieces of advice all want to run at the same join point?
Spring AOP follows the same precedence rules as AspectJ to determine the order of advice
execution. The highest precedence advice runs first "on the way in" (so, given two pieces
of before advice, the one with highest precedence runs first). "On the way out" from a
join point, the highest precedence advice runs last (so, given two pieces of after
advice, the one with the highest precedence will run second).</p>
</div>
<div class="paragraph">
<p>When two pieces of advice defined in different aspects both need to run at the same
join point, unless you specify otherwise, the order of execution is undefined. You can
control the order of execution by specifying precedence. This is done in the normal
Spring way by either implementing the <code>org.springframework.core.Ordered</code> interface in
the aspect class or annotating it with the <code>@Order</code> annotation. Given two aspects, the
aspect returning the lower value from <code>Ordered.getOrder()</code> (or the annotation value) has
the higher precedence.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Each of the distinct advice types of a particular aspect is conceptually meant to apply
to the join point directly. As a consequence, an <code>@AfterThrowing</code> advice method is not
supposed to receive an exception from an accompanying <code>@After</code>/<code>@AfterReturning</code> method.</p>
</div>
<div class="paragraph">
<p>As of Spring Framework 5.2.7, advice methods defined in the same <code>@Aspect</code> class that
need to run at the same join point are assigned precedence based on their advice type in
the following order, from highest to lowest precedence: <code>@Around</code>, <code>@Before</code>, <code>@After</code>,
<code>@AfterReturning</code>, <code>@AfterThrowing</code>. Note, however, that an <code>@After</code> advice method will
effectively be invoked after any <code>@AfterReturning</code> or <code>@AfterThrowing</code> advice methods
in the same aspect, following AspectJ&#8217;s "after finally advice" semantics for <code>@After</code>.</p>
</div>
<div class="paragraph">
<p>When two pieces of the same type of advice (for example, two <code>@After</code> advice methods)
defined in the same <code>@Aspect</code> class both need to run at the same join point, the ordering
is undefined (since there is no way to retrieve the source code declaration order through
reflection for javac-compiled classes). Consider collapsing such advice methods into one
advice method per join point in each <code>@Aspect</code> class or refactor the pieces of advice into
separate <code>@Aspect</code> classes that you can order at the aspect level via <code>Ordered</code> or <code>@Order</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-introductions"><a class="anchor" href="#aop-introductions"></a>5.4.5. Introductions</h4>
<div class="paragraph">
<p>Introductions (known as inter-type declarations in AspectJ) enable an aspect to declare
that advised objects implement a given interface, and to provide an implementation of
that interface on behalf of those objects.</p>
</div>
<div class="paragraph">
<p>You can make an introduction by using the <code>@DeclareParents</code> annotation. This annotation
is used to declare that matching types have a new parent (hence the name). For example,
given an interface named <code>UsageTracked</code> and an implementation of that interface named
<code>DefaultUsageTracked</code>, the following aspect declares that all implementors of service
interfaces also implement the <code>UsageTracked</code> interface (e.g. for statistics via JMX):</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Aspect
public class UsageTracking {

    @DeclareParents(value="com.xzy.myapp.service.*+", defaultImpl=DefaultUsageTracked.class)
    public static UsageTracked mixin;

    @Before("com.xyz.myapp.CommonPointcuts.businessService() &amp;&amp; this(usageTracked)")
    public void recordUsage(UsageTracked usageTracked) {
        usageTracked.incrementUseCount();
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Aspect
class UsageTracking {

    companion object {
        @DeclareParents(value = "com.xzy.myapp.service.*+", defaultImpl = DefaultUsageTracked::class)
        lateinit var mixin: UsageTracked
    }

    @Before("com.xyz.myapp.CommonPointcuts.businessService() &amp;&amp; this(usageTracked)")
    fun recordUsage(usageTracked: UsageTracked) {
        usageTracked.incrementUseCount()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface to be implemented is determined by the type of the annotated field. The
<code>value</code> attribute of the <code>@DeclareParents</code> annotation is an AspectJ type pattern. Any
bean of a matching type implements the <code>UsageTracked</code> interface. Note that, in the
before advice of the preceding example, service beans can be directly used as
implementations of the <code>UsageTracked</code> interface. If accessing a bean programmatically,
you would write the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">UsageTracked usageTracked = (UsageTracked) context.getBean("myService");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val usageTracked = context.getBean("myService") as UsageTracked</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-instantiation-models"><a class="anchor" href="#aop-instantiation-models"></a>5.4.6. Aspect Instantiation Models</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is an advanced topic. If you are just starting out with AOP, you can safely skip
it until later.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By default, there is a single instance of each aspect within the application
context. AspectJ calls this the singleton instantiation model. It is possible to define
aspects with alternate lifecycles. Spring supports AspectJ&#8217;s <code>perthis</code> and <code>pertarget</code>
instantiation models; <code>percflow</code>, <code>percflowbelow</code>, and <code>pertypewithin</code> are not currently
supported.</p>
</div>
<div class="paragraph">
<p>You can declare a <code>perthis</code> aspect by specifying a <code>perthis</code> clause in the <code>@Aspect</code>
annotation. Consider the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Aspect("perthis(com.xyz.myapp.CommonPointcuts.businessService())")
public class MyAspect {

    private int someState;

    @Before("com.xyz.myapp.CommonPointcuts.businessService()")
    public void recordServiceUsage() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Aspect("perthis(com.xyz.myapp.CommonPointcuts.businessService())")
class MyAspect {

    private val someState: Int = 0

    @Before("com.xyz.myapp.CommonPointcuts.businessService()")
    fun recordServiceUsage() {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the preceding example, the effect of the <code>perthis</code> clause is that one aspect instance
is created for each unique service object that performs a business service (each unique
object bound to <code>this</code> at join points matched by the pointcut expression). The aspect
instance is created the first time that a method is invoked on the service object. The
aspect goes out of scope when the service object goes out of scope. Before the aspect
instance is created, none of the advice within it runs. As soon as the aspect instance
has been created, the advice declared within it runs at matched join points, but only
when the service object is the one with which this aspect is associated. See the AspectJ
Programming Guide for more information on <code>per</code> clauses.</p>
</div>
<div class="paragraph">
<p>The <code>pertarget</code> instantiation model works in exactly the same way as <code>perthis</code>, but it
creates one aspect instance for each unique target object at matched join points.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ataspectj-example"><a class="anchor" href="#aop-ataspectj-example"></a>5.4.7. An AOP Example</h4>
<div class="paragraph">
<p>Now that you have seen how all the constituent parts work, we can put them together to do
something useful.</p>
</div>
<div class="paragraph">
<p>The execution of business services can sometimes fail due to concurrency issues (for
example, a deadlock loser). If the operation is retried, it is likely to succeed
on the next try. For business services where it is appropriate to retry in such
conditions (idempotent operations that do not need to go back to the user for conflict
resolution), we want to transparently retry the operation to avoid the client seeing a
<code>PessimisticLockingFailureException</code>. This is a requirement that clearly cuts across
multiple services in the service layer and, hence, is ideal for implementing through an
aspect.</p>
</div>
<div class="paragraph">
<p>Because we want to retry the operation, we need to use around advice so that we can
call <code>proceed</code> multiple times. The following listing shows the basic aspect implementation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Aspect
public class ConcurrentOperationExecutor implements Ordered {

    private static final int DEFAULT_MAX_RETRIES = 2;

    private int maxRetries = DEFAULT_MAX_RETRIES;
    private int order = 1;

    public void setMaxRetries(int maxRetries) {
        this.maxRetries = maxRetries;
    }

    public int getOrder() {
        return this.order;
    }

    public void setOrder(int order) {
        this.order = order;
    }

    @Around("com.xyz.myapp.CommonPointcuts.businessService()")
    public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {
        int numAttempts = 0;
        PessimisticLockingFailureException lockFailureException;
        do {
            numAttempts++;
            try {
                return pjp.proceed();
            }
            catch(PessimisticLockingFailureException ex) {
                lockFailureException = ex;
            }
        } while(numAttempts &lt;= this.maxRetries);
        throw lockFailureException;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Aspect
class ConcurrentOperationExecutor : Ordered {

    private val DEFAULT_MAX_RETRIES = 2
    private var maxRetries = DEFAULT_MAX_RETRIES
    private var order = 1

    fun setMaxRetries(maxRetries: Int) {
        this.maxRetries = maxRetries
    }

    override fun getOrder(): Int {
        return this.order
    }

    fun setOrder(order: Int) {
        this.order = order
    }

    @Around("com.xyz.myapp.CommonPointcuts.businessService()")
    fun doConcurrentOperation(pjp: ProceedingJoinPoint): Any {
        var numAttempts = 0
        var lockFailureException: PessimisticLockingFailureException
        do {
            numAttempts++
            try {
                return pjp.proceed()
            } catch (ex: PessimisticLockingFailureException) {
                lockFailureException = ex
            }

        } while (numAttempts &lt;= this.maxRetries)
        throw lockFailureException
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the aspect implements the <code>Ordered</code> interface so that we can set the precedence of
the aspect higher than the transaction advice (we want a fresh transaction each time we
retry). The <code>maxRetries</code> and <code>order</code> properties are both configured by Spring. The
main action happens in the <code>doConcurrentOperation</code> around advice. Notice that, for the
moment, we apply the retry logic to each <code>businessService()</code>. We try to proceed,
and if we fail with a <code>PessimisticLockingFailureException</code>, we try again, unless
we have exhausted all of our retry attempts.</p>
</div>
<div class="paragraph">
<p>The corresponding Spring configuration follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:aspectj-autoproxy/&gt;

&lt;bean id="concurrentOperationExecutor" class="com.xyz.myapp.service.impl.ConcurrentOperationExecutor"&gt;
    &lt;property name="maxRetries" value="3"/&gt;
    &lt;property name="order" value="100"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To refine the aspect so that it retries only idempotent operations, we might define the following
<code>Idempotent</code> annotation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Retention(RetentionPolicy.RUNTIME)
public @interface Idempotent {
    // marker annotation
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Retention(AnnotationRetention.RUNTIME)
annotation class Idempotent// marker annotation</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can then use the annotation to annotate the implementation of service operations. The change
to the aspect to retry only idempotent operations involves refining the pointcut
expression so that only <code>@Idempotent</code> operations match, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Around("com.xyz.myapp.CommonPointcuts.businessService() &amp;&amp; " +
        "@annotation(com.xyz.myapp.service.Idempotent)")
public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Around("com.xyz.myapp.CommonPointcuts.businessService() &amp;&amp; " +
        "@annotation(com.xyz.myapp.service.Idempotent)")
fun doConcurrentOperation(pjp: ProceedingJoinPoint): Any {
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-schema"><a class="anchor" href="#aop-schema"></a>5.5. Schema-based AOP Support</h3>
<div class="paragraph">
<p>If you prefer an XML-based format, Spring also offers support for defining aspects
using the <code>aop</code> namespace tags. The exact same pointcut expressions and advice kinds
as when using the @AspectJ style are supported. Hence, in this section we focus on
that syntax and refer the reader to the discussion in the previous section
(<a href="#aop-ataspectj">@AspectJ support</a>) for an understanding of writing pointcut expressions and the binding
of advice parameters.</p>
</div>
<div class="paragraph">
<p>To use the aop namespace tags described in this section, you need to import the
<code>spring-aop</code> schema, as described in <a href="#xsd-schemas">XML Schema-based configuration</a>. See <a href="#xsd-schemas-aop">the AOP schema</a>
for how to import the tags in the <code>aop</code> namespace.</p>
</div>
<div class="paragraph">
<p>Within your Spring configurations, all aspect and advisor elements must be placed within
an <code>&lt;aop:config&gt;</code> element (you can have more than one <code>&lt;aop:config&gt;</code> element in an
application context configuration). An <code>&lt;aop:config&gt;</code> element can contain pointcut,
advisor, and aspect elements (note that these must be declared in that order).</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The <code>&lt;aop:config&gt;</code> style of configuration makes heavy use of Spring&#8217;s
<a href="#aop-autoproxy">auto-proxying</a> mechanism. This can cause issues (such as advice
not being woven) if you already use explicit auto-proxying through the use of
<code>BeanNameAutoProxyCreator</code> or something similar. The recommended usage pattern is to
use either only the <code>&lt;aop:config&gt;</code> style or only the <code>AutoProxyCreator</code> style and
never mix them.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="aop-schema-declaring-an-aspect"><a class="anchor" href="#aop-schema-declaring-an-aspect"></a>5.5.1. Declaring an Aspect</h4>
<div class="paragraph">
<p>When you use the schema support, an aspect is a regular Java object defined as a bean in
your Spring application context. The state and behavior are captured in the fields and
methods of the object, and the pointcut and advice information are captured in the XML.</p>
</div>
<div class="paragraph">
<p>You can declare an aspect by using the <code>&lt;aop:aspect&gt;</code> element, and reference the backing bean
by using the <code>ref</code> attribute, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:config&gt;
    &lt;aop:aspect id="myAspect" ref="aBean"&gt;
        ...
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;

&lt;bean id="aBean" class="..."&gt;
    ...
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The bean that backs the aspect (<code>aBean</code> in this case) can of course be configured and
dependency injected just like any other Spring bean.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-pointcuts"><a class="anchor" href="#aop-schema-pointcuts"></a>5.5.2. Declaring a Pointcut</h4>
<div class="paragraph">
<p>You can declare a named pointcut inside an <code>&lt;aop:config&gt;</code> element, letting the pointcut
definition be shared across several aspects and advisors.</p>
</div>
<div class="paragraph">
<p>A pointcut that represents the execution of any business service in the service layer can
be defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:config&gt;

    &lt;aop:pointcut id="businessService"
        expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;

&lt;/aop:config&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the pointcut expression itself is using the same AspectJ pointcut expression
language as described in <a href="#aop-ataspectj">@AspectJ support</a>. If you use the schema based declaration
style, you can refer to named pointcuts defined in types (@Aspects) within the
pointcut expression. Another way of defining the above pointcut would be as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:config&gt;

    &lt;aop:pointcut id="businessService"
        expression="com.xyz.myapp.CommonPointcuts.businessService()"/&gt;

&lt;/aop:config&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assume that you have a <code>CommonPointcuts</code> aspect as described in <a href="#aop-common-pointcuts">Sharing Common Pointcut Definitions</a>.</p>
</div>
<div class="paragraph">
<p>Then declaring a pointcut inside an aspect is very similar to declaring a top-level pointcut,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:config&gt;

    &lt;aop:aspect id="myAspect" ref="aBean"&gt;

        &lt;aop:pointcut id="businessService"
            expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;

        ...
    &lt;/aop:aspect&gt;

&lt;/aop:config&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In much the same way as an @AspectJ aspect, pointcuts declared by using the schema based
definition style can collect join point context. For example, the following pointcut
collects the <code>this</code> object as the join point context and passes it to the advice:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:config&gt;

    &lt;aop:aspect id="myAspect" ref="aBean"&gt;

        &lt;aop:pointcut id="businessService"
            expression="execution(* com.xyz.myapp.service.*.*(..)) &amp;amp;&amp;amp; this(service)"/&gt;

        &lt;aop:before pointcut-ref="businessService" method="monitor"/&gt;

        ...
    &lt;/aop:aspect&gt;

&lt;/aop:config&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The advice must be declared to receive the collected join point context by including
parameters of the matching names, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public void monitor(Object service) {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun monitor(service: Any) {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When combining pointcut sub-expressions, <code>&amp;amp;&amp;amp;</code> is awkward within an XML
document, so you can use the <code>and</code>, <code>or</code>, and <code>not</code> keywords in place of <code>&amp;amp;&amp;amp;</code>,
<code>||</code>, and <code>!</code>, respectively. For example, the previous pointcut can be better written as
follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:config&gt;

    &lt;aop:aspect id="myAspect" ref="aBean"&gt;

        &lt;aop:pointcut id="businessService"
            expression="execution(* com.xyz.myapp.service.*.*(..)) and this(service)"/&gt;

        &lt;aop:before pointcut-ref="businessService" method="monitor"/&gt;

        ...
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that pointcuts defined in this way are referred to by their XML <code>id</code> and cannot be
used as named pointcuts to form composite pointcuts. The named pointcut support in the
schema-based definition style is thus more limited than that offered by the @AspectJ
style.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-advice"><a class="anchor" href="#aop-schema-advice"></a>5.5.3. Declaring Advice</h4>
<div class="paragraph">
<p>The schema-based AOP support uses the same five kinds of advice as the @AspectJ style, and they have
exactly the same semantics.</p>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-before"><a class="anchor" href="#aop-schema-advice-before"></a>Before Advice</h5>
<div class="paragraph">
<p>Before advice runs before a matched method execution. It is declared inside an
<code>&lt;aop:aspect&gt;</code> by using the <code>&lt;aop:before&gt;</code> element, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:aspect id="beforeExample" ref="aBean"&gt;

    &lt;aop:before
        pointcut-ref="dataAccessOperation"
        method="doAccessCheck"/&gt;

    ...

&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, <code>dataAccessOperation</code> is the <code>id</code> of a pointcut defined at the top (<code>&lt;aop:config&gt;</code>)
level. To define the pointcut inline instead, replace the <code>pointcut-ref</code> attribute with
a <code>pointcut</code> attribute, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:aspect id="beforeExample" ref="aBean"&gt;

    &lt;aop:before
        pointcut="execution(* com.xyz.myapp.dao.*.*(..))"
        method="doAccessCheck"/&gt;

    ...
&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>As we noted in the discussion of the @AspectJ style, using named pointcuts can
significantly improve the readability of your code.</p>
</div>
<div class="paragraph">
<p>The <code>method</code> attribute identifies a method (<code>doAccessCheck</code>) that provides the body of
the advice. This method must be defined for the bean referenced by the aspect element
that contains the advice. Before a data access operation is performed (a method execution
join point matched by the pointcut expression), the <code>doAccessCheck</code> method on the aspect
bean is invoked.</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-after-returning"><a class="anchor" href="#aop-schema-advice-after-returning"></a>After Returning Advice</h5>
<div class="paragraph">
<p>After returning advice runs when a matched method execution completes normally. It is
declared inside an <code>&lt;aop:aspect&gt;</code> in the same way as before advice. The following example
shows how to declare it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:aspect id="afterReturningExample" ref="aBean"&gt;

    &lt;aop:after-returning
        pointcut-ref="dataAccessOperation"
        method="doAccessCheck"/&gt;

    ...
&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>As in the @AspectJ style, you can get the return value within the advice body.
To do so, use the <code>returning</code> attribute to specify the name of the parameter to which
the return value should be passed, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:aspect id="afterReturningExample" ref="aBean"&gt;

    &lt;aop:after-returning
        pointcut-ref="dataAccessOperation"
        returning="retVal"
        method="doAccessCheck"/&gt;

    ...
&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>doAccessCheck</code> method must declare a parameter named <code>retVal</code>. The type of this
parameter constrains matching in the same way as described for <code>@AfterReturning</code>. For
example, you can declare the method signature as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public void doAccessCheck(Object retVal) {...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun doAccessCheck(retVal: Any) {...</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-after-throwing"><a class="anchor" href="#aop-schema-advice-after-throwing"></a>After Throwing Advice</h5>
<div class="paragraph">
<p>After throwing advice runs when a matched method execution exits by throwing an
exception. It is declared inside an <code>&lt;aop:aspect&gt;</code> by using the <code>after-throwing</code> element,
as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:aspect id="afterThrowingExample" ref="aBean"&gt;

    &lt;aop:after-throwing
        pointcut-ref="dataAccessOperation"
        method="doRecoveryActions"/&gt;

    ...
&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>As in the @AspectJ style, you can get the thrown exception within the advice body.
To do so, use the <code>throwing</code> attribute to specify the name of the parameter to
which the exception should be passed as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:aspect id="afterThrowingExample" ref="aBean"&gt;

    &lt;aop:after-throwing
        pointcut-ref="dataAccessOperation"
        throwing="dataAccessEx"
        method="doRecoveryActions"/&gt;

    ...
&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>doRecoveryActions</code> method must declare a parameter named <code>dataAccessEx</code>.
The type of this parameter constrains matching in the same way as described for
<code>@AfterThrowing</code>. For example, the method signature may be declared as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public void doRecoveryActions(DataAccessException dataAccessEx) {...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun doRecoveryActions(dataAccessEx: DataAccessException) {...</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-after-finally"><a class="anchor" href="#aop-schema-advice-after-finally"></a>After (Finally) Advice</h5>
<div class="paragraph">
<p>After (finally) advice runs no matter how a matched method execution exits.
You can declare it by using the <code>after</code> element, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:aspect id="afterFinallyExample" ref="aBean"&gt;

    &lt;aop:after
        pointcut-ref="dataAccessOperation"
        method="doReleaseLock"/&gt;

    ...
&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-advice-around"><a class="anchor" href="#aop-schema-advice-around"></a>Around Advice</h5>
<div class="paragraph">
<p>The last kind of advice is around advice. Around advice runs "around" a matched method
execution. It has the opportunity to do work both before and after the method runs
and to determine when, how, and even if the method actually gets to run at all.
Around advice is often used to share state before and after a method execution in a
thread-safe manner (starting and stopping a timer, for example). Always use the least
powerful form of advice that meets your requirements. Do not use around advice if
before advice can do the job.</p>
</div>
<div class="paragraph">
<p>You can declare around advice by using the <code>aop:around</code> element. The first parameter of
the advice method must be of type <code>ProceedingJoinPoint</code>. Within the body of the advice,
calling <code>proceed()</code> on the <code>ProceedingJoinPoint</code> causes the underlying method to run.
The <code>proceed</code> method may also be called with an <code>Object[]</code>. The values in the array
are used as the arguments to the method execution when it proceeds.
See <a href="#aop-ataspectj-around-advice">Around Advice</a> for notes on calling <code>proceed</code> with an <code>Object[]</code>.
The following example shows how to declare around advice in XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:aspect id="aroundExample" ref="aBean"&gt;

    &lt;aop:around
        pointcut-ref="businessService"
        method="doBasicProfiling"/&gt;

    ...
&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The implementation of the <code>doBasicProfiling</code> advice can be exactly the same as in the
@AspectJ example (minus the annotation, of course), as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {
    // start stopwatch
    Object retVal = pjp.proceed();
    // stop stopwatch
    return retVal;
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun doBasicProfiling(pjp: ProceedingJoinPoint): Any {
    // start stopwatch
    val retVal = pjp.proceed()
    // stop stopwatch
    return pjp.proceed()
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-schema-params"><a class="anchor" href="#aop-schema-params"></a>Advice Parameters</h5>
<div class="paragraph">
<p>The schema-based declaration style supports fully typed advice in the same way as
described for the @AspectJ support&#8201;&#8212;&#8201;by matching pointcut parameters by name against
advice method parameters. See <a href="#aop-ataspectj-advice-params">Advice Parameters</a> for details. If you wish
to explicitly specify argument names for the advice methods (not relying on the
detection strategies previously described), you can do so by using the <code>arg-names</code>
attribute of the advice element, which is treated in the same manner as the <code>argNames</code>
attribute in an advice annotation (as described in <a href="#aop-ataspectj-advice-params-names">Determining Argument Names</a>).
The following example shows how to specify an argument name in XML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:before
    pointcut="com.xyz.lib.Pointcuts.anyPublicMethod() and @annotation(auditable)"
    method="audit"
    arg-names="auditable"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>arg-names</code> attribute accepts a comma-delimited list of parameter names.</p>
</div>
<div class="paragraph">
<p>The following slightly more involved example of the XSD-based approach shows
some around advice used in conjunction with a number of strongly typed parameters:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package x.y.service;

public interface PersonService {

    Person getPerson(String personName, int age);
}

public class DefaultPersonService implements PersonService {

    public Person getPerson(String name, int age) {
        return new Person(name, age);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package x.y.service

interface PersonService {

    fun getPerson(personName: String, age: Int): Person
}

class DefaultPersonService : PersonService {

    fun getPerson(name: String, age: Int): Person {
        return Person(name, age)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next up is the aspect. Notice the fact that the <code>profile(..)</code> method accepts a number of
strongly-typed parameters, the first of which happens to be the join point used to
proceed with the method call. The presence of this parameter is an indication that the
<code>profile(..)</code> is to be used as <code>around</code> advice, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package x.y;

import org.aspectj.lang.ProceedingJoinPoint;
import org.springframework.util.StopWatch;

public class SimpleProfiler {

    public Object profile(ProceedingJoinPoint call, String name, int age) throws Throwable {
        StopWatch clock = new StopWatch("Profiling for '" + name + "' and '" + age + "'");
        try {
            clock.start(call.toShortString());
            return call.proceed();
        } finally {
            clock.stop();
            System.out.println(clock.prettyPrint());
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">import org.aspectj.lang.ProceedingJoinPoint
import org.springframework.util.StopWatch

class SimpleProfiler {

    fun profile(call: ProceedingJoinPoint, name: String, age: Int): Any {
        val clock = StopWatch("Profiling for '$name' and '$age'")
        try {
            clock.start(call.toShortString())
            return call.proceed()
        } finally {
            clock.stop()
            println(clock.prettyPrint())
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, the following example XML configuration effects the execution of the
preceding advice for a particular join point:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;!-- this is the object that will be proxied by Spring's AOP infrastructure --&gt;
    &lt;bean id="personService" class="x.y.service.DefaultPersonService"/&gt;

    &lt;!-- this is the actual advice itself --&gt;
    &lt;bean id="profiler" class="x.y.SimpleProfiler"/&gt;

    &lt;aop:config&gt;
        &lt;aop:aspect ref="profiler"&gt;

            &lt;aop:pointcut id="theExecutionOfSomePersonServiceMethod"
                expression="execution(* x.y.service.PersonService.getPerson(String,int))
                and args(name, age)"/&gt;

            &lt;aop:around pointcut-ref="theExecutionOfSomePersonServiceMethod"
                method="profile"/&gt;

        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Consider the following driver script:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">import org.springframework.beans.factory.BeanFactory;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import x.y.service.PersonService;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        BeanFactory ctx = new ClassPathXmlApplicationContext("x/y/plain.xml");
        PersonService person = (PersonService) ctx.getBean("personService");
        person.getPerson("Pengo", 12);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun main() {
    val ctx = ClassPathXmlApplicationContext("x/y/plain.xml")
    val person = ctx.getBean("personService") as PersonService
    person.getPerson("Pengo", 12)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>With such a Boot class, we would get output similar to the following on standard output:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>StopWatch 'Profiling for 'Pengo' and '12'': running time (millis) = 0
-----------------------------------------
ms     %     Task name
-----------------------------------------
00000  ?  execution(getFoo)</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-ordering"><a class="anchor" href="#aop-ordering"></a>Advice Ordering</h5>
<div class="paragraph">
<p>When multiple pieces of advice need to run at the same join point (executing method)
the ordering rules are as described in <a href="#aop-ataspectj-advice-ordering">Advice Ordering</a>. The precedence
between aspects is determined via the <code>order</code> attribute in the <code>&lt;aop:aspect&gt;</code> element or
by either adding the <code>@Order</code> annotation to the bean that backs the aspect or by having
the bean implement the <code>Ordered</code> interface.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In contrast to the precedence rules for advice methods defined in the same <code>@Aspect</code>
class, when two pieces of advice defined in the same <code>&lt;aop:aspect&gt;</code> element both need to
run at the same join point, the precedence is determined by the order in which the advice
elements are declared within the enclosing <code>&lt;aop:aspect&gt;</code> element, from highest to lowest
precedence.</p>
</div>
<div class="paragraph">
<p>For example, given an <code>around</code> advice and a <code>before</code> advice defined in the same
<code>&lt;aop:aspect&gt;</code> element that apply to the same join point, to ensure that the <code>around</code>
advice has higher precedence than the <code>before</code> advice, the <code>&lt;aop:around&gt;</code> element must be
declared before the <code>&lt;aop:before&gt;</code> element.</p>
</div>
<div class="paragraph">
<p>As a general rule of thumb, if you find that you have multiple pieces of advice defined
in the same <code>&lt;aop:aspect&gt;</code> element that apply to the same join point, consider collapsing
such advice methods into one advice method per join point in each <code>&lt;aop:aspect&gt;</code> element
or refactor the pieces of advice into separate <code>&lt;aop:aspect&gt;</code> elements that you can order
at the aspect level.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-introductions"><a class="anchor" href="#aop-schema-introductions"></a>5.5.4. Introductions</h4>
<div class="paragraph">
<p>Introductions (known as inter-type declarations in AspectJ) let an aspect declare
that advised objects implement a given interface and provide an implementation of
that interface on behalf of those objects.</p>
</div>
<div class="paragraph">
<p>You can make an introduction by using the <code>aop:declare-parents</code> element inside an <code>aop:aspect</code>.
You can use the <code>aop:declare-parents</code> element to declare that matching types have a new parent (hence the name).
For example, given an interface named <code>UsageTracked</code> and an implementation of that interface named
<code>DefaultUsageTracked</code>, the following aspect declares that all implementors of service
interfaces also implement the <code>UsageTracked</code> interface. (In order to expose statistics
through JMX for example.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:aspect id="usageTrackerAspect" ref="usageTracking"&gt;

    &lt;aop:declare-parents
        types-matching="com.xzy.myapp.service.*+"
        implement-interface="com.xyz.myapp.service.tracking.UsageTracked"
        default-impl="com.xyz.myapp.service.tracking.DefaultUsageTracked"/&gt;

    &lt;aop:before
        pointcut="com.xyz.myapp.CommonPointcuts.businessService()
            and this(usageTracked)"
            method="recordUsage"/&gt;

&lt;/aop:aspect&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The class that backs the <code>usageTracking</code> bean would then contain the following method:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public void recordUsage(UsageTracked usageTracked) {
    usageTracked.incrementUseCount();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun recordUsage(usageTracked: UsageTracked) {
    usageTracked.incrementUseCount()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface to be implemented is determined by the <code>implement-interface</code> attribute. The
value of the <code>types-matching</code> attribute is an AspectJ type pattern. Any bean of a
matching type implements the <code>UsageTracked</code> interface. Note that, in the before
advice of the preceding example, service beans can be directly used as implementations of
the <code>UsageTracked</code> interface. To access a bean programmatically, you could write the
following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">UsageTracked usageTracked = (UsageTracked) context.getBean("myService");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val usageTracked = context.getBean("myService") as UsageTracked</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-instatiation-models"><a class="anchor" href="#aop-schema-instatiation-models"></a>5.5.5. Aspect Instantiation Models</h4>
<div class="paragraph">
<p>The only supported instantiation model for schema-defined aspects is the singleton
model. Other instantiation models may be supported in future releases.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-advisors"><a class="anchor" href="#aop-schema-advisors"></a>5.5.6. Advisors</h4>
<div class="paragraph">
<p>The concept of &#8220;advisors&#8221; comes from the AOP support defined in Spring
and does not have a direct equivalent in AspectJ. An advisor is like a small
self-contained aspect that has a single piece of advice. The advice itself is
represented by a bean and must implement one of the advice interfaces described in
<a href="#aop-api-advice-types">Advice Types in Spring</a>. Advisors can take advantage of AspectJ pointcut expressions.</p>
</div>
<div class="paragraph">
<p>Spring supports the advisor concept with the <code>&lt;aop:advisor&gt;</code> element. You most
commonly see it used in conjunction with transactional advice, which also has its own
namespace support in Spring. The following example shows an advisor:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:config&gt;

    &lt;aop:pointcut id="businessService"
        expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;

    &lt;aop:advisor
        pointcut-ref="businessService"
        advice-ref="tx-advice"/&gt;

&lt;/aop:config&gt;

&lt;tx:advice id="tx-advice"&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name="*" propagation="REQUIRED"/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>As well as the <code>pointcut-ref</code> attribute used in the preceding example, you can also use the
<code>pointcut</code> attribute to define a pointcut expression inline.</p>
</div>
<div class="paragraph">
<p>To define the precedence of an advisor so that the advice can participate in ordering,
use the <code>order</code> attribute to define the <code>Ordered</code> value of the advisor.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-schema-example"><a class="anchor" href="#aop-schema-example"></a>5.5.7. An AOP Schema Example</h4>
<div class="paragraph">
<p>This section shows how the concurrent locking failure retry example from
<a href="#aop-ataspectj-example">An AOP Example</a> looks when rewritten with the schema support.</p>
</div>
<div class="paragraph">
<p>The execution of business services can sometimes fail due to concurrency issues (for
example, a deadlock loser). If the operation is retried, it is likely to succeed
on the next try. For business services where it is appropriate to retry in such
conditions (idempotent operations that do not need to go back to the user for conflict
resolution), we want to transparently retry the operation to avoid the client seeing a
<code>PessimisticLockingFailureException</code>. This is a requirement that clearly cuts across
multiple services in the service layer and, hence, is ideal for implementing through an
aspect.</p>
</div>
<div class="paragraph">
<p>Because we want to retry the operation, we need to use around advice so that we can
call <code>proceed</code> multiple times. The following listing shows the basic aspect implementation
(which is a regular Java class that uses the schema support):</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class ConcurrentOperationExecutor implements Ordered {

    private static final int DEFAULT_MAX_RETRIES = 2;

    private int maxRetries = DEFAULT_MAX_RETRIES;
    private int order = 1;

    public void setMaxRetries(int maxRetries) {
        this.maxRetries = maxRetries;
    }

    public int getOrder() {
        return this.order;
    }

    public void setOrder(int order) {
        this.order = order;
    }

    public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable {
        int numAttempts = 0;
        PessimisticLockingFailureException lockFailureException;
        do {
            numAttempts++;
            try {
                return pjp.proceed();
            }
            catch(PessimisticLockingFailureException ex) {
                lockFailureException = ex;
            }
        } while(numAttempts &lt;= this.maxRetries);
        throw lockFailureException;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class ConcurrentOperationExecutor : Ordered {

    private val DEFAULT_MAX_RETRIES = 2

    private var maxRetries = DEFAULT_MAX_RETRIES
    private var order = 1

    fun setMaxRetries(maxRetries: Int) {
        this.maxRetries = maxRetries
    }

    override fun getOrder(): Int {
        return this.order
    }

    fun setOrder(order: Int) {
        this.order = order
    }

    fun doConcurrentOperation(pjp: ProceedingJoinPoint): Any {
        var numAttempts = 0
        var lockFailureException: PessimisticLockingFailureException
        do {
            numAttempts++
            try {
                return pjp.proceed()
            } catch (ex: PessimisticLockingFailureException) {
                lockFailureException = ex
            }

        } while (numAttempts &lt;= this.maxRetries)
        throw lockFailureException
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the aspect implements the <code>Ordered</code> interface so that we can set the precedence of
the aspect higher than the transaction advice (we want a fresh transaction each time we
retry). The <code>maxRetries</code> and <code>order</code> properties are both configured by Spring. The
main action happens in the <code>doConcurrentOperation</code> around advice method. We try to
proceed. If we fail with a <code>PessimisticLockingFailureException</code>, we try again,
unless we have exhausted all of our retry attempts.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This class is identical to the one used in the @AspectJ example, but with the
annotations removed.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The corresponding Spring configuration is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:config&gt;

    &lt;aop:aspect id="concurrentOperationRetry" ref="concurrentOperationExecutor"&gt;

        &lt;aop:pointcut id="idempotentOperation"
            expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;

        &lt;aop:around
            pointcut-ref="idempotentOperation"
            method="doConcurrentOperation"/&gt;

    &lt;/aop:aspect&gt;

&lt;/aop:config&gt;

&lt;bean id="concurrentOperationExecutor"
    class="com.xyz.myapp.service.impl.ConcurrentOperationExecutor"&gt;
        &lt;property name="maxRetries" value="3"/&gt;
        &lt;property name="order" value="100"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice that, for the time, being we assume that all business services are idempotent. If
this is not the case, we can refine the aspect so that it retries only genuinely
idempotent operations, by introducing an <code>Idempotent</code> annotation and using the annotation
to annotate the implementation of service operations, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Retention(RetentionPolicy.RUNTIME)
public @interface Idempotent {
    // marker annotation
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Retention(AnnotationRetention.RUNTIME)
annotation class Idempotent {
    // marker annotation
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The
change to the aspect to retry only idempotent operations involves refining the
pointcut expression so that only <code>@Idempotent</code> operations match, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:pointcut id="idempotentOperation"
        expression="execution(* com.xyz.myapp.service.*.*(..)) and
        @annotation(com.xyz.myapp.service.Idempotent)"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-choosing"><a class="anchor" href="#aop-choosing"></a>5.6. Choosing which AOP Declaration Style to Use</h3>
<div class="paragraph">
<p>Once you have decided that an aspect is the best approach for implementing a given
requirement, how do you decide between using Spring AOP or AspectJ and between the
Aspect language (code) style, the @AspectJ annotation style, or the Spring XML style? These
decisions are influenced by a number of factors including application requirements,
development tools, and team familiarity with AOP.</p>
</div>
<div class="sect3">
<h4 id="aop-spring-or-aspectj"><a class="anchor" href="#aop-spring-or-aspectj"></a>5.6.1. Spring AOP or Full AspectJ?</h4>
<div class="paragraph">
<p>Use the simplest thing that can work. Spring AOP is simpler than using full AspectJ, as
there is no requirement to introduce the AspectJ compiler / weaver into your development
and build processes. If you only need to advise the execution of operations on Spring
beans, Spring AOP is the right choice. If you need to advise objects not managed by
the Spring container (such as domain objects, typically), you need to use
AspectJ. You also need to use AspectJ if you wish to advise join points other than
simple method executions (for example, field get or set join points and so on).</p>
</div>
<div class="paragraph">
<p>When you use AspectJ, you have the choice of the AspectJ language syntax (also known as
the &#8220;code style&#8221;) or the @AspectJ annotation style. Clearly, if you do not use Java
5+, the choice has been made for you: Use the code style. If aspects play a large
role in your design, and you are able to use the <a href="https://www.eclipse.org/ajdt/">AspectJ
Development Tools (AJDT)</a> plugin for Eclipse, the AspectJ language syntax is the
preferred option. It is cleaner and simpler because the language was purposefully
designed for writing aspects. If you do not use Eclipse or have only a few aspects
that do not play a major role in your application, you may want to consider using
the @AspectJ style, sticking with regular Java compilation in your IDE, and adding
an aspect weaving phase to your build script.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ataspectj-or-xml"><a class="anchor" href="#aop-ataspectj-or-xml"></a>5.6.2. @AspectJ or XML for Spring AOP?</h4>
<div class="paragraph">
<p>If you have chosen to use Spring AOP, you have a choice of @AspectJ or XML style.
There are various tradeoffs to consider.</p>
</div>
<div class="paragraph">
<p>The XML style may be most familiar to existing Spring users, and it is backed by genuine
POJOs. When using AOP as a tool to configure enterprise services, XML can be a good
choice (a good test is whether you consider the pointcut expression to be a part of your
configuration that you might want to change independently). With the XML style, it is
arguably clearer from your configuration which aspects are present in the system.</p>
</div>
<div class="paragraph">
<p>The XML style has two disadvantages. First, it does not fully encapsulate the
implementation of the requirement it addresses in a single place. The DRY principle says
that there should be a single, unambiguous, authoritative representation of any piece of
knowledge within a system. When using the XML style, the knowledge of how a requirement
is implemented is split across the declaration of the backing bean class and the XML in
the configuration file. When you use the @AspectJ style, this information is encapsulated
in a single module: the aspect. Secondly, the XML style is slightly more limited in what
it can express than the @AspectJ style: Only the &#8220;singleton&#8221; aspect instantiation model
is supported, and it is not possible to combine named pointcuts declared in XML.
For example, in the @AspectJ style you can write something like the following:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Pointcut("execution(* get*())")
public void propertyAccess() {}

@Pointcut("execution(org.xyz.Account+ *(..))")
public void operationReturningAnAccount() {}

@Pointcut("propertyAccess() &amp;&amp; operationReturningAnAccount()")
public void accountPropertyAccess() {}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Pointcut("execution(* get*())")
fun propertyAccess() {}

@Pointcut("execution(org.xyz.Account+ *(..))")
fun operationReturningAnAccount() {}

@Pointcut("propertyAccess() &amp;&amp; operationReturningAnAccount()")
fun accountPropertyAccess() {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the XML style you can declare the first two pointcuts:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:pointcut id="propertyAccess"
        expression="execution(* get*())"/&gt;

&lt;aop:pointcut id="operationReturningAnAccount"
        expression="execution(org.xyz.Account+ *(..))"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The downside of the XML approach is that you cannot define the
<code>accountPropertyAccess</code> pointcut by combining these definitions.</p>
</div>
<div class="paragraph">
<p>The @AspectJ style supports additional instantiation models and richer pointcut
composition. It has the advantage of keeping the aspect as a modular unit. It also has
the advantage that the @AspectJ aspects can be understood (and thus consumed) both by
Spring AOP and by AspectJ. So, if you later decide you need the capabilities of AspectJ
to implement additional requirements, you can easily migrate to a classic AspectJ setup.
On balance, the Spring team prefers the @AspectJ style for custom aspects beyond simple
configuration of enterprise services.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-mixing-styles"><a class="anchor" href="#aop-mixing-styles"></a>5.7. Mixing Aspect Types</h3>
<div class="paragraph">
<p>It is perfectly possible to mix @AspectJ style aspects by using the auto-proxying support,
schema-defined <code>&lt;aop:aspect&gt;</code> aspects, <code>&lt;aop:advisor&gt;</code> declared advisors, and even proxies
and interceptors in other styles in the same configuration. All of these are implemented
by using the same underlying support mechanism and can co-exist without any difficulty.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-proxying"><a class="anchor" href="#aop-proxying"></a>5.8. Proxying Mechanisms</h3>
<div class="paragraph">
<p>Spring AOP uses either JDK dynamic proxies or CGLIB to create the proxy for a given
target object. JDK dynamic proxies are built into the JDK, whereas CGLIB is a common
open-source class definition library (repackaged into <code>spring-core</code>).</p>
</div>
<div class="paragraph">
<p>If the target object to be proxied implements at least one interface, a JDK dynamic
proxy is used. All of the interfaces implemented by the target type are proxied.
If the target object does not implement any interfaces, a CGLIB proxy is created.</p>
</div>
<div class="paragraph">
<p>If you want to force the use of CGLIB proxying (for example, to proxy every method
defined for the target object, not only those implemented by its interfaces),
you can do so. However, you should consider the following issues:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>With CGLIB, <code>final</code> methods cannot be advised, as they cannot be overridden in
runtime-generated subclasses.</p>
</li>
<li>
<p>As of Spring 4.0, the constructor of your proxied object is NOT called twice anymore,
since the CGLIB proxy instance is created through Objenesis. Only if your JVM does
not allow for constructor bypassing, you might see double invocations and
corresponding debug log entries from Spring&#8217;s AOP support.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To force the use of CGLIB proxies, set the value of the <code>proxy-target-class</code> attribute
of the <code>&lt;aop:config&gt;</code> element to true, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:config proxy-target-class="true"&gt;
    &lt;!-- other beans defined here... --&gt;
&lt;/aop:config&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>To force CGLIB proxying when you use the @AspectJ auto-proxy support, set the
<code>proxy-target-class</code> attribute of the <code>&lt;aop:aspectj-autoproxy&gt;</code> element to <code>true</code>,
as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Multiple <code>&lt;aop:config/&gt;</code> sections are collapsed into a single unified auto-proxy creator
at runtime, which applies the <em>strongest</em> proxy settings that any of the
<code>&lt;aop:config/&gt;</code> sections (typically from different XML bean definition files) specified.
This also applies to the <code>&lt;tx:annotation-driven/&gt;</code> and <code>&lt;aop:aspectj-autoproxy/&gt;</code>
elements.</p>
</div>
<div class="paragraph">
<p>To be clear, using <code>proxy-target-class="true"</code> on <code>&lt;tx:annotation-driven/&gt;</code>,
<code>&lt;aop:aspectj-autoproxy/&gt;</code>, or <code>&lt;aop:config/&gt;</code> elements forces the use of CGLIB
proxies <em>for all three of them</em>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="aop-understanding-aop-proxies"><a class="anchor" href="#aop-understanding-aop-proxies"></a>5.8.1. Understanding AOP Proxies</h4>
<div class="paragraph">
<p>Spring AOP is proxy-based. It is vitally important that you grasp the semantics of
what that last statement actually means before you write your own aspects or use any of
the Spring AOP-based aspects supplied with the Spring Framework.</p>
</div>
<div class="paragraph">
<p>Consider first the scenario where you have a plain-vanilla, un-proxied,
nothing-special-about-it, straight object reference, as the following
code snippet shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class SimplePojo implements Pojo {

    public void foo() {
        // this next method invocation is a direct call on the 'this' reference
        this.bar();
    }

    public void bar() {
        // some logic...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class SimplePojo : Pojo {

    fun foo() {
        // this next method invocation is a direct call on the 'this' reference
        this.bar()
    }

    fun bar() {
        // some logic...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you invoke a method on an object reference, the method is invoked directly on
that object reference, as the following image and listing show:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/aop-proxy-plain-pojo-call.png" alt="aop proxy plain pojo call">
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class Main {

    public static void main(String[] args) {
        Pojo pojo = new SimplePojo();
        // this is a direct method call on the 'pojo' reference
        pojo.foo();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun main() {
    val pojo = SimplePojo()
    // this is a direct method call on the 'pojo' reference
    pojo.foo()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Things change slightly when the reference that client code has is a proxy. Consider the
following diagram and code snippet:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/aop-proxy-call.png" alt="aop proxy call">
</div>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class Main {

    public static void main(String[] args) {
        ProxyFactory factory = new ProxyFactory(new SimplePojo());
        factory.addInterface(Pojo.class);
        factory.addAdvice(new RetryAdvice());

        Pojo pojo = (Pojo) factory.getProxy();
        // this is a method call on the proxy!
        pojo.foo();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun main() {
    val factory = ProxyFactory(SimplePojo())
    factory.addInterface(Pojo::class.java)
    factory.addAdvice(RetryAdvice())

    val pojo = factory.proxy as Pojo
    // this is a method call on the proxy!
    pojo.foo()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The key thing to understand here is that the client code inside the <code>main(..)</code> method
of the <code>Main</code> class has a reference to the proxy. This means that method calls on that
object reference are calls on the proxy. As a result, the proxy can delegate to all of
the interceptors (advice) that are relevant to that particular method call. However,
once the call has finally reached the target object (the <code>SimplePojo</code> reference in
this case), any method calls that it may make on itself, such as <code>this.bar()</code> or
<code>this.foo()</code>, are going to be invoked against the <code>this</code> reference, and not the proxy.
This has important implications. It means that self-invocation is not going to result
in the advice associated with a method invocation getting a chance to run.</p>
</div>
<div class="paragraph">
<p>Okay, so what is to be done about this? The best approach (the term "best" is used
loosely here) is to refactor your code such that the self-invocation does not happen.
This does entail some work on your part, but it is the best, least-invasive approach.
The next approach is absolutely horrendous, and we hesitate to point it out, precisely
because it is so horrendous. You can (painful as it is to us) totally tie the logic
within your class to Spring AOP, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class SimplePojo implements Pojo {

    public void foo() {
        // this works, but... gah!
        ((Pojo) AopContext.currentProxy()).bar();
    }

    public void bar() {
        // some logic...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class SimplePojo : Pojo {

    fun foo() {
        // this works, but... gah!
        (AopContext.currentProxy() as Pojo).bar()
    }

    fun bar() {
        // some logic...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This totally couples your code to Spring AOP, and it makes the class itself aware of
the fact that it is being used in an AOP context, which flies in the face of AOP. It
also requires some additional configuration when the proxy is being created, as the
following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class Main {

    public static void main(String[] args) {
        ProxyFactory factory = new ProxyFactory(new SimplePojo());
        factory.addInterface(Pojo.class);
        factory.addAdvice(new RetryAdvice());
        factory.setExposeProxy(true);

        Pojo pojo = (Pojo) factory.getProxy();
        // this is a method call on the proxy!
        pojo.foo();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun main() {
    val factory = ProxyFactory(SimplePojo())
    factory.addInterface(Pojo::class.java)
    factory.addAdvice(RetryAdvice())
    factory.isExposeProxy = true

    val pojo = factory.proxy as Pojo
    // this is a method call on the proxy!
    pojo.foo()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, it must be noted that AspectJ does not have this self-invocation issue because
it is not a proxy-based AOP framework.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-aspectj-programmatic"><a class="anchor" href="#aop-aspectj-programmatic"></a>5.9. Programmatic Creation of @AspectJ Proxies</h3>
<div class="paragraph">
<p>In addition to declaring aspects in your configuration by using either <code>&lt;aop:config&gt;</code>
or <code>&lt;aop:aspectj-autoproxy&gt;</code>, it is also possible to programmatically create proxies
that advise target objects. For the full details of Spring&#8217;s AOP API, see the
<a href="#aop-api">next chapter</a>. Here, we want to focus on the ability to automatically
create proxies by using @AspectJ aspects.</p>
</div>
<div class="paragraph">
<p>You can use the <code>org.springframework.aop.aspectj.annotation.AspectJProxyFactory</code> class
to create a proxy for a target object that is advised by one or more @AspectJ aspects.
The basic usage for this class is very simple, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">// create a factory that can generate a proxy for the given target object
AspectJProxyFactory factory = new AspectJProxyFactory(targetObject);

// add an aspect, the class must be an @AspectJ aspect
// you can call this as many times as you need with different aspects
factory.addAspect(SecurityManager.class);

// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspect
factory.addAspect(usageTracker);

// now get the proxy object...
MyInterfaceType proxy = factory.getProxy();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">// create a factory that can generate a proxy for the given target object
val factory = AspectJProxyFactory(targetObject)

// add an aspect, the class must be an @AspectJ aspect
// you can call this as many times as you need with different aspects
factory.addAspect(SecurityManager::class.java)

// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspect
factory.addAspect(usageTracker)

// now get the proxy object...
val proxy = factory.getProxy&lt;Any&gt;()</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/aop/aspectj/annotation/AspectJProxyFactory.html">javadoc</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-using-aspectj"><a class="anchor" href="#aop-using-aspectj"></a>5.10. Using AspectJ with Spring Applications</h3>
<div class="paragraph">
<p>Everything we have covered so far in this chapter is pure Spring AOP. In this section,
we look at how you can use the AspectJ compiler or weaver instead of or in
addition to Spring AOP if your needs go beyond the facilities offered by Spring AOP
alone.</p>
</div>
<div class="paragraph">
<p>Spring ships with a small AspectJ aspect library, which is available stand-alone in your
distribution as <code>spring-aspects.jar</code>. You need to add this to your classpath in order
to use the aspects in it. <a href="#aop-atconfigurable">Using AspectJ to Dependency Inject Domain Objects with Spring</a> and <a href="#aop-ajlib-other">Other Spring aspects for AspectJ</a> discuss the
content of this library and how you can use it. <a href="#aop-aj-configure">Configuring AspectJ Aspects by Using Spring IoC</a> discusses how to
dependency inject AspectJ aspects that are woven using the AspectJ compiler. Finally,
<a href="#aop-aj-ltw">Load-time Weaving with AspectJ in the Spring Framework</a> provides an introduction to load-time weaving for Spring applications
that use AspectJ.</p>
</div>
<div class="sect3">
<h4 id="aop-atconfigurable"><a class="anchor" href="#aop-atconfigurable"></a>5.10.1. Using AspectJ to Dependency Inject Domain Objects with Spring</h4>
<div class="paragraph">
<p>The Spring container instantiates and configures beans defined in your application
context. It is also possible to ask a bean factory to configure a pre-existing
object, given the name of a bean definition that contains the configuration to be applied.
<code>spring-aspects.jar</code> contains an annotation-driven aspect that exploits this
capability to allow dependency injection of any object. The support is intended to
be used for objects created outside of the control of any container. Domain objects
often fall into this category because they are often created programmatically with the
<code>new</code> operator or by an ORM tool as a result of a database query.</p>
</div>
<div class="paragraph">
<p>The <code>@Configurable</code> annotation marks a class as being eligible for Spring-driven
configuration. In the simplest case, you can use purely it as a marker annotation, as the
following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package com.xyz.myapp.domain;

import org.springframework.beans.factory.annotation.Configurable;

@Configurable
public class Account {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package com.xyz.myapp.domain

import org.springframework.beans.factory.annotation.Configurable

@Configurable
class Account {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When used as a marker interface in this way, Spring configures new instances of the
annotated type (<code>Account</code>, in this case) by using a bean definition (typically
prototype-scoped) with the same name as the fully-qualified type name
(<code>com.xyz.myapp.domain.Account</code>). Since the default name for a bean is the
fully-qualified name of its type, a convenient way to declare the prototype definition
is to omit the <code>id</code> attribute, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean class="com.xyz.myapp.domain.Account" scope="prototype"&gt;
    &lt;property name="fundsTransferService" ref="fundsTransferService"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to explicitly specify the name of the prototype bean definition to use, you
can do so directly in the annotation, as the following example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package com.xyz.myapp.domain;

import org.springframework.beans.factory.annotation.Configurable;

@Configurable("account")
public class Account {
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package com.xyz.myapp.domain

import org.springframework.beans.factory.annotation.Configurable

@Configurable("account")
class Account {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring now looks for a bean definition named <code>account</code> and uses that as the
definition to configure new <code>Account</code> instances.</p>
</div>
<div class="paragraph">
<p>You can also use autowiring to avoid having to specify a dedicated bean definition at
all. To have Spring apply autowiring, use the <code>autowire</code> property of the <code>@Configurable</code>
annotation. You can specify either <code>@Configurable(autowire=Autowire.BY_TYPE)</code> or
<code>@Configurable(autowire=Autowire.BY_NAME)</code> for autowiring by type or by name,
respectively. As an alternative, it is preferable to specify explicit, annotation-driven
dependency injection for your <code>@Configurable</code> beans through <code>@Autowired</code> or <code>@Inject</code>
at the field or method level (see <a href="#beans-annotation-config">Annotation-based Container Configuration</a> for further details).</p>
</div>
<div class="paragraph">
<p>Finally, you can enable Spring dependency checking for the object references in the newly
created and configured object by using the <code>dependencyCheck</code> attribute (for example,
<code>@Configurable(autowire=Autowire.BY_NAME,dependencyCheck=true)</code>). If this attribute is
set to <code>true</code>, Spring validates after configuration that all properties (which
are not primitives or collections) have been set.</p>
</div>
<div class="paragraph">
<p>Note that using the annotation on its own does nothing. It is the
<code>AnnotationBeanConfigurerAspect</code> in <code>spring-aspects.jar</code> that acts on the presence of
the annotation. In essence, the aspect says, &#8220;after returning from the initialization of
a new object of a type annotated with <code>@Configurable</code>, configure the newly created object
using Spring in accordance with the properties of the annotation&#8221;. In this context,
&#8220;initialization&#8221; refers to newly instantiated objects (for example, objects instantiated
with the <code>new</code> operator) as well as to <code>Serializable</code> objects that are undergoing
deserialization (for example, through
<a href="https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html">readResolve()</a>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>One of the key phrases in the above paragraph is &#8220;in essence&#8221;. For most cases, the
exact semantics of &#8220;after returning from the initialization of a new object&#8221; are
fine. In this context, &#8220;after initialization&#8221; means that the dependencies are
injected after the object has been constructed. This means that the dependencies
are not available for use in the constructor bodies of the class. If you want the
dependencies to be injected before the constructor bodies run and thus be
available for use in the body of the constructors, you need to define this on the
<code>@Configurable</code> declaration, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configurable(preConstruction = true)</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configurable(preConstruction = true)</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can find more information about the language semantics of the various pointcut
types in AspectJ
<a href="https://www.eclipse.org/aspectj/doc/next/progguide/semantics-joinPoints.html">in this
appendix</a> of the <a href="https://www.eclipse.org/aspectj/doc/next/progguide/index.html">AspectJ
Programming Guide</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For this to work, the annotated types must be woven with the AspectJ weaver. You can
either use a build-time Ant or Maven task to do this (see, for example, the
<a href="https://www.eclipse.org/aspectj/doc/released/devguide/antTasks.html">AspectJ Development
Environment Guide</a>) or load-time weaving (see <a href="#aop-aj-ltw">Load-time Weaving with AspectJ in the Spring Framework</a>). The
<code>AnnotationBeanConfigurerAspect</code> itself needs to be configured by Spring (in order to obtain
a reference to the bean factory that is to be used to configure new objects). If you
use Java-based configuration, you can add <code>@EnableSpringConfigured</code> to any
<code>@Configuration</code> class, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@EnableSpringConfigured
public class AppConfig {
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@EnableSpringConfigured
class AppConfig {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you prefer XML based configuration, the Spring
<a href="#xsd-schemas-context"><code>context</code> namespace</a>
defines a convenient <code>context:spring-configured</code> element, which you can use as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;context:spring-configured/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Instances of <code>@Configurable</code> objects created before the aspect has been configured
result in a message being issued to the debug log and no configuration of the
object taking place. An example might be a bean in the Spring configuration that creates
domain objects when it is initialized by Spring. In this case, you can use the
<code>depends-on</code> bean attribute to manually specify that the bean depends on the
configuration aspect. The following example shows how to use the <code>depends-on</code> attribute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="myService"
        class="com.xzy.myapp.service.MyService"
        depends-on="org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect"&gt;

    &lt;!-- ... --&gt;

&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Do not activate <code>@Configurable</code> processing through the bean configurer aspect unless you
really mean to rely on its semantics at runtime. In particular, make sure that you do
not use <code>@Configurable</code> on bean classes that are registered as regular Spring beans
with the container. Doing so results in double initialization, once through the
container and once through the aspect.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="aop-configurable-testing"><a class="anchor" href="#aop-configurable-testing"></a>Unit Testing <code>@Configurable</code> Objects</h5>
<div class="paragraph">
<p>One of the goals of the <code>@Configurable</code> support is to enable independent unit testing
of domain objects without the difficulties associated with hard-coded lookups.
If <code>@Configurable</code> types have not been woven by AspectJ, the annotation has no affect
during unit testing. You can set mock or stub property references in the object under
test and proceed as normal. If <code>@Configurable</code> types have been woven by AspectJ,
you can still unit test outside of the container as normal, but you see a warning
message each time that you construct a <code>@Configurable</code> object indicating that it has
not been configured by Spring.</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-configurable-container"><a class="anchor" href="#aop-configurable-container"></a>Working with Multiple Application Contexts</h5>
<div class="paragraph">
<p>The <code>AnnotationBeanConfigurerAspect</code> that is used to implement the <code>@Configurable</code> support
is an AspectJ singleton aspect. The scope of a singleton aspect is the same as the scope
of <code>static</code> members: There is one aspect instance per classloader that defines the type.
This means that, if you define multiple application contexts within the same classloader
hierarchy, you need to consider where to define the <code>@EnableSpringConfigured</code> bean and
where to place <code>spring-aspects.jar</code> on the classpath.</p>
</div>
<div class="paragraph">
<p>Consider a typical Spring web application configuration that has a shared parent application
context that defines common business services, everything needed to support those services,
and one child application context for each servlet (which contains definitions particular
to that servlet). All of these contexts co-exist within the same classloader hierarchy,
and so the <code>AnnotationBeanConfigurerAspect</code> can hold a reference to only one of them.
In this case, we recommend defining the <code>@EnableSpringConfigured</code> bean in the shared
(parent) application context. This defines the services that you are likely to want to
inject into domain objects. A consequence is that you cannot configure domain objects
with references to beans defined in the child (servlet-specific) contexts by using the
@Configurable mechanism (which is probably not something you want to do anyway).</p>
</div>
<div class="paragraph">
<p>When deploying multiple web applications within the same container, ensure that each
web application loads the types in <code>spring-aspects.jar</code> by using its own classloader
(for example, by placing <code>spring-aspects.jar</code> in <code>'WEB-INF/lib'</code>). If <code>spring-aspects.jar</code>
is added only to the container-wide classpath (and hence loaded by the shared parent
classloader), all web applications share the same aspect instance (which is probably
not what you want).</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-ajlib-other"><a class="anchor" href="#aop-ajlib-other"></a>5.10.2. Other Spring aspects for AspectJ</h4>
<div class="paragraph">
<p>In addition to the <code>@Configurable</code> aspect, <code>spring-aspects.jar</code> contains an AspectJ
aspect that you can use to drive Spring&#8217;s transaction management for types and methods
annotated with the <code>@Transactional</code> annotation. This is primarily intended for users who
want to use the Spring Framework&#8217;s transaction support outside of the Spring container.</p>
</div>
<div class="paragraph">
<p>The aspect that interprets <code>@Transactional</code> annotations is the
<code>AnnotationTransactionAspect</code>. When you use this aspect, you must annotate the
implementation class (or methods within that class or both), not the interface (if
any) that the class implements. AspectJ follows Java&#8217;s rule that annotations on
interfaces are not inherited.</p>
</div>
<div class="paragraph">
<p>A <code>@Transactional</code> annotation on a class specifies the default transaction semantics for
the execution of any public operation in the class.</p>
</div>
<div class="paragraph">
<p>A <code>@Transactional</code> annotation on a method within the class overrides the default
transaction semantics given by the class annotation (if present). Methods of any
visibility may be annotated, including private methods. Annotating non-public methods
directly is the only way to get transaction demarcation for the execution of such methods.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Since Spring Framework 4.2, <code>spring-aspects</code> provides a similar aspect that offers the
exact same features for the standard <code>javax.transaction.Transactional</code> annotation. Check
<code>JtaAnnotationTransactionAspect</code> for more details.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For AspectJ programmers who want to use the Spring configuration and transaction
management support but do not want to (or cannot) use annotations, <code>spring-aspects.jar</code>
also contains <code>abstract</code> aspects you can extend to provide your own pointcut
definitions. See the sources for the <code>AbstractBeanConfigurerAspect</code> and
<code>AbstractTransactionAspect</code> aspects for more information. As an example, the following
excerpt shows how you could write an aspect to configure all instances of objects
defined in the domain model by using prototype bean definitions that match the
fully qualified class names:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public aspect DomainObjectConfiguration extends AbstractBeanConfigurerAspect {

    public DomainObjectConfiguration() {
        setBeanWiringInfoResolver(new ClassNameBeanWiringInfoResolver());
    }

    // the creation of a new bean (any object in the domain model)
    protected pointcut beanCreation(Object beanInstance) :
        initialization(new(..)) &amp;&amp;
        CommonPointcuts.inDomainModel() &amp;&amp;
        this(beanInstance);
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-aj-configure"><a class="anchor" href="#aop-aj-configure"></a>5.10.3. Configuring AspectJ Aspects by Using Spring IoC</h4>
<div class="paragraph">
<p>When you use AspectJ aspects with Spring applications, it is natural to both want and
expect to be able to configure such aspects with Spring. The AspectJ runtime itself is
responsible for aspect creation, and the means of configuring the AspectJ-created
aspects through Spring depends on the AspectJ instantiation model (the <code>per-xxx</code> clause)
used by the aspect.</p>
</div>
<div class="paragraph">
<p>The majority of AspectJ aspects are singleton aspects. Configuration of these
aspects is easy. You can create a bean definition that references the aspect type as
normal and include the <code>factory-method="aspectOf"</code> bean attribute. This ensures that
Spring obtains the aspect instance by asking AspectJ for it rather than trying to create
an instance itself. The following example shows how to use the <code>factory-method="aspectOf"</code> attribute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="profiler" class="com.xyz.profiler.Profiler"
        factory-method="aspectOf"&gt; <i class="conum" data-value="1"></i><b>(1)</b>

    &lt;property name="profilingStrategy" ref="jamonProfilingStrategy"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Note the <code>factory-method="aspectOf"</code> attribute</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Non-singleton aspects are harder to configure. However, it is possible to do so by
creating prototype bean definitions and using the <code>@Configurable</code> support from
<code>spring-aspects.jar</code> to configure the aspect instances once they have bean created by
the AspectJ runtime.</p>
</div>
<div class="paragraph">
<p>If you have some @AspectJ aspects that you want to weave with AspectJ (for example,
using load-time weaving for domain model types) and other @AspectJ aspects that you want
to use with Spring AOP, and these aspects are all configured in Spring, you
need to tell the Spring AOP @AspectJ auto-proxying support which exact subset of the
@AspectJ aspects defined in the configuration should be used for auto-proxying. You can
do this by using one or more <code>&lt;include/&gt;</code> elements inside the <code>&lt;aop:aspectj-autoproxy/&gt;</code>
declaration. Each <code>&lt;include/&gt;</code> element specifies a name pattern, and only beans with
names matched by at least one of the patterns are used for Spring AOP auto-proxy
configuration. The following example shows how to use <code>&lt;include/&gt;</code> elements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;aop:aspectj-autoproxy&gt;
    &lt;aop:include name="thisBean"/&gt;
    &lt;aop:include name="thatBean"/&gt;
&lt;/aop:aspectj-autoproxy&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Do not be misled by the name of the <code>&lt;aop:aspectj-autoproxy/&gt;</code> element. Using it
results in the creation of Spring AOP proxies. The @AspectJ style of aspect
declaration is being used here, but the AspectJ runtime is not involved.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="aop-aj-ltw"><a class="anchor" href="#aop-aj-ltw"></a>5.10.4. Load-time Weaving with AspectJ in the Spring Framework</h4>
<div class="paragraph">
<p>Load-time weaving (LTW) refers to the process of weaving AspectJ aspects into an
application&#8217;s class files as they are being loaded into the Java virtual machine (JVM).
The focus of this section is on configuring and using LTW in the specific context of the
Spring Framework. This section is not a general introduction to LTW. For full details on
the specifics of LTW and configuring LTW with only AspectJ (with Spring not being
involved at all), see the
<a href="https://www.eclipse.org/aspectj/doc/released/devguide/ltw.html">LTW section of the AspectJ
Development Environment Guide</a>.</p>
</div>
<div class="paragraph">
<p>The value that the Spring Framework brings to AspectJ LTW is in enabling much
finer-grained control over the weaving process. 'Vanilla' AspectJ LTW is effected by using
a Java (5+) agent, which is switched on by specifying a VM argument when starting up a
JVM. It is, thus, a JVM-wide setting, which may be fine in some situations but is often a
little too coarse. Spring-enabled LTW lets you switch on LTW on a
per-<code>ClassLoader</code> basis, which is more fine-grained and which can make more
sense in a 'single-JVM-multiple-application' environment (such as is found in a typical
application server environment).</p>
</div>
<div class="paragraph">
<p>Further, <a href="#aop-aj-ltw-environments">in certain environments</a>, this support enables
load-time weaving without making any modifications to the application server&#8217;s launch
script that is needed to add <code>-javaagent:path/to/aspectjweaver.jar</code> or (as we describe
later in this section) <code>-javaagent:path/to/spring-instrument.jar</code>. Developers configure
the application context to enable load-time weaving instead of relying on administrators
who typically are in charge of the deployment configuration, such as the launch script.</p>
</div>
<div class="paragraph">
<p>Now that the sales pitch is over, let us first walk through a quick example of AspectJ
LTW that uses Spring, followed by detailed specifics about elements introduced in the
example. For a complete example, see the
<a href="https://github.com/spring-projects/spring-petclinic">Petclinic sample application</a>.</p>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-first-example"><a class="anchor" href="#aop-aj-ltw-first-example"></a>A First Example</h5>
<div class="paragraph">
<p>Assume that you are an application developer who has been tasked with diagnosing
the cause of some performance problems in a system. Rather than break out a
profiling tool, we are going to switch on a simple profiling aspect that lets us
quickly get some performance metrics. We can then apply a finer-grained profiling
tool to that specific area immediately afterwards.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The example presented here uses XML configuration. You can also configure and
use @AspectJ with <a href="#beans-java">Java configuration</a>. Specifically, you can use the
<code>@EnableLoadTimeWeaving</code> annotation as an alternative to <code>&lt;context:load-time-weaver/&gt;</code>
(see <a href="#aop-aj-ltw-spring">below</a> for details).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following example shows the profiling aspect, which is not fancy.
It is a time-based profiler that uses the @AspectJ-style of aspect declaration:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package foo;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.util.StopWatch;
import org.springframework.core.annotation.Order;

@Aspect
public class ProfilingAspect {

    @Around("methodsToBeProfiled()")
    public Object profile(ProceedingJoinPoint pjp) throws Throwable {
        StopWatch sw = new StopWatch(getClass().getSimpleName());
        try {
            sw.start(pjp.getSignature().getName());
            return pjp.proceed();
        } finally {
            sw.stop();
            System.out.println(sw.prettyPrint());
        }
    }

    @Pointcut("execution(public * foo..*.*(..))")
    public void methodsToBeProfiled(){}
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package foo

import org.aspectj.lang.ProceedingJoinPoint
import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.Around
import org.aspectj.lang.annotation.Pointcut
import org.springframework.util.StopWatch
import org.springframework.core.annotation.Order

@Aspect
class ProfilingAspect {

    @Around("methodsToBeProfiled()")
    fun profile(pjp: ProceedingJoinPoint): Any {
        val sw = StopWatch(javaClass.simpleName)
        try {
            sw.start(pjp.getSignature().getName())
            return pjp.proceed()
        } finally {
            sw.stop()
            println(sw.prettyPrint())
        }
    }

    @Pointcut("execution(public * foo..*.*(..))")
    fun methodsToBeProfiled() {
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We also need to create an <code>META-INF/aop.xml</code> file, to inform the AspectJ weaver that
we want to weave our <code>ProfilingAspect</code> into our classes. This file convention, namely
the presence of a file (or files) on the Java classpath called <code>META-INF/aop.xml</code> is
standard AspectJ. The following example shows the <code>aop.xml</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!DOCTYPE aspectj PUBLIC "-//AspectJ//DTD//EN" "https://www.eclipse.org/aspectj/dtd/aspectj.dtd"&gt;
&lt;aspectj&gt;

    &lt;weaver&gt;
        &lt;!-- only weave classes in our application-specific packages --&gt;
        &lt;include within="foo.*"/&gt;
    &lt;/weaver&gt;

    &lt;aspects&gt;
        &lt;!-- weave in just this aspect --&gt;
        &lt;aspect name="foo.ProfilingAspect"/&gt;
    &lt;/aspects&gt;

&lt;/aspectj&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can move on to the Spring-specific portion of the configuration. We need
to configure a <code>LoadTimeWeaver</code> (explained later). This load-time weaver is the
essential component responsible for weaving the aspect configuration in one or
more <code>META-INF/aop.xml</code> files into the classes in your application. The good
thing is that it does not require a lot of configuration (there are some more
options that you can specify, but these are detailed later), as can be seen in
the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;!-- a service object; we will be profiling its methods --&gt;
    &lt;bean id="entitlementCalculationService"
            class="foo.StubEntitlementCalculationService"/&gt;

    &lt;!-- this switches on the load-time weaving --&gt;
    &lt;context:load-time-weaver/&gt;
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that all the required artifacts (the aspect, the <code>META-INF/aop.xml</code>
file, and the Spring configuration) are in place, we can create the following
driver class with a <code>main(..)</code> method to demonstrate the LTW in action:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package foo;

import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Main {

    public static void main(String[] args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml", Main.class);

        EntitlementCalculationService entitlementCalculationService =
                (EntitlementCalculationService) ctx.getBean("entitlementCalculationService");

        // the profiling aspect is 'woven' around this method execution
        entitlementCalculationService.calculateEntitlement();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package foo

import org.springframework.context.support.ClassPathXmlApplicationContext

fun main() {
    val ctx = ClassPathXmlApplicationContext("beans.xml")

    val entitlementCalculationService = ctx.getBean("entitlementCalculationService") as EntitlementCalculationService

    // the profiling aspect is 'woven' around this method execution
    entitlementCalculationService.calculateEntitlement()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We have one last thing to do. The introduction to this section did say that one could
switch on LTW selectively on a per-<code>ClassLoader</code> basis with Spring, and this is true.
However, for this example, we use a Java agent (supplied with Spring) to switch on LTW.
We use the following command to run the <code>Main</code> class shown earlier:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>java -javaagent:C:/projects/foo/lib/global/spring-instrument.jar foo.Main</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>-javaagent</code> is a flag for specifying and enabling
<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/package-summary.html">agents
to instrument programs that run on the JVM</a>. The Spring Framework ships with such an
agent, the <code>InstrumentationSavingAgent</code>, which is packaged in the
<code>spring-instrument.jar</code> that was supplied as the value of the <code>-javaagent</code> argument in
the preceding example.</p>
</div>
<div class="paragraph">
<p>The output from the execution of the <code>Main</code> program looks something like the next example.
(I have introduced a <code>Thread.sleep(..)</code> statement into the <code>calculateEntitlement()</code>
implementation so that the profiler actually captures something other than 0
milliseconds (the <code>01234</code> milliseconds is not an overhead introduced by the AOP).
The following listing shows the output we got when we ran our profiler:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Calculating entitlement

StopWatch 'ProfilingAspect': running time (millis) = 1234
------ ----- ----------------------------
ms     %     Task name
------ ----- ----------------------------
01234  100%  calculateEntitlement</pre>
</div>
</div>
<div class="paragraph">
<p>Since this LTW is effected by using full-blown AspectJ, we are not limited only to advising
Spring beans. The following slight variation on the <code>Main</code> program yields the same
result:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package foo;

import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Main {

    public static void main(String[] args) {
        new ClassPathXmlApplicationContext("beans.xml", Main.class);

        EntitlementCalculationService entitlementCalculationService =
                new StubEntitlementCalculationService();

        // the profiling aspect will be 'woven' around this method execution
        entitlementCalculationService.calculateEntitlement();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package foo

import org.springframework.context.support.ClassPathXmlApplicationContext

fun main(args: Array&lt;String&gt;) {
    ClassPathXmlApplicationContext("beans.xml")

    val entitlementCalculationService = StubEntitlementCalculationService()

    // the profiling aspect will be 'woven' around this method execution
    entitlementCalculationService.calculateEntitlement()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice how, in the preceding program, we bootstrap the Spring container and
then create a new instance of the <code>StubEntitlementCalculationService</code> totally outside
the context of Spring. The profiling advice still gets woven in.</p>
</div>
<div class="paragraph">
<p>Admittedly, the example is simplistic. However, the basics of the LTW support in Spring
have all been introduced in the earlier example, and the rest of this section explains
the &#8220;why&#8221; behind each bit of configuration and usage in detail.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>ProfilingAspect</code> used in this example may be basic, but it is quite useful. It is a
nice example of a development-time aspect that developers can use during development
and then easily exclude from builds of the application being deployed
into UAT or production.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-the-aspects"><a class="anchor" href="#aop-aj-ltw-the-aspects"></a>Aspects</h5>
<div class="paragraph">
<p>The aspects that you use in LTW have to be AspectJ aspects. You can write them in
either the AspectJ language itself, or you can write your aspects in the @AspectJ-style.
Your aspects are then both valid AspectJ and Spring AOP aspects.
Furthermore, the compiled aspect classes need to be available on the classpath.</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-aop_dot_xml"><a class="anchor" href="#aop-aj-ltw-aop_dot_xml"></a>'META-INF/aop.xml'</h5>
<div class="paragraph">
<p>The AspectJ LTW infrastructure is configured by using one or more <code>META-INF/aop.xml</code>
files that are on the Java classpath (either directly or, more typically, in jar files).</p>
</div>
<div class="paragraph">
<p>The structure and contents of this file is detailed in the LTW part of the
<a href="https://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html">AspectJ reference
documentation</a>. Because the <code>aop.xml</code> file is 100% AspectJ, we do not describe it further here.</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-libraries"><a class="anchor" href="#aop-aj-ltw-libraries"></a>Required libraries (JARS)</h5>
<div class="paragraph">
<p>At minimum, you need the following libraries to use the Spring Framework&#8217;s support
for AspectJ LTW:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spring-aop.jar</code></p>
</li>
<li>
<p><code>aspectjweaver.jar</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If you use the <a href="#aop-aj-ltw-environments-generic">Spring-provided agent to enable
instrumentation</a>, you also need:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>spring-instrument.jar</code></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-spring"><a class="anchor" href="#aop-aj-ltw-spring"></a>Spring Configuration</h5>
<div class="paragraph">
<p>The key component in Spring&#8217;s LTW support is the <code>LoadTimeWeaver</code> interface (in the
<code>org.springframework.instrument.classloading</code> package), and the numerous implementations
of it that ship with the Spring distribution. A <code>LoadTimeWeaver</code> is responsible for
adding one or more <code>java.lang.instrument.ClassFileTransformers</code> to a <code>ClassLoader</code> at
runtime, which opens the door to all manner of interesting applications, one of which
happens to be the LTW of aspects.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you are unfamiliar with the idea of runtime class file transformation, see the
javadoc API documentation for the <code>java.lang.instrument</code> package before continuing.
While that documentation is not comprehensive, at least you can see the key interfaces
and classes (for reference as you read through this section).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Configuring a <code>LoadTimeWeaver</code> for a particular <code>ApplicationContext</code> can be as easy as
adding one line. (Note that you almost certainly need to use an
<code>ApplicationContext</code> as your Spring container&#8201;&#8212;&#8201;typically, a <code>BeanFactory</code> is not
enough because the LTW support uses <code>BeanFactoryPostProcessors</code>.)</p>
</div>
<div class="paragraph">
<p>To enable the Spring Framework&#8217;s LTW support, you need to configure a <code>LoadTimeWeaver</code>,
which typically is done by using the <code>@EnableLoadTimeWeaving</code> annotation, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@EnableLoadTimeWeaving
public class AppConfig {
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@EnableLoadTimeWeaving
class AppConfig {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, if you prefer XML-based configuration, use the
<code>&lt;context:load-time-weaver/&gt;</code> element. Note that the element is defined in the
<code>context</code> namespace. The following example shows how to use <code>&lt;context:load-time-weaver/&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;context:load-time-weaver/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration automatically defines and registers a number of LTW-specific
infrastructure beans, such as a <code>LoadTimeWeaver</code> and an <code>AspectJWeavingEnabler</code>, for you.
The default <code>LoadTimeWeaver</code> is the <code>DefaultContextLoadTimeWeaver</code> class, which attempts
to decorate an automatically detected <code>LoadTimeWeaver</code>. The exact type of <code>LoadTimeWeaver</code>
that is &#8220;automatically detected&#8221; is dependent upon your runtime environment.
The following table summarizes various <code>LoadTimeWeaver</code> implementations:</p>
</div>
<table id="aop-aj-ltw-spring-env-impls" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 13. DefaultContextLoadTimeWeaver LoadTimeWeavers</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Runtime Environment</th>
<th class="tableblock halign-left valign-top"><code>LoadTimeWeaver</code> implementation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Running in <a href="https://tomcat.apache.org/">Apache Tomcat</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TomcatLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Running in <a href="https://eclipse-ee4j.github.io/glassfish/">GlassFish</a> (limited to EAR deployments)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GlassFishLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Running in Red Hat&#8217;s <a href="https://www.jboss.org/jbossas/">JBoss AS</a> or <a href="https://www.wildfly.org/">WildFly</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JBossLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Running in IBM&#8217;s <a href="https://www-01.ibm.com/software/webservers/appserv/was/">WebSphere</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebSphereLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Running in Oracle&#8217;s
<a href="https://www.oracle.com/technetwork/middleware/weblogic/overview/index-085209.html">WebLogic</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebLogicLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JVM started with Spring <code>InstrumentationSavingAgent</code>
(<code>java -javaagent:path/to/spring-instrument.jar</code>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InstrumentationLoadTimeWeaver</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fallback, expecting the underlying ClassLoader to follow common conventions
(namely <code>addTransformer</code> and optionally a <code>getThrowawayClassLoader</code> method)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ReflectiveLoadTimeWeaver</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Note that the table lists only the <code>LoadTimeWeavers</code> that are autodetected when you
use the <code>DefaultContextLoadTimeWeaver</code>. You can specify exactly which <code>LoadTimeWeaver</code>
implementation to use.</p>
</div>
<div class="paragraph">
<p>To specify a specific <code>LoadTimeWeaver</code> with Java configuration, implement the
<code>LoadTimeWeavingConfigurer</code> interface and override the <code>getLoadTimeWeaver()</code> method.
The following example specifies a <code>ReflectiveLoadTimeWeaver</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">@Configuration
@EnableLoadTimeWeaving
public class AppConfig implements LoadTimeWeavingConfigurer {

    @Override
    public LoadTimeWeaver getLoadTimeWeaver() {
        return new ReflectiveLoadTimeWeaver();
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">@Configuration
@EnableLoadTimeWeaving
class AppConfig : LoadTimeWeavingConfigurer {

    override fun getLoadTimeWeaver(): LoadTimeWeaver {
        return ReflectiveLoadTimeWeaver()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you use XML-based configuration, you can specify the fully qualified classname
as the value of the <code>weaver-class</code> attribute on the <code>&lt;context:load-time-weaver/&gt;</code>
element. Again, the following example specifies a <code>ReflectiveLoadTimeWeaver</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;context:load-time-weaver
            weaver-class="org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>LoadTimeWeaver</code> that is defined and registered by the configuration can be later
retrieved from the Spring container by using the well known name, <code>loadTimeWeaver</code>.
Remember that the <code>LoadTimeWeaver</code> exists only as a mechanism for Spring&#8217;s LTW
infrastructure to add one or more <code>ClassFileTransformers</code>. The actual
<code>ClassFileTransformer</code> that does the LTW is the <code>ClassPreProcessorAgentAdapter</code> (from
the <code>org.aspectj.weaver.loadtime</code> package) class. See the class-level javadoc of the
<code>ClassPreProcessorAgentAdapter</code> class for further details, because the specifics of how
the weaving is actually effected is beyond the scope of this document.</p>
</div>
<div class="paragraph">
<p>There is one final attribute of the configuration left to discuss: the <code>aspectjWeaving</code>
attribute (or <code>aspectj-weaving</code> if you use XML). This attribute controls whether LTW
is enabled or not. It accepts one of three possible values, with the default value being
<code>autodetect</code> if the attribute is not present. The following table summarizes the three
possible values:</p>
</div>
<table id="aop-aj-ltw-ltw-tag-attrs" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 14. AspectJ weaving attribute values</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Annotation Value</th>
<th class="tableblock halign-left valign-top">XML Value</th>
<th class="tableblock halign-left valign-top">Explanation</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ENABLED</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>on</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">AspectJ weaving is on, and aspects are woven at load-time as appropriate.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DISABLED</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>off</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LTW is off. No aspect is woven at load-time.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AUTODETECT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>autodetect</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">If the Spring LTW infrastructure can find at least one <code>META-INF/aop.xml</code> file,
then AspectJ weaving is on. Otherwise, it is off. This is the default value.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect4">
<h5 id="aop-aj-ltw-environments"><a class="anchor" href="#aop-aj-ltw-environments"></a>Environment-specific Configuration</h5>
<div class="paragraph">
<p>This last section contains any additional settings and configuration that you need
when you use Spring&#8217;s LTW support in environments such as application servers and web
containers.</p>
</div>
<div class="sect5">
<h6 id="aop-aj-ltw-environments-tomcat-jboss-etc"><a class="anchor" href="#aop-aj-ltw-environments-tomcat-jboss-etc"></a>Tomcat, JBoss, WebSphere, WebLogic</h6>
<div class="paragraph">
<p>Tomcat, JBoss/WildFly, IBM WebSphere Application Server and Oracle WebLogic Server all
provide a general app <code>ClassLoader</code> that is capable of local instrumentation. Spring&#8217;s
native LTW may leverage those ClassLoader implementations to provide AspectJ weaving.
You can simply enable load-time weaving, as <a href="#aop-using-aspectj">described earlier</a>.
Specifically, you do not need to modify the JVM launch script to add
<code>-javaagent:path/to/spring-instrument.jar</code>.</p>
</div>
<div class="paragraph">
<p>Note that on JBoss, you may need to disable the app server scanning to prevent it from
loading the classes before the application actually starts. A quick workaround is to add
to your artifact a file named <code>WEB-INF/jboss-scanning.xml</code> with the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;scanning xmlns="urn:jboss:scanning:1.0"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="aop-aj-ltw-environments-generic"><a class="anchor" href="#aop-aj-ltw-environments-generic"></a>Generic Java Applications</h6>
<div class="paragraph">
<p>When class instrumentation is required in environments that are not supported by
specific <code>LoadTimeWeaver</code> implementations, a JVM agent is the general solution.
For such cases, Spring provides <code>InstrumentationLoadTimeWeaver</code> which requires a
Spring-specific (but very general) JVM agent, <code>spring-instrument.jar</code>, autodetected
by common <code>@EnableLoadTimeWeaving</code> and <code>&lt;context:load-time-weaver/&gt;</code> setups.</p>
</div>
<div class="paragraph">
<p>To use it, you must start the virtual machine with the Spring agent by supplying
the following JVM options:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>-javaagent:/path/to/spring-instrument.jar</pre>
</div>
</div>
<div class="paragraph">
<p>Note that this requires modification of the JVM launch script, which may prevent you
from using this in application server environments (depending on your server and your
operation policies). That said, for one-app-per-JVM deployments such as standalone
Spring Boot applications, you typically control the entire JVM setup in any case.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-resources"><a class="anchor" href="#aop-resources"></a>5.11. Further Resources</h3>
<div class="paragraph">
<p>More information on AspectJ can be found on the <a href="https://www.eclipse.org/aspectj">AspectJ website</a>.</p>
</div>
<div class="paragraph">
<p><em>Eclipse AspectJ</em> by Adrian Colyer et. al. (Addison-Wesley, 2005) provides a
comprehensive introduction and reference for the AspectJ language.</p>
</div>
<div class="paragraph">
<p><em>AspectJ in Action</em>, Second Edition by Ramnivas Laddad (Manning, 2009) comes highly
recommended. The focus of the book is on AspectJ, but a lot of general AOP themes are
explored (in some depth).</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="aop-api"><a class="anchor" href="#aop-api"></a>6. Spring AOP APIs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The previous chapter described the Spring&#8217;s support for AOP with @AspectJ and schema-based
aspect definitions. In this chapter, we discuss the lower-level Spring AOP APIs. For common
applications, we recommend the use of Spring AOP with AspectJ pointcuts as described in the
previous chapter.</p>
</div>
<div class="sect2">
<h3 id="aop-api-pointcuts"><a class="anchor" href="#aop-api-pointcuts"></a>6.1. Pointcut API in Spring</h3>
<div class="paragraph">
<p>This section describes how Spring handles the crucial pointcut concept.</p>
</div>
<div class="sect3">
<h4 id="aop-api-concepts"><a class="anchor" href="#aop-api-concepts"></a>6.1.1. Concepts</h4>
<div class="paragraph">
<p>Spring&#8217;s pointcut model enables pointcut reuse independent of advice types. You can
target different advice with the same pointcut.</p>
</div>
<div class="paragraph">
<p>The <code>org.springframework.aop.Pointcut</code> interface is the central interface, used to
target advices to particular classes and methods. The complete interface follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface Pointcut {

    ClassFilter getClassFilter();

    MethodMatcher getMethodMatcher();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Splitting the <code>Pointcut</code> interface into two parts allows reuse of class and method
matching parts and fine-grained composition operations (such as performing a &#8220;union&#8221;
with another method matcher).</p>
</div>
<div class="paragraph">
<p>The <code>ClassFilter</code> interface is used to restrict the pointcut to a given set of target
classes. If the <code>matches()</code> method always returns true, all target classes are
matched. The following listing shows the <code>ClassFilter</code> interface definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface ClassFilter {

    boolean matches(Class clazz);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>MethodMatcher</code> interface is normally more important. The complete interface follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface MethodMatcher {

    boolean matches(Method m, Class&lt;?&gt; targetClass);

    boolean isRuntime();

    boolean matches(Method m, Class&lt;?&gt; targetClass, Object... args);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>matches(Method, Class)</code> method is used to test whether this pointcut ever
matches a given method on a target class. This evaluation can be performed when an AOP
proxy is created to avoid the need for a test on every method invocation. If the
two-argument <code>matches</code> method returns <code>true</code> for a given method, and the <code>isRuntime()</code>
method for the MethodMatcher returns <code>true</code>, the three-argument matches method is
invoked on every method invocation. This lets a pointcut look at the arguments passed
to the method invocation immediately before the target advice starts.</p>
</div>
<div class="paragraph">
<p>Most <code>MethodMatcher</code> implementations are static, meaning that their <code>isRuntime()</code> method
returns <code>false</code>. In this case, the three-argument <code>matches</code> method is never invoked.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If possible, try to make pointcuts static, allowing the AOP framework to cache the
results of pointcut evaluation when an AOP proxy is created.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcut-ops"><a class="anchor" href="#aop-api-pointcut-ops"></a>6.1.2. Operations on Pointcuts</h4>
<div class="paragraph">
<p>Spring supports operations (notably, union and intersection) on pointcuts.</p>
</div>
<div class="paragraph">
<p>Union means the methods that either pointcut matches.
Intersection means the methods that both pointcuts match.
Union is usually more useful.
You can compose pointcuts by using the static methods in the
<code>org.springframework.aop.support.Pointcuts</code> class or by using the
<code>ComposablePointcut</code> class in the same package. However, using AspectJ pointcut
expressions is usually a simpler approach.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcuts-aspectj"><a class="anchor" href="#aop-api-pointcuts-aspectj"></a>6.1.3. AspectJ Expression Pointcuts</h4>
<div class="paragraph">
<p>Since 2.0, the most important type of pointcut used by Spring is
<code>org.springframework.aop.aspectj.AspectJExpressionPointcut</code>. This is a pointcut that
uses an AspectJ-supplied library to parse an AspectJ pointcut expression string.</p>
</div>
<div class="paragraph">
<p>See the <a href="#aop">previous chapter</a> for a discussion of supported AspectJ pointcut primitives.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcuts-impls"><a class="anchor" href="#aop-api-pointcuts-impls"></a>6.1.4. Convenience Pointcut Implementations</h4>
<div class="paragraph">
<p>Spring provides several convenient pointcut implementations. You can use some of them
directly; others are intended to be subclassed in application-specific pointcuts.</p>
</div>
<div class="sect4">
<h5 id="aop-api-pointcuts-static"><a class="anchor" href="#aop-api-pointcuts-static"></a>Static Pointcuts</h5>
<div class="paragraph">
<p>Static pointcuts are based on the method and the target class and cannot take into account
the method&#8217;s arguments. Static pointcuts suffice&#8201;&#8212;&#8201;and are best&#8201;&#8212;&#8201;for most usages.
Spring can evaluate a static pointcut only once, when a method is first invoked.
After that, there is no need to evaluate the pointcut again with each method invocation.</p>
</div>
<div class="paragraph">
<p>The rest of this section describes some of the static pointcut implementations that are
included with Spring.</p>
</div>
<div class="sect5">
<h6 id="aop-api-pointcuts-regex"><a class="anchor" href="#aop-api-pointcuts-regex"></a>Regular Expression Pointcuts</h6>
<div class="paragraph">
<p>One obvious way to specify static pointcuts is regular expressions. Several AOP
frameworks besides Spring make this possible.
<code>org.springframework.aop.support.JdkRegexpMethodPointcut</code> is a generic regular
expression pointcut that uses the regular expression support in the JDK.</p>
</div>
<div class="paragraph">
<p>With the <code>JdkRegexpMethodPointcut</code> class, you can provide a list of pattern strings.
If any of these is a match, the pointcut evaluates to <code>true</code>. (As a consequence,
the resulting pointcut is effectively the union of the specified patterns.)</p>
</div>
<div class="paragraph">
<p>The following example shows how to use <code>JdkRegexpMethodPointcut</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="settersAndAbsquatulatePointcut"
        class="org.springframework.aop.support.JdkRegexpMethodPointcut"&gt;
    &lt;property name="patterns"&gt;
        &lt;list&gt;
            &lt;value&gt;.*set.*&lt;/value&gt;
            &lt;value&gt;.*absquatulate&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring provides a convenience class named <code>RegexpMethodPointcutAdvisor</code>, which lets us
also reference an <code>Advice</code> (remember that an <code>Advice</code> can be an interceptor, before advice,
throws advice, and others). Behind the scenes, Spring uses a <code>JdkRegexpMethodPointcut</code>.
Using <code>RegexpMethodPointcutAdvisor</code> simplifies wiring, as the one bean encapsulates both
pointcut and advice, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="settersAndAbsquatulateAdvisor"
        class="org.springframework.aop.support.RegexpMethodPointcutAdvisor"&gt;
    &lt;property name="advice"&gt;
        &lt;ref bean="beanNameOfAopAllianceInterceptor"/&gt;
    &lt;/property&gt;
    &lt;property name="patterns"&gt;
        &lt;list&gt;
            &lt;value&gt;.*set.*&lt;/value&gt;
            &lt;value&gt;.*absquatulate&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use <code>RegexpMethodPointcutAdvisor</code> with any <code>Advice</code> type.</p>
</div>
</div>
<div class="sect5">
<h6 id="aop-api-pointcuts-attribute-driven"><a class="anchor" href="#aop-api-pointcuts-attribute-driven"></a>Attribute-driven Pointcuts</h6>
<div class="paragraph">
<p>An important type of static pointcut is a metadata-driven pointcut. This uses the
values of metadata attributes (typically, source-level metadata).</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-pointcuts-dynamic"><a class="anchor" href="#aop-api-pointcuts-dynamic"></a>Dynamic pointcuts</h5>
<div class="paragraph">
<p>Dynamic pointcuts are costlier to evaluate than static pointcuts. They take into account
method arguments as well as static information. This means that they must be
evaluated with every method invocation and that the result cannot be cached, as arguments will
vary.</p>
</div>
<div class="paragraph">
<p>The main example is the <code>control flow</code> pointcut.</p>
</div>
<div class="sect5">
<h6 id="aop-api-pointcuts-cflow"><a class="anchor" href="#aop-api-pointcuts-cflow"></a>Control Flow Pointcuts</h6>
<div class="paragraph">
<p>Spring control flow pointcuts are conceptually similar to AspectJ <code>cflow</code> pointcuts,
although less powerful. (There is currently no way to specify that a pointcut runs
below a join point matched by another pointcut.) A control flow pointcut matches the
current call stack. For example, it might fire if the join point was invoked by a method
in the <code>com.mycompany.web</code> package or by the <code>SomeCaller</code> class. Control flow pointcuts
are specified by using the <code>org.springframework.aop.support.ControlFlowPointcut</code> class.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Control flow pointcuts are significantly more expensive to evaluate at runtime than even
other dynamic pointcuts. In Java 1.4, the cost is about five times that of other dynamic
pointcuts.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcuts-superclasses"><a class="anchor" href="#aop-api-pointcuts-superclasses"></a>6.1.5. Pointcut Superclasses</h4>
<div class="paragraph">
<p>Spring provides useful pointcut superclasses to help you to implement your own pointcuts.</p>
</div>
<div class="paragraph">
<p>Because static pointcuts are most useful, you should probably subclass
<code>StaticMethodMatcherPointcut</code>. This requires implementing only one
abstract method (although you can override other methods to customize behavior). The
following example shows how to subclass <code>StaticMethodMatcherPointcut</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">class TestStaticPointcut extends StaticMethodMatcherPointcut {

    public boolean matches(Method m, Class targetClass) {
        // return true if custom criteria match
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class TestStaticPointcut : StaticMethodMatcherPointcut() {

    override fun matches(method: Method, targetClass: Class&lt;*&gt;): Boolean {
        // return true if custom criteria match
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are also superclasses for dynamic pointcuts.
You can use custom pointcuts with any advice type.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-pointcuts-custom"><a class="anchor" href="#aop-api-pointcuts-custom"></a>6.1.6. Custom Pointcuts</h4>
<div class="paragraph">
<p>Because pointcuts in Spring AOP are Java classes rather than language features (as in
AspectJ), you can declare custom pointcuts, whether static or dynamic. Custom
pointcuts in Spring can be arbitrarily complex. However, we recommend using the AspectJ pointcut
expression language, if you can.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Later versions of Spring may offer support for &#8220;semantic pointcuts&#8221; as offered by JAC&#8201;&#8212;&#8201;for example, &#8220;all methods that change instance variables in the target object.&#8221;
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-advice"><a class="anchor" href="#aop-api-advice"></a>6.2. Advice API in Spring</h3>
<div class="paragraph">
<p>Now we can examine how Spring AOP handles advice.</p>
</div>
<div class="sect3">
<h4 id="aop-api-advice-lifecycle"><a class="anchor" href="#aop-api-advice-lifecycle"></a>6.2.1. Advice Lifecycles</h4>
<div class="paragraph">
<p>Each advice is a Spring bean. An advice instance can be shared across all advised
objects or be unique to each advised object. This corresponds to per-class or
per-instance advice.</p>
</div>
<div class="paragraph">
<p>Per-class advice is used most often. It is appropriate for generic advice, such as
transaction advisors. These do not depend on the state of the proxied object or add new
state. They merely act on the method and arguments.</p>
</div>
<div class="paragraph">
<p>Per-instance advice is appropriate for introductions, to support mixins. In this case,
the advice adds state to the proxied object.</p>
</div>
<div class="paragraph">
<p>You can use a mix of shared and per-instance advice in the same AOP proxy.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-advice-types"><a class="anchor" href="#aop-api-advice-types"></a>6.2.2. Advice Types in Spring</h4>
<div class="paragraph">
<p>Spring provides several advice types and is extensible to support
arbitrary advice types. This section describes the basic concepts and standard advice types.</p>
</div>
<div class="sect4">
<h5 id="aop-api-advice-around"><a class="anchor" href="#aop-api-advice-around"></a>Interception Around Advice</h5>
<div class="paragraph">
<p>The most fundamental advice type in Spring is interception around advice.</p>
</div>
<div class="paragraph">
<p>Spring is compliant with the AOP <code>Alliance</code> interface for around advice that uses method
interception. Classes that implement <code>MethodInterceptor</code> and that implement around advice should also implement the
following interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface MethodInterceptor extends Interceptor {

    Object invoke(MethodInvocation invocation) throws Throwable;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>MethodInvocation</code> argument to the <code>invoke()</code> method exposes the method being
invoked, the target join point, the AOP proxy, and the arguments to the method. The
<code>invoke()</code> method should return the invocation&#8217;s result: the return value of the join
point.</p>
</div>
<div class="paragraph">
<p>The following example shows a simple <code>MethodInterceptor</code> implementation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class DebugInterceptor implements MethodInterceptor {

    public Object invoke(MethodInvocation invocation) throws Throwable {
        System.out.println("Before: invocation=[" + invocation + "]");
        Object rval = invocation.proceed();
        System.out.println("Invocation returned");
        return rval;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class DebugInterceptor : MethodInterceptor {

    override fun invoke(invocation: MethodInvocation): Any {
        println("Before: invocation=[$invocation]")
        val rval = invocation.proceed()
        println("Invocation returned")
        return rval
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note the call to the <code>proceed()</code> method of <code>MethodInvocation</code>. This proceeds down the
interceptor chain towards the join point. Most interceptors invoke this method and
return its return value. However, a <code>MethodInterceptor</code>, like any around advice, can
return a different value or throw an exception rather than invoke the proceed method.
However, you do not want to do this without good reason.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>MethodInterceptor</code> implementations offer interoperability with other AOP Alliance-compliant AOP
implementations. The other advice types discussed in the remainder of this section
implement common AOP concepts but in a Spring-specific way. While there is an advantage
in using the most specific advice type, stick with <code>MethodInterceptor</code> around advice if
you are likely to want to run the aspect in another AOP framework. Note that pointcuts
are not currently interoperable between frameworks, and the AOP Alliance does not
currently define pointcut interfaces.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-advice-before"><a class="anchor" href="#aop-api-advice-before"></a>Before Advice</h5>
<div class="paragraph">
<p>A simpler advice type is a before advice. This does not need a <code>MethodInvocation</code>
object, since it is called only before entering the method.</p>
</div>
<div class="paragraph">
<p>The main advantage of a before advice is that there is no need to invoke the <code>proceed()</code>
method and, therefore, no possibility of inadvertently failing to proceed down the
interceptor chain.</p>
</div>
<div class="paragraph">
<p>The following listing shows the <code>MethodBeforeAdvice</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface MethodBeforeAdvice extends BeforeAdvice {

    void before(Method m, Object[] args, Object target) throws Throwable;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>(Spring&#8217;s API design would allow for
field before advice, although the usual objects apply to field interception and it is
unlikely for Spring to ever implement it.)</p>
</div>
<div class="paragraph">
<p>Note that the return type is <code>void</code>. Before advice can insert custom behavior before the join
point runs but cannot change the return value. If a before advice throws an
exception, it stops further execution of the interceptor chain. The exception
propagates back up the interceptor chain. If it is unchecked or on the signature of
the invoked method, it is passed directly to the client. Otherwise, it is
wrapped in an unchecked exception by the AOP proxy.</p>
</div>
<div class="paragraph">
<p>The following example shows a before advice in Spring, which counts all method invocations:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class CountingBeforeAdvice implements MethodBeforeAdvice {

    private int count;

    public void before(Method m, Object[] args, Object target) throws Throwable {
        ++count;
    }

    public int getCount() {
        return count;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class CountingBeforeAdvice : MethodBeforeAdvice {

    var count: Int = 0

    override fun before(m: Method, args: Array&lt;Any&gt;, target: Any?) {
        ++count
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Before advice can be used with any pointcut.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-advice-throws"><a class="anchor" href="#aop-api-advice-throws"></a>Throws Advice</h5>
<div class="paragraph">
<p>Throws advice is invoked after the return of the join point if the join point threw
an exception. Spring offers typed throws advice. Note that this means that the
<code>org.springframework.aop.ThrowsAdvice</code> interface does not contain any methods. It is a
tag interface identifying that the given object implements one or more typed throws
advice methods. These should be in the following form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">afterThrowing([Method, args, target], subclassOfThrowable)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Only the last argument is required. The method signatures may have either one or four
arguments, depending on whether the advice method is interested in the method and
arguments. The next two listing show classes that are examples of throws advice.</p>
</div>
<div class="paragraph">
<p>The following advice is invoked if a <code>RemoteException</code> is thrown (including from subclasses):</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class RemoteThrowsAdvice implements ThrowsAdvice {

    public void afterThrowing(RemoteException ex) throws Throwable {
        // Do something with remote exception
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class RemoteThrowsAdvice : ThrowsAdvice {

    fun afterThrowing(ex: RemoteException) {
        // Do something with remote exception
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unlike the preceding
advice, the next example declares four arguments, so that it has access to the invoked method, method
arguments, and target object. The following advice is invoked if a <code>ServletException</code> is thrown:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class ServletThrowsAdviceWithArguments implements ThrowsAdvice {

    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {
        // Do something with all arguments
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class ServletThrowsAdviceWithArguments : ThrowsAdvice {

    fun afterThrowing(m: Method, args: Array&lt;Any&gt;, target: Any, ex: ServletException) {
        // Do something with all arguments
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The final example illustrates how these two methods could be used in a single class
that handles both <code>RemoteException</code> and <code>ServletException</code>. Any number of throws advice
methods can be combined in a single class. The following listing shows the final example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public static class CombinedThrowsAdvice implements ThrowsAdvice {

    public void afterThrowing(RemoteException ex) throws Throwable {
        // Do something with remote exception
    }

    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {
        // Do something with all arguments
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class CombinedThrowsAdvice : ThrowsAdvice {

    fun afterThrowing(ex: RemoteException) {
        // Do something with remote exception
    }

    fun afterThrowing(m: Method, args: Array&lt;Any&gt;, target: Any, ex: ServletException) {
        // Do something with all arguments
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If a throws-advice method throws an exception itself, it overrides the
original exception (that is, it changes the exception thrown to the user). The overriding
exception is typically a RuntimeException, which is compatible with any method
signature. However, if a throws-advice method throws a checked exception, it must
match the declared exceptions of the target method and is, hence, to some degree
coupled to specific target method signatures. <em>Do not throw an undeclared checked
exception that is incompatible with the target method&#8217;s signature!</em>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Throws advice can be used with any pointcut.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-advice-after-returning"><a class="anchor" href="#aop-api-advice-after-returning"></a>After Returning Advice</h5>
<div class="paragraph">
<p>An after returning advice in Spring must implement the
<code>org.springframework.aop.AfterReturningAdvice</code> interface, which the following listing shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface AfterReturningAdvice extends Advice {

    void afterReturning(Object returnValue, Method m, Object[] args, Object target)
            throws Throwable;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An after returning advice has access to the return value (which it cannot modify),
the invoked method, the method&#8217;s arguments, and the target.</p>
</div>
<div class="paragraph">
<p>The following after returning advice counts all successful method invocations that have
not thrown exceptions:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class CountingAfterReturningAdvice implements AfterReturningAdvice {

    private int count;

    public void afterReturning(Object returnValue, Method m, Object[] args, Object target)
            throws Throwable {
        ++count;
    }

    public int getCount() {
        return count;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class CountingAfterReturningAdvice : AfterReturningAdvice {

    var count: Int = 0
        private set

    override fun afterReturning(returnValue: Any?, m: Method, args: Array&lt;Any&gt;, target: Any?) {
        ++count
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This advice does not change the execution path. If it throws an exception, it is
thrown up the interceptor chain instead of the return value.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
After returning advice can be used with any pointcut.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-advice-introduction"><a class="anchor" href="#aop-api-advice-introduction"></a>Introduction Advice</h5>
<div class="paragraph">
<p>Spring treats introduction advice as a special kind of interception advice.</p>
</div>
<div class="paragraph">
<p>Introduction requires an <code>IntroductionAdvisor</code> and an <code>IntroductionInterceptor</code> that
implement the following interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface IntroductionInterceptor extends MethodInterceptor {

    boolean implementsInterface(Class intf);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>invoke()</code> method inherited from the AOP Alliance <code>MethodInterceptor</code> interface must
implement the introduction. That is, if the invoked method is on an introduced
interface, the introduction interceptor is responsible for handling the method call&#8201;&#8212;&#8201;it
cannot invoke <code>proceed()</code>.</p>
</div>
<div class="paragraph">
<p>Introduction advice cannot be used with any pointcut, as it applies only at the class,
rather than the method, level. You can only use introduction advice with the
<code>IntroductionAdvisor</code>, which has the following methods:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface IntroductionAdvisor extends Advisor, IntroductionInfo {

    ClassFilter getClassFilter();

    void validateInterfaces() throws IllegalArgumentException;
}

public interface IntroductionInfo {

    Class&lt;?&gt;[] getInterfaces();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is no <code>MethodMatcher</code> and, hence, no <code>Pointcut</code> associated with introduction
advice. Only class filtering is logical.</p>
</div>
<div class="paragraph">
<p>The <code>getInterfaces()</code> method returns the interfaces introduced by this advisor.</p>
</div>
<div class="paragraph">
<p>The <code>validateInterfaces()</code> method is used internally to see whether or not the
introduced interfaces can be implemented by the configured <code>IntroductionInterceptor</code>.</p>
</div>
<div class="paragraph">
<p>Consider an example from the Spring test suite and suppose we want to
introduce the following interface to one or more objects:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public interface Lockable {
    void lock();
    void unlock();
    boolean locked();
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">interface Lockable {
    fun lock()
    fun unlock()
    fun locked(): Boolean
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This illustrates a mixin. We want to be able to cast advised objects to <code>Lockable</code>,
whatever their type and call lock and unlock methods. If we call the <code>lock()</code> method, we
want all setter methods to throw a <code>LockedException</code>. Thus, we can add an aspect that
provides the ability to make objects immutable without them having any knowledge of it:
a good example of AOP.</p>
</div>
<div class="paragraph">
<p>First, we need an <code>IntroductionInterceptor</code> that does the heavy lifting. In this
case, we extend the <code>org.springframework.aop.support.DelegatingIntroductionInterceptor</code>
convenience class. We could implement <code>IntroductionInterceptor</code> directly, but using
<code>DelegatingIntroductionInterceptor</code> is best for most cases.</p>
</div>
<div class="paragraph">
<p>The <code>DelegatingIntroductionInterceptor</code> is designed to delegate an introduction to an
actual implementation of the introduced interfaces, concealing the use of interception
to do so. You can set the delegate to any object using a constructor argument. The
default delegate (when the no-argument constructor is used) is <code>this</code>. Thus, in the next example,
the delegate is the <code>LockMixin</code> subclass of <code>DelegatingIntroductionInterceptor</code>.
Given a delegate (by default, itself), a <code>DelegatingIntroductionInterceptor</code> instance
looks for all interfaces implemented by the delegate (other than
<code>IntroductionInterceptor</code>) and supports introductions against any of them.
Subclasses such as <code>LockMixin</code> can call the <code>suppressInterface(Class intf)</code>
method to suppress interfaces that should not be exposed. However, no matter how many
interfaces an <code>IntroductionInterceptor</code> is prepared to support, the
<code>IntroductionAdvisor</code> used controls which interfaces are actually exposed. An
introduced interface conceals any implementation of the same interface by the target.</p>
</div>
<div class="paragraph">
<p>Thus, <code>LockMixin</code> extends <code>DelegatingIntroductionInterceptor</code> and implements <code>Lockable</code>
itself. The superclass automatically picks up that <code>Lockable</code> can be supported for
introduction, so we do not need to specify that. We could introduce any number of
interfaces in this way.</p>
</div>
<div class="paragraph">
<p>Note the use of the <code>locked</code> instance variable. This effectively adds additional state
to that held in the target object.</p>
</div>
<div class="paragraph">
<p>The following example shows the example <code>LockMixin</code> class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class LockMixin extends DelegatingIntroductionInterceptor implements Lockable {

    private boolean locked;

    public void lock() {
        this.locked = true;
    }

    public void unlock() {
        this.locked = false;
    }

    public boolean locked() {
        return this.locked;
    }

    public Object invoke(MethodInvocation invocation) throws Throwable {
        if (locked() &amp;&amp; invocation.getMethod().getName().indexOf("set") == 0) {
            throw new LockedException();
        }
        return super.invoke(invocation);
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class LockMixin : DelegatingIntroductionInterceptor(), Lockable {

    private var locked: Boolean = false

    fun lock() {
        this.locked = true
    }

    fun unlock() {
        this.locked = false
    }

    fun locked(): Boolean {
        return this.locked
    }

    override fun invoke(invocation: MethodInvocation): Any? {
        if (locked() &amp;&amp; invocation.method.name.indexOf("set") == 0) {
            throw LockedException()
        }
        return super.invoke(invocation)
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Often, you need not override the <code>invoke()</code> method. The
<code>DelegatingIntroductionInterceptor</code> implementation (which calls the <code>delegate</code> method if
the method is introduced, otherwise proceeds towards the join point) usually
suffices. In the present case, we need to add a check: no setter method can be invoked
if in locked mode.</p>
</div>
<div class="paragraph">
<p>The required introduction only needs to hold a distinct
<code>LockMixin</code> instance and specify the introduced interfaces (in this case, only
<code>Lockable</code>). A more complex example might take a reference to the introduction
interceptor (which would be defined as a prototype). In this case, there is no
configuration relevant for a <code>LockMixin</code>, so we create it by using <code>new</code>.
The following example shows our <code>LockMixinAdvisor</code> class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class LockMixinAdvisor extends DefaultIntroductionAdvisor {

    public LockMixinAdvisor() {
        super(new LockMixin(), Lockable.class);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class LockMixinAdvisor : DefaultIntroductionAdvisor(LockMixin(), Lockable::class.java)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can apply this advisor very simply, because it requires no configuration. (However, it
is impossible to use an <code>IntroductionInterceptor</code> without an
<code>IntroductionAdvisor</code>.) As usual with introductions, the advisor must be per-instance,
as it is stateful. We need a different instance of <code>LockMixinAdvisor</code>, and hence
<code>LockMixin</code>, for each advised object. The advisor comprises part of the advised object&#8217;s
state.</p>
</div>
<div class="paragraph">
<p>We can apply this advisor programmatically by using the <code>Advised.addAdvisor()</code> method or
(the recommended way) in XML configuration, as any other advisor. All proxy creation
choices discussed below, including &#8220;auto proxy creators,&#8221; correctly handle introductions
and stateful mixins.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-advisor"><a class="anchor" href="#aop-api-advisor"></a>6.3. The Advisor API in Spring</h3>
<div class="paragraph">
<p>In Spring, an Advisor is an aspect that contains only a single advice object associated
with a pointcut expression.</p>
</div>
<div class="paragraph">
<p>Apart from the special case of introductions, any advisor can be used with any advice.
<code>org.springframework.aop.support.DefaultPointcutAdvisor</code> is the most commonly used
advisor class. It can be used with a <code>MethodInterceptor</code>, <code>BeforeAdvice</code>, or
<code>ThrowsAdvice</code>.</p>
</div>
<div class="paragraph">
<p>It is possible to mix advisor and advice types in Spring in the same AOP proxy. For
example, you could use an interception around advice, throws advice, and before advice in
one proxy configuration. Spring automatically creates the necessary interceptor
chain.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-pfb"><a class="anchor" href="#aop-pfb"></a>6.4. Using the <code>ProxyFactoryBean</code> to Create AOP Proxies</h3>
<div class="paragraph">
<p>If you use the Spring IoC container (an <code>ApplicationContext</code> or <code>BeanFactory</code>) for your
business objects (and you should be!), you want to use one of Spring&#8217;s AOP
<code>FactoryBean</code> implementations. (Remember that a factory bean introduces a layer of indirection, letting
it create objects of a different type.)</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The Spring AOP support also uses factory beans under the covers.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The basic way to create an AOP proxy in Spring is to use the
<code>org.springframework.aop.framework.ProxyFactoryBean</code>. This gives complete control over
the pointcuts, any advice that applies, and their ordering. However, there are simpler
options that are preferable if you do not need such control.</p>
</div>
<div class="sect3">
<h4 id="aop-pfb-1"><a class="anchor" href="#aop-pfb-1"></a>6.4.1. Basics</h4>
<div class="paragraph">
<p>The <code>ProxyFactoryBean</code>, like other Spring <code>FactoryBean</code> implementations, introduces a
level of indirection. If you define a <code>ProxyFactoryBean</code> named <code>foo</code>, objects that
reference <code>foo</code> do not see the <code>ProxyFactoryBean</code> instance itself but an object
created by the implementation of the <code>getObject()</code> method in the <code>ProxyFactoryBean</code> . This
method creates an AOP proxy that wraps a target object.</p>
</div>
<div class="paragraph">
<p>One of the most important benefits of using a <code>ProxyFactoryBean</code> or another IoC-aware
class to create AOP proxies is that advices and pointcuts can also be
managed by IoC. This is a powerful feature, enabling certain approaches that are hard to
achieve with other AOP frameworks. For example, an advice may itself reference
application objects (besides the target, which should be available in any AOP
framework), benefiting from all the pluggability provided by Dependency Injection.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-pfb-2"><a class="anchor" href="#aop-pfb-2"></a>6.4.2. JavaBean Properties</h4>
<div class="paragraph">
<p>In common with most <code>FactoryBean</code> implementations provided with Spring, the
<code>ProxyFactoryBean</code> class is itself a JavaBean. Its properties are used to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Specify the target you want to proxy.</p>
</li>
<li>
<p>Specify whether to use CGLIB (described later and see also <a href="#aop-pfb-proxy-types">JDK- and CGLIB-based proxies</a>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Some key properties are inherited from <code>org.springframework.aop.framework.ProxyConfig</code>
(the superclass for all AOP proxy factories in Spring). These key properties include
the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>proxyTargetClass</code>: <code>true</code> if the target class is to be proxied, rather than the
target class&#8217;s interfaces. If this property value is set to <code>true</code>, then CGLIB proxies
are created (but see also <a href="#aop-pfb-proxy-types">JDK- and CGLIB-based proxies</a>).</p>
</li>
<li>
<p><code>optimize</code>: Controls whether or not aggressive optimizations are applied to proxies
created through CGLIB. You should not blithely use this setting unless you fully
understand how the relevant AOP proxy handles optimization. This is currently used
only for CGLIB proxies. It has no effect with JDK dynamic proxies.</p>
</li>
<li>
<p><code>frozen</code>: If a proxy configuration is <code>frozen</code>, changes to the configuration are
no longer allowed. This is useful both as a slight optimization and for those cases
when you do not want callers to be able to manipulate the proxy (through the <code>Advised</code>
interface) after the proxy has been created. The default value of this property is
<code>false</code>, so changes (such as adding additional advice) are allowed.</p>
</li>
<li>
<p><code>exposeProxy</code>: Determines whether or not the current proxy should be exposed in a
<code>ThreadLocal</code> so that it can be accessed by the target. If a target needs to obtain
the proxy and the <code>exposeProxy</code> property is set to <code>true</code>, the target can use the
<code>AopContext.currentProxy()</code> method.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Other properties specific to <code>ProxyFactoryBean</code> include the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>proxyInterfaces</code>: An array of <code>String</code> interface names. If this is not supplied, a CGLIB
proxy for the target class is used (but see also <a href="#aop-pfb-proxy-types">JDK- and CGLIB-based proxies</a>).</p>
</li>
<li>
<p><code>interceptorNames</code>: A <code>String</code> array of <code>Advisor</code>, interceptor, or other advice names to
apply. Ordering is significant, on a first come-first served basis. That is to say
that the first interceptor in the list is the first to be able to intercept the
invocation.</p>
<div class="paragraph">
<p>The names are bean names in the current factory, including bean names from ancestor
factories. You cannot mention bean references here, since doing so results in the
<code>ProxyFactoryBean</code> ignoring the singleton setting of the advice.</p>
</div>
<div class="paragraph">
<p>You can append an interceptor name with an asterisk (<code>*</code>). Doing so results in the
application of all advisor beans with names that start with the part before the asterisk
to be applied. You can find an example of using this feature in <a href="#aop-global-advisors">Using &#8220;Global&#8221; Advisors</a>.</p>
</div>
</li>
<li>
<p>singleton: Whether or not the factory should return a single object, no matter how
often the <code>getObject()</code> method is called. Several <code>FactoryBean</code> implementations offer
such a method. The default value is <code>true</code>. If you want to use stateful advice - for
example, for stateful mixins - use prototype advices along with a singleton value of
<code>false</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="aop-pfb-proxy-types"><a class="anchor" href="#aop-pfb-proxy-types"></a>6.4.3. JDK- and CGLIB-based proxies</h4>
<div class="paragraph">
<p>This section serves as the definitive documentation on how the <code>ProxyFactoryBean</code>
chooses to create either a JDK-based proxy or a CGLIB-based proxy for a particular target
object (which is to be proxied).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The behavior of the <code>ProxyFactoryBean</code> with regard to creating JDK- or CGLIB-based
proxies changed between versions 1.2.x and 2.0 of Spring. The <code>ProxyFactoryBean</code> now
exhibits similar semantics with regard to auto-detecting interfaces as those of the
<code>TransactionProxyFactoryBean</code> class.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the class of a target object that is to be proxied (hereafter simply referred to as
the target class) does not implement any interfaces, a CGLIB-based proxy is
created. This is the easiest scenario, because JDK proxies are interface-based, and no
interfaces means JDK proxying is not even possible. You can plug in the target bean
and specify the list of interceptors by setting the <code>interceptorNames</code> property. Note that a
CGLIB-based proxy is created even if the <code>proxyTargetClass</code> property of the
<code>ProxyFactoryBean</code> has been set to <code>false</code>. (Doing so makes no sense and is best
removed from the bean definition, because it is, at best, redundant, and, at worst
confusing.)</p>
</div>
<div class="paragraph">
<p>If the target class implements one (or more) interfaces, the type of proxy that is
created depends on the configuration of the <code>ProxyFactoryBean</code>.</p>
</div>
<div class="paragraph">
<p>If the <code>proxyTargetClass</code> property of the <code>ProxyFactoryBean</code> has been set to <code>true</code>,
a CGLIB-based proxy is created. This makes sense and is in keeping with the
principle of least surprise. Even if the <code>proxyInterfaces</code> property of the
<code>ProxyFactoryBean</code> has been set to one or more fully qualified interface names, the fact
that the <code>proxyTargetClass</code> property is set to <code>true</code> causes CGLIB-based
proxying to be in effect.</p>
</div>
<div class="paragraph">
<p>If the <code>proxyInterfaces</code> property of the <code>ProxyFactoryBean</code> has been set to one or more
fully qualified interface names, a JDK-based proxy is created. The created
proxy implements all of the interfaces that were specified in the <code>proxyInterfaces</code>
property. If the target class happens to implement a whole lot more interfaces than
those specified in the <code>proxyInterfaces</code> property, that is all well and good, but those
additional interfaces are not implemented by the returned proxy.</p>
</div>
<div class="paragraph">
<p>If the <code>proxyInterfaces</code> property of the <code>ProxyFactoryBean</code> has not been set, but
the target class does implement one (or more) interfaces, the
<code>ProxyFactoryBean</code> auto-detects the fact that the target class does actually
implement at least one interface, and a JDK-based proxy is created. The interfaces
that are actually proxied are all of the interfaces that the target class
implements. In effect, this is the same as supplying a list of each and every
interface that the target class implements to the <code>proxyInterfaces</code> property. However,
it is significantly less work and less prone to typographical errors.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-proxying-intf"><a class="anchor" href="#aop-api-proxying-intf"></a>6.4.4. Proxying Interfaces</h4>
<div class="paragraph">
<p>Consider a simple example of <code>ProxyFactoryBean</code> in action. This example involves:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A target bean that is proxied. This is the <code>personTarget</code> bean definition in
the example.</p>
</li>
<li>
<p>An <code>Advisor</code> and an <code>Interceptor</code> used to provide advice.</p>
</li>
<li>
<p>An AOP proxy bean definition to specify the target object (the <code>personTarget</code> bean),
the interfaces to proxy, and the advices to apply.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following listing shows the example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="personTarget" class="com.mycompany.PersonImpl"&gt;
    &lt;property name="name" value="Tony"/&gt;
    &lt;property name="age" value="51"/&gt;
&lt;/bean&gt;

&lt;bean id="myAdvisor" class="com.mycompany.MyAdvisor"&gt;
    &lt;property name="someProperty" value="Custom string property value"/&gt;
&lt;/bean&gt;

&lt;bean id="debugInterceptor" class="org.springframework.aop.interceptor.DebugInterceptor"&gt;
&lt;/bean&gt;

&lt;bean id="person"
    class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="proxyInterfaces" value="com.mycompany.Person"/&gt;

    &lt;property name="target" ref="personTarget"/&gt;
    &lt;property name="interceptorNames"&gt;
        &lt;list&gt;
            &lt;value&gt;myAdvisor&lt;/value&gt;
            &lt;value&gt;debugInterceptor&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the <code>interceptorNames</code> property takes a list of <code>String</code>, which holds the bean names of the
interceptors or advisors in the current factory. You can use advisors, interceptors, before, after
returning, and throws advice objects. The ordering of advisors is significant.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You might be wondering why the list does not hold bean references. The reason for this is
that, if the singleton property of the <code>ProxyFactoryBean</code> is set to <code>false</code>, it must be able to
return independent proxy instances. If any of the advisors is itself a prototype, an
independent instance would need to be returned, so it is necessary to be able to obtain
an instance of the prototype from the factory. Holding a reference is not sufficient.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>person</code> bean definition shown earlier can be used in place of a <code>Person</code> implementation, as
follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Person person = (Person) factory.getBean("person");</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val person = factory.getBean("person") as Person;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Other beans in the same IoC context can express a strongly typed dependency on it, as
with an ordinary Java object. The following example shows how to do so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="personUser" class="com.mycompany.PersonUser"&gt;
    &lt;property name="person"&gt;&lt;ref bean="person"/&gt;&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>PersonUser</code> class in this example exposes a property of type <code>Person</code>. As far as
it is concerned, the AOP proxy can be used transparently in place of a &#8220;real&#8221; person
implementation. However, its class would be a dynamic proxy class. It would be possible
to cast it to the <code>Advised</code> interface (discussed later).</p>
</div>
<div class="paragraph">
<p>You can conceal the distinction between target and proxy by using an anonymous
inner bean. Only the <code>ProxyFactoryBean</code> definition is different. The
advice is included only for completeness. The following example shows how to use an
anonymous inner bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="myAdvisor" class="com.mycompany.MyAdvisor"&gt;
    &lt;property name="someProperty" value="Custom string property value"/&gt;
&lt;/bean&gt;

&lt;bean id="debugInterceptor" class="org.springframework.aop.interceptor.DebugInterceptor"/&gt;

&lt;bean id="person" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="proxyInterfaces" value="com.mycompany.Person"/&gt;
    &lt;!-- Use inner bean, not local reference to target --&gt;
    &lt;property name="target"&gt;
        &lt;bean class="com.mycompany.PersonImpl"&gt;
            &lt;property name="name" value="Tony"/&gt;
            &lt;property name="age" value="51"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="interceptorNames"&gt;
        &lt;list&gt;
            &lt;value&gt;myAdvisor&lt;/value&gt;
            &lt;value&gt;debugInterceptor&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using an anonymous inner bean has the advantage that there is only one object of type <code>Person</code>. This is useful if we want
to prevent users of the application context from obtaining a reference to the un-advised
object or need to avoid any ambiguity with Spring IoC autowiring. There is also,
arguably, an advantage in that the <code>ProxyFactoryBean</code> definition is self-contained.
However, there are times when being able to obtain the un-advised target from the
factory might actually be an advantage (for example, in certain test scenarios).</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-api-proxying-class"><a class="anchor" href="#aop-api-proxying-class"></a>6.4.5. Proxying Classes</h4>
<div class="paragraph">
<p>What if you need to proxy a class, rather than one or more interfaces?</p>
</div>
<div class="paragraph">
<p>Imagine that in our earlier example, there was no <code>Person</code> interface. We needed to advise
a class called <code>Person</code> that did not implement any business interface. In this case, you
can configure Spring to use CGLIB proxying rather than dynamic proxies. To do so, set the
<code>proxyTargetClass</code> property on the <code>ProxyFactoryBean</code> shown earlier to <code>true</code>. While it is best to
program to interfaces rather than classes, the ability to advise classes that do not
implement interfaces can be useful when working with legacy code. (In general, Spring
is not prescriptive. While it makes it easy to apply good practices, it avoids forcing a
particular approach.)</p>
</div>
<div class="paragraph">
<p>If you want to, you can force the use of CGLIB in any case, even if you do have
interfaces.</p>
</div>
<div class="paragraph">
<p>CGLIB proxying works by generating a subclass of the target class at runtime. Spring
configures this generated subclass to delegate method calls to the original target. The
subclass is used to implement the Decorator pattern, weaving in the advice.</p>
</div>
<div class="paragraph">
<p>CGLIB proxying should generally be transparent to users. However, there are some issues
to consider:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Final</code> methods cannot be advised, as they cannot be overridden.</p>
</li>
<li>
<p>There is no need to add CGLIB to your classpath. As of Spring 3.2, CGLIB is repackaged
and included in the spring-core JAR. In other words, CGLIB-based AOP works &#8220;out of
the box&#8221;, as do JDK dynamic proxies.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There is little performance difference between CGLIB proxying and dynamic proxies.
Performance should not be a decisive consideration in this case.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-global-advisors"><a class="anchor" href="#aop-global-advisors"></a>6.4.6. Using &#8220;Global&#8221; Advisors</h4>
<div class="paragraph">
<p>By appending an asterisk to an interceptor name, all advisors with bean names that match
the part before the asterisk are added to the advisor chain. This can come in handy
if you need to add a standard set of &#8220;global&#8221; advisors. The following example defines
two global advisors:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="proxy" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="target" ref="service"/&gt;
    &lt;property name="interceptorNames"&gt;
        &lt;list&gt;
            &lt;value&gt;global*&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="global_debug" class="org.springframework.aop.interceptor.DebugInterceptor"/&gt;
&lt;bean id="global_performance" class="org.springframework.aop.interceptor.PerformanceMonitorInterceptor"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-concise-proxy"><a class="anchor" href="#aop-concise-proxy"></a>6.5. Concise Proxy Definitions</h3>
<div class="paragraph">
<p>Especially when defining transactional proxies, you may end up with many similar proxy
definitions. The use of parent and child bean definitions, along with inner bean
definitions, can result in much cleaner and more concise proxy definitions.</p>
</div>
<div class="paragraph">
<p>First, we create a parent, template, bean definition for the proxy, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="txProxyTemplate" abstract="true"
        class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="transactionManager" ref="transactionManager"/&gt;
    &lt;property name="transactionAttributes"&gt;
        &lt;props&gt;
            &lt;prop key="*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is never instantiated itself, so it can actually be incomplete. Then, each proxy
that needs to be created is a child bean definition, which wraps the target of the
proxy as an inner bean definition, since the target is never used on its own anyway.
The following example shows such a child bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="myService" parent="txProxyTemplate"&gt;
    &lt;property name="target"&gt;
        &lt;bean class="org.springframework.samples.MyServiceImpl"&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can override properties from the parent template. In the following example,
we override the transaction propagation settings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="mySpecialService" parent="txProxyTemplate"&gt;
    &lt;property name="target"&gt;
        &lt;bean class="org.springframework.samples.MySpecialServiceImpl"&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="transactionAttributes"&gt;
        &lt;props&gt;
            &lt;prop key="get*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
            &lt;prop key="find*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
            &lt;prop key="load*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
            &lt;prop key="store*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that in the parent bean example, we explicitly marked the parent bean definition as
being abstract by setting the <code>abstract</code> attribute to <code>true</code>, as described
<a href="#beans-child-bean-definitions">previously</a>, so that it may not actually ever be
instantiated. Application contexts (but not simple bean factories), by default,
pre-instantiate all singletons. Therefore, it is important (at least for singleton beans)
that, if you have a (parent) bean definition that you intend to use only as a template,
and this definition specifies a class, you must make sure to set the <code>abstract</code>
attribute to <code>true</code>. Otherwise, the application context actually tries to
pre-instantiate it.</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-prog"><a class="anchor" href="#aop-prog"></a>6.6. Creating AOP Proxies Programmatically with the <code>ProxyFactory</code></h3>
<div class="paragraph">
<p>It is easy to create AOP proxies programmatically with Spring. This lets you use
Spring AOP without dependency on Spring IoC.</p>
</div>
<div class="paragraph">
<p>The interfaces implemented by the target object are
automatically proxied. The following listing shows creation of a proxy for a target object, with one
interceptor and one advisor:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">ProxyFactory factory = new ProxyFactory(myBusinessInterfaceImpl);
factory.addAdvice(myMethodInterceptor);
factory.addAdvisor(myAdvisor);
MyBusinessInterface tb = (MyBusinessInterface) factory.getProxy();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val factory = ProxyFactory(myBusinessInterfaceImpl)
factory.addAdvice(myMethodInterceptor)
factory.addAdvisor(myAdvisor)
val tb = factory.proxy as MyBusinessInterface</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first step is to construct an object of type
<code>org.springframework.aop.framework.ProxyFactory</code>. You can create this with a target
object, as in the preceding example, or specify the interfaces to be proxied in an alternate
constructor.</p>
</div>
<div class="paragraph">
<p>You can add advices (with interceptors as a specialized kind of advice), advisors, or both
and manipulate them for the life of the <code>ProxyFactory</code>. If you add an
<code>IntroductionInterceptionAroundAdvisor</code>, you can cause the proxy to implement additional
interfaces.</p>
</div>
<div class="paragraph">
<p>There are also convenience methods on <code>ProxyFactory</code> (inherited from <code>AdvisedSupport</code>)
that let you add other advice types, such as before and throws advice.
<code>AdvisedSupport</code> is the superclass of both <code>ProxyFactory</code> and <code>ProxyFactoryBean</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Integrating AOP proxy creation with the IoC framework is best practice in most
applications. We recommend that you externalize configuration from Java code with AOP,
as you should in general.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="aop-api-advised"><a class="anchor" href="#aop-api-advised"></a>6.7. Manipulating Advised Objects</h3>
<div class="paragraph">
<p>However you create AOP proxies, you can manipulate them BY using the
<code>org.springframework.aop.framework.Advised</code> interface. Any AOP proxy can be cast to this
interface, no matter which other interfaces it implements. This interface includes the
following methods:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Advisor[] getAdvisors();

void addAdvice(Advice advice) throws AopConfigException;

void addAdvice(int pos, Advice advice) throws AopConfigException;

void addAdvisor(Advisor advisor) throws AopConfigException;

void addAdvisor(int pos, Advisor advisor) throws AopConfigException;

int indexOf(Advisor advisor);

boolean removeAdvisor(Advisor advisor) throws AopConfigException;

void removeAdvisor(int index) throws AopConfigException;

boolean replaceAdvisor(Advisor a, Advisor b) throws AopConfigException;

boolean isFrozen();</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">fun getAdvisors(): Array&lt;Advisor&gt;

@Throws(AopConfigException::class)
fun addAdvice(advice: Advice)

@Throws(AopConfigException::class)
fun addAdvice(pos: Int, advice: Advice)

@Throws(AopConfigException::class)
fun addAdvisor(advisor: Advisor)

@Throws(AopConfigException::class)
fun addAdvisor(pos: Int, advisor: Advisor)

fun indexOf(advisor: Advisor): Int

@Throws(AopConfigException::class)
fun removeAdvisor(advisor: Advisor): Boolean

@Throws(AopConfigException::class)
fun removeAdvisor(index: Int)

@Throws(AopConfigException::class)
fun replaceAdvisor(a: Advisor, b: Advisor): Boolean

fun isFrozen(): Boolean</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>getAdvisors()</code> method returns an <code>Advisor</code> for every advisor, interceptor, or
other advice type that has been added to the factory. If you added an <code>Advisor</code>, the
returned advisor at this index is the object that you added. If you added an
interceptor or other advice type, Spring wrapped this in an advisor with a
pointcut that always returns <code>true</code>. Thus, if you added a <code>MethodInterceptor</code>, the advisor
returned for this index is a <code>DefaultPointcutAdvisor</code> that returns your
<code>MethodInterceptor</code> and a pointcut that matches all classes and methods.</p>
</div>
<div class="paragraph">
<p>The <code>addAdvisor()</code> methods can be used to add any <code>Advisor</code>. Usually, the advisor holding
pointcut and advice is the generic <code>DefaultPointcutAdvisor</code>, which you can use with
any advice or pointcut (but not for introductions).</p>
</div>
<div class="paragraph">
<p>By default, it is possible to add or remove advisors or interceptors even once a proxy
has been created. The only restriction is that it is impossible to add or remove an
introduction advisor, as existing proxies from the factory do not show the interface
change. (You can obtain a new proxy from the factory to avoid this problem.)</p>
</div>
<div class="paragraph">
<p>The following example shows casting an AOP proxy to the <code>Advised</code> interface and examining and
manipulating its advice:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">Advised advised = (Advised) myObject;
Advisor[] advisors = advised.getAdvisors();
int oldAdvisorCount = advisors.length;
System.out.println(oldAdvisorCount + " advisors");

// Add an advice like an interceptor without a pointcut
// Will match all proxied methods
// Can use for interceptors, before, after returning or throws advice
advised.addAdvice(new DebugInterceptor());

// Add selective advice using a pointcut
advised.addAdvisor(new DefaultPointcutAdvisor(mySpecialPointcut, myAdvice));

assertEquals("Added two advisors", oldAdvisorCount + 2, advised.getAdvisors().length);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val advised = myObject as Advised
val advisors = advised.advisors
val oldAdvisorCount = advisors.size
println("$oldAdvisorCount advisors")

// Add an advice like an interceptor without a pointcut
// Will match all proxied methods
// Can use for interceptors, before, after returning or throws advice
advised.addAdvice(DebugInterceptor())

// Add selective advice using a pointcut
advised.addAdvisor(DefaultPointcutAdvisor(mySpecialPointcut, myAdvice))

assertEquals("Added two advisors", oldAdvisorCount + 2, advised.advisors.size)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is questionable whether it is advisable (no pun intended) to modify advice on a
business object in production, although there are, no doubt, legitimate usage cases.
However, it can be very useful in development (for example, in tests). We have sometimes
found it very useful to be able to add test code in the form of an interceptor or other
advice, getting inside a method invocation that we want to test. (For example, the advice can
get inside a transaction created for that method, perhaps to run SQL to check that
a database was correctly updated, before marking the transaction for roll back.)
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Depending on how you created the proxy, you can usually set a <code>frozen</code> flag. In that
case, the <code>Advised</code> <code>isFrozen()</code> method returns <code>true</code>, and any attempts to modify
advice through addition or removal results in an <code>AopConfigException</code>. The ability
to freeze the state of an advised object is useful in some cases (for example, to
prevent calling code removing a security interceptor).</p>
</div>
</div>
<div class="sect2">
<h3 id="aop-autoproxy"><a class="anchor" href="#aop-autoproxy"></a>6.8. Using the "auto-proxy" facility</h3>
<div class="paragraph">
<p>So far, we have considered explicit creation of AOP proxies by using a <code>ProxyFactoryBean</code> or
similar factory bean.</p>
</div>
<div class="paragraph">
<p>Spring also lets us use &#8220;auto-proxy&#8221; bean definitions, which can automatically
proxy selected bean definitions. This is built on Spring&#8217;s &#8220;bean post processor&#8221;
infrastructure, which enables modification of any bean definition as the container loads.</p>
</div>
<div class="paragraph">
<p>In this model, you set up some special bean definitions in your XML bean definition file
to configure the auto-proxy infrastructure. This lets you declare the targets
eligible for auto-proxying. You need not use <code>ProxyFactoryBean</code>.</p>
</div>
<div class="paragraph">
<p>There are two ways to do this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>By using an auto-proxy creator that refers to specific beans in the current context.</p>
</li>
<li>
<p>A special case of auto-proxy creation that deserves to be considered separately:
auto-proxy creation driven by source-level metadata attributes.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="aop-autoproxy-choices"><a class="anchor" href="#aop-autoproxy-choices"></a>6.8.1. Auto-proxy Bean Definitions</h4>
<div class="paragraph">
<p>This section covers the auto-proxy creators provided by the
<code>org.springframework.aop.framework.autoproxy</code> package.</p>
</div>
<div class="sect4">
<h5 id="aop-api-autoproxy"><a class="anchor" href="#aop-api-autoproxy"></a><code>BeanNameAutoProxyCreator</code></h5>
<div class="paragraph">
<p>The <code>BeanNameAutoProxyCreator</code> class is a <code>BeanPostProcessor</code> that automatically creates
AOP proxies for beans with names that match literal values or wildcards. The following
example shows how to create a <code>BeanNameAutoProxyCreator</code> bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"&gt;
    &lt;property name="beanNames" value="jdk*,onlyJdk"/&gt;
    &lt;property name="interceptorNames"&gt;
        &lt;list&gt;
            &lt;value&gt;myInterceptor&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>As with <code>ProxyFactoryBean</code>, there is an <code>interceptorNames</code> property rather than a list
of interceptors, to allow correct behavior for prototype advisors. Named &#8220;interceptors&#8221;
can be advisors or any advice type.</p>
</div>
<div class="paragraph">
<p>As with auto-proxying in general, the main point of using <code>BeanNameAutoProxyCreator</code> is
to apply the same configuration consistently to multiple objects, with minimal volume of
configuration. It is a popular choice for applying declarative transactions to multiple
objects.</p>
</div>
<div class="paragraph">
<p>Bean definitions whose names match, such as <code>jdkMyBean</code> and <code>onlyJdk</code> in the preceding
example, are plain old bean definitions with the target class. An AOP proxy is
automatically created by the <code>BeanNameAutoProxyCreator</code>. The same advice is applied
to all matching beans. Note that, if advisors are used (rather than the interceptor in
the preceding example), the pointcuts may apply differently to different beans.</p>
</div>
</div>
<div class="sect4">
<h5 id="aop-api-autoproxy-default"><a class="anchor" href="#aop-api-autoproxy-default"></a><code>DefaultAdvisorAutoProxyCreator</code></h5>
<div class="paragraph">
<p>A more general and extremely powerful auto-proxy creator is
<code>DefaultAdvisorAutoProxyCreator</code>. This automagically applies eligible advisors in the
current context, without the need to include specific bean names in the auto-proxy
advisor&#8217;s bean definition. It offers the same merit of consistent configuration and
avoidance of duplication as <code>BeanNameAutoProxyCreator</code>.</p>
</div>
<div class="paragraph">
<p>Using this mechanism involves:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Specifying a <code>DefaultAdvisorAutoProxyCreator</code> bean definition.</p>
</li>
<li>
<p>Specifying any number of advisors in the same or related contexts. Note that these
must be advisors, not interceptors or other advices. This is necessary,
because there must be a pointcut to evaluate, to check the eligibility of each advice
to candidate bean definitions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>DefaultAdvisorAutoProxyCreator</code> automatically evaluates the pointcut contained
in each advisor, to see what (if any) advice it should apply to each business object
(such as <code>businessObject1</code> and <code>businessObject2</code> in the example).</p>
</div>
<div class="paragraph">
<p>This means that any number of advisors can be applied automatically to each business
object. If no pointcut in any of the advisors matches any method in a business object,
the object is not proxied. As bean definitions are added for new business objects,
they are automatically proxied if necessary.</p>
</div>
<div class="paragraph">
<p>Auto-proxying in general has the advantage of making it impossible for callers or
dependencies to obtain an un-advised object. Calling <code>getBean("businessObject1")</code> on this
<code>ApplicationContext</code> returns an AOP proxy, not the target business object. (The &#8220;inner
bean&#8221; idiom shown earlier also offers this benefit.)</p>
</div>
<div class="paragraph">
<p>The following example creates a <code>DefaultAdvisorAutoProxyCreator</code> bean and the other
elements discussed in this section:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/&gt;

&lt;bean class="org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"&gt;
    &lt;property name="transactionInterceptor" ref="transactionInterceptor"/&gt;
&lt;/bean&gt;

&lt;bean id="customAdvisor" class="com.mycompany.MyAdvisor"/&gt;

&lt;bean id="businessObject1" class="com.mycompany.BusinessObject1"&gt;
    &lt;!-- Properties omitted --&gt;
&lt;/bean&gt;

&lt;bean id="businessObject2" class="com.mycompany.BusinessObject2"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>DefaultAdvisorAutoProxyCreator</code> is very useful if you want to apply the same advice
consistently to many business objects. Once the infrastructure definitions are in place,
you can add new business objects without including specific proxy configuration.
You can also easily drop in additional aspects (for example, tracing or
performance monitoring aspects) with minimal change to configuration.</p>
</div>
<div class="paragraph">
<p>The <code>DefaultAdvisorAutoProxyCreator</code> offers support for filtering (by using a naming
convention so that only certain advisors are evaluated, which allows the use of multiple,
differently configured, AdvisorAutoProxyCreators in the same factory) and ordering.
Advisors can implement the <code>org.springframework.core.Ordered</code> interface to ensure
correct ordering if this is an issue. The <code>TransactionAttributeSourceAdvisor</code> used in the
preceding example has a configurable order value. The default setting is unordered.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-targetsource"><a class="anchor" href="#aop-targetsource"></a>6.9. Using <code>TargetSource</code> Implementations</h3>
<div class="paragraph">
<p>Spring offers the concept of a <code>TargetSource</code>, expressed in the
<code>org.springframework.aop.TargetSource</code> interface. This interface is responsible for
returning the &#8220;target object&#8221; that implements the join point. The <code>TargetSource</code>
implementation is asked for a target instance each time the AOP proxy handles a method
invocation.</p>
</div>
<div class="paragraph">
<p>Developers who use Spring AOP do not normally need to work directly with <code>TargetSource</code> implementations, but
this provides a powerful means of supporting pooling, hot swappable, and other
sophisticated targets. For example, a pooling <code>TargetSource</code> can return a different target
instance for each invocation, by using a pool to manage instances.</p>
</div>
<div class="paragraph">
<p>If you do not specify a <code>TargetSource</code>, a default implementation is used to wrap a
local object. The same target is returned for each invocation (as you would expect).</p>
</div>
<div class="paragraph">
<p>The rest of this section describes the standard target sources provided with Spring and how you can use them.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
When using a custom target source, your target will usually need to be a prototype
rather than a singleton bean definition. This allows Spring to create a new target
instance when required.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="aop-ts-swap"><a class="anchor" href="#aop-ts-swap"></a>6.9.1. Hot-swappable Target Sources</h4>
<div class="paragraph">
<p>The <code>org.springframework.aop.target.HotSwappableTargetSource</code> exists to let the target
of an AOP proxy be switched while letting callers keep their references to it.</p>
</div>
<div class="paragraph">
<p>Changing the target source&#8217;s target takes effect immediately. The
<code>HotSwappableTargetSource</code> is thread-safe.</p>
</div>
<div class="paragraph">
<p>You can change the target by using the <code>swap()</code> method on HotSwappableTargetSource, as the follow example shows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">HotSwappableTargetSource swapper = (HotSwappableTargetSource) beanFactory.getBean("swapper");
Object oldTarget = swapper.swap(newTarget);</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val swapper = beanFactory.getBean("swapper") as HotSwappableTargetSource
val oldTarget = swapper.swap(newTarget)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example shows the required XML definitions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="initialTarget" class="mycompany.OldTarget"/&gt;

&lt;bean id="swapper" class="org.springframework.aop.target.HotSwappableTargetSource"&gt;
    &lt;constructor-arg ref="initialTarget"/&gt;
&lt;/bean&gt;

&lt;bean id="swappable" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="targetSource" ref="swapper"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding <code>swap()</code> call changes the target of the swappable bean. Clients that hold a
reference to that bean are unaware of the change but immediately start hitting
the new target.</p>
</div>
<div class="paragraph">
<p>Although this example does not add any advice (it is not necessary to add advice to
use a <code>TargetSource</code>), any <code>TargetSource</code> can be used in conjunction with
arbitrary advice.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ts-pool"><a class="anchor" href="#aop-ts-pool"></a>6.9.2. Pooling Target Sources</h4>
<div class="paragraph">
<p>Using a pooling target source provides a similar programming model to stateless session
EJBs, in which a pool of identical instances is maintained, with method invocations
going to free objects in the pool.</p>
</div>
<div class="paragraph">
<p>A crucial difference between Spring pooling and SLSB pooling is that Spring pooling can
be applied to any POJO. As with Spring in general, this service can be applied in a
non-invasive way.</p>
</div>
<div class="paragraph">
<p>Spring provides support for Commons Pool 2.2, which provides a
fairly efficient pooling implementation. You need the <code>commons-pool</code> Jar on your
application&#8217;s classpath to use this feature. You can also subclass
<code>org.springframework.aop.target.AbstractPoolingTargetSource</code> to support any other
pooling API.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Commons Pool 1.5+ is also supported but is deprecated as of Spring Framework 4.2.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following listing shows an example configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="businessObjectTarget" class="com.mycompany.MyBusinessObject"
        scope="prototype"&gt;
    ... properties omitted
&lt;/bean&gt;

&lt;bean id="poolTargetSource" class="org.springframework.aop.target.CommonsPool2TargetSource"&gt;
    &lt;property name="targetBeanName" value="businessObjectTarget"/&gt;
    &lt;property name="maxSize" value="25"/&gt;
&lt;/bean&gt;

&lt;bean id="businessObject" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="targetSource" ref="poolTargetSource"/&gt;
    &lt;property name="interceptorNames" value="myInterceptor"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the target object (<code>businessObjectTarget</code> in the preceding example) must be a
prototype. This lets the <code>PoolingTargetSource</code> implementation create new instances
of the target to grow the pool as necessary. See the <a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframeworkaop/target/AbstractPoolingTargetSource.html">javadoc of
<code>AbstractPoolingTargetSource</code></a> and the concrete subclass you wish to use for information
about its properties. <code>maxSize</code> is the most basic and is always guaranteed to be present.</p>
</div>
<div class="paragraph">
<p>In this case, <code>myInterceptor</code> is the name of an interceptor that would need to be
defined in the same IoC context. However, you need not specify interceptors to
use pooling. If you want only pooling and no other advice, do not set the
<code>interceptorNames</code> property at all.</p>
</div>
<div class="paragraph">
<p>You can configure Spring to be able to cast any pooled object to the
<code>org.springframework.aop.target.PoolingConfig</code> interface, which exposes information
about the configuration and current size of the pool through an introduction. You
need to define an advisor similar to the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="poolConfigAdvisor" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;
    &lt;property name="targetObject" ref="poolTargetSource"/&gt;
    &lt;property name="targetMethod" value="getPoolingConfigMixin"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This advisor is obtained by calling a convenience method on the
<code>AbstractPoolingTargetSource</code> class, hence the use of <code>MethodInvokingFactoryBean</code>. This
advisor&#8217;s name (<code>poolConfigAdvisor</code>, here) must be in the list of interceptors names in
the <code>ProxyFactoryBean</code> that exposes the pooled object.</p>
</div>
<div class="paragraph">
<p>The cast is defined as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">PoolingConfig conf = (PoolingConfig) beanFactory.getBean("businessObject");
System.out.println("Max pool size is " + conf.getMaxSize());</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val conf = beanFactory.getBean("businessObject") as PoolingConfig
println("Max pool size is " + conf.maxSize)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Pooling stateless service objects is not usually necessary. We do not believe it should
be the default choice, as most stateless objects are naturally thread safe, and instance
pooling is problematic if resources are cached.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Simpler pooling is available by using auto-proxying. You can set the <code>TargetSource</code> implementations
used by any auto-proxy creator.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ts-prototype"><a class="anchor" href="#aop-ts-prototype"></a>6.9.3. Prototype Target Sources</h4>
<div class="paragraph">
<p>Setting up a &#8220;prototype&#8221; target source is similar to setting up a pooling <code>TargetSource</code>. In this
case, a new instance of the target is created on every method invocation. Although
the cost of creating a new object is not high in a modern JVM, the cost of wiring up the
new object (satisfying its IoC dependencies) may be more expensive. Thus, you should not
use this approach without very good reason.</p>
</div>
<div class="paragraph">
<p>To do this, you could modify the <code>poolTargetSource</code> definition shown earlier as follows
(we also changed the name, for clarity):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="prototypeTargetSource" class="org.springframework.aop.target.PrototypeTargetSource"&gt;
    &lt;property name="targetBeanName" ref="businessObjectTarget"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The only property is the name of the target bean. Inheritance is used in the
<code>TargetSource</code> implementations to ensure consistent naming. As with the pooling target
source, the target bean must be a prototype bean definition.</p>
</div>
</div>
<div class="sect3">
<h4 id="aop-ts-threadlocal"><a class="anchor" href="#aop-ts-threadlocal"></a>6.9.4. <code>ThreadLocal</code> Target Sources</h4>
<div class="paragraph">
<p><code>ThreadLocal</code> target sources are useful if you need an object to be created for each
incoming request (per thread that is). The concept of a <code>ThreadLocal</code> provides a JDK-wide
facility to transparently store a resource alongside a thread. Setting up a
<code>ThreadLocalTargetSource</code> is pretty much the same as was explained for the other types
of target source, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="threadlocalTargetSource" class="org.springframework.aop.target.ThreadLocalTargetSource"&gt;
    &lt;property name="targetBeanName" value="businessObjectTarget"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>ThreadLocal</code> instances come with serious issues (potentially resulting in memory leaks) when
incorrectly using them in multi-threaded and multi-classloader environments. You
should always consider wrapping a threadlocal in some other class and never directly use
the <code>ThreadLocal</code> itself (except in the wrapper class). Also, you should
always remember to correctly set and unset (where the latter simply involves a call to
<code>ThreadLocal.set(null)</code>) the resource local to the thread. Unsetting should be done in
any case, since not unsetting it might result in problematic behavior. Spring&#8217;s
<code>ThreadLocal</code> support does this for you and should always be considered in favor of using
<code>ThreadLocal</code> instances without other proper handling code.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="aop-extensibility"><a class="anchor" href="#aop-extensibility"></a>6.10. Defining New Advice Types</h3>
<div class="paragraph">
<p>Spring AOP is designed to be extensible. While the interception implementation strategy
is presently used internally, it is possible to support arbitrary advice types in
addition to the interception around advice, before, throws advice, and
after returning advice.</p>
</div>
<div class="paragraph">
<p>The <code>org.springframework.aop.framework.adapter</code> package is an SPI package that lets
support for new custom advice types be added without changing the core framework.
The only constraint on a custom <code>Advice</code> type is that it must implement the
<code>org.aopalliance.aop.Advice</code> marker interface.</p>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/aop/framework/adapter/package-frame.html"><code>org.springframework.aop.framework.adapter</code></a>
javadoc for further information.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="null-safety"><a class="anchor" href="#null-safety"></a>7. Null-safety</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Although Java does not let you express null-safety with its type system, the Spring Framework
now provides the following annotations in the <code>org.springframework.lang</code> package to let you
declare nullability of APIs and fields:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/lang/Nullable.html"><code>@Nullable</code></a>: Annotation to indicate that a
specific parameter, return value, or field can be <code>null</code>.</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/lang/NonNull.html"><code>@NonNull</code></a>: Annotation to indicate that a specific
parameter, return value, or field cannot be <code>null</code> (not needed on parameters / return values
and fields where <code>@NonNullApi</code> and <code>@NonNullFields</code> apply, respectively).</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/lang/NonNullApi.html"><code>@NonNullApi</code></a>: Annotation at the package level
that declares non-null as the default semantics for parameters and return values.</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/lang/NonNullFields.html"><code>@NonNullFields</code></a>: Annotation at the package
level that declares non-null as the default semantics for fields.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Spring Framework itself leverages these annotations, but they can also be used in any
Spring-based Java project to declare null-safe APIs and optionally null-safe fields.
Generic type arguments, varargs and array elements nullability are not supported yet but
should be in an upcoming release, see <a href="https://jira.spring.io/browse/SPR-15942">SPR-15942</a>
for up-to-date information. Nullability declarations are expected to be fine-tuned between
Spring Framework releases, including minor ones. Nullability of types used inside method
bodies is outside of the scope of this feature.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Other common libraries such as Reactor and Spring Data provide null-safe APIs that
use a similar nullability arrangement, delivering a consistent overall experience for
Spring application developers.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="use-cases"><a class="anchor" href="#use-cases"></a>7.1. Use cases</h3>
<div class="paragraph">
<p>In addition to providing an explicit declaration for Spring Framework API nullability,
these annotations can be used by an IDE (such as IDEA or Eclipse) to provide useful
warnings related to null-safety in order to avoid <code>NullPointerException</code> at runtime.</p>
</div>
<div class="paragraph">
<p>They are also used to make Spring API null-safe in Kotlin projects, since Kotlin natively
supports <a href="https://kotlinlang.org/docs/reference/null-safety.html">null-safety</a>. More details
are available in the <a href="languages.html#kotlin-null-safety">Kotlin support documentation</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="jsr-305-meta-annotations"><a class="anchor" href="#jsr-305-meta-annotations"></a>7.2. JSR-305 meta-annotations</h3>
<div class="paragraph">
<p>Spring annotations are meta-annotated with <a href="https://jcp.org/en/jsr/detail?id=305">JSR 305</a>
annotations (a dormant but wide-spread JSR). JSR-305 meta-annotations let tooling vendors
like IDEA or Kotlin provide null-safety support in a generic way, without having to
hard-code support for Spring annotations.</p>
</div>
<div class="paragraph">
<p>It is not necessary nor recommended to add a JSR-305 dependency to the project classpath to
take advantage of Spring null-safe API. Only projects such as Spring-based libraries that use
null-safety annotations in their codebase should add <code>com.google.code.findbugs:jsr305:3.0.2</code>
with <code>compileOnly</code> Gradle configuration or Maven <code>provided</code> scope to avoid compile warnings.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="databuffers"><a class="anchor" href="#databuffers"></a>8. Data Buffers and Codecs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Java NIO provides <code>ByteBuffer</code> but many libraries build their own byte buffer API on top,
especially for network operations where reusing buffers and/or using direct buffers is
beneficial for performance. For example Netty has the <code>ByteBuf</code> hierarchy, Undertow uses
XNIO, Jetty uses pooled byte buffers with a callback to be released, and so on.
The <code>spring-core</code> module provides a set of abstractions to work with various byte buffer
APIs as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#databuffers-factory"><code>DataBufferFactory</code></a> abstracts the creation of a data buffer.</p>
</li>
<li>
<p><a href="#databuffers-buffer"><code>DataBuffer</code></a> represents a byte buffer, which may be
<a href="#databuffers-buffer-pooled">pooled</a>.</p>
</li>
<li>
<p><a href="#databuffers-utils"><code>DataBufferUtils</code></a> offers utility methods for data buffers.</p>
</li>
<li>
<p><a href="#codecs">Codecs</a> decode or encode streams data buffer streams into higher level objects.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="databuffers-factory"><a class="anchor" href="#databuffers-factory"></a>8.1. <code>DataBufferFactory</code></h3>
<div class="paragraph">
<p><code>DataBufferFactory</code> is used to create data buffers in one of two ways:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Allocate a new data buffer, optionally specifying capacity upfront, if known, which is
more efficient even though implementations of <code>DataBuffer</code> can grow and shrink on demand.</p>
</li>
<li>
<p>Wrap an existing <code>byte[]</code> or <code>java.nio.ByteBuffer</code>, which decorates the given data with
a <code>DataBuffer</code> implementation and that does not involve allocation.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that WebFlux applications do not create a <code>DataBufferFactory</code> directly but instead
access it through the <code>ServerHttpResponse</code> or the <code>ClientHttpRequest</code> on the client side.
The type of factory depends on the underlying client or server, e.g.
<code>NettyDataBufferFactory</code> for Reactor Netty, <code>DefaultDataBufferFactory</code> for others.</p>
</div>
</div>
<div class="sect2">
<h3 id="databuffers-buffer"><a class="anchor" href="#databuffers-buffer"></a>8.2. <code>DataBuffer</code></h3>
<div class="paragraph">
<p>The <code>DataBuffer</code> interface offers similar operations as <code>java.nio.ByteBuffer</code> but also
brings a few additional benefits some of which are inspired by the Netty <code>ByteBuf</code>.
Below is a partial list of benefits:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Read and write with independent positions, i.e. not requiring a call to <code>flip()</code> to
alternate between read and write.</p>
</li>
<li>
<p>Capacity expanded on demand as with <code>java.lang.StringBuilder</code>.</p>
</li>
<li>
<p>Pooled buffers and reference counting via <a href="#databuffers-buffer-pooled"><code>PooledDataBuffer</code></a>.</p>
</li>
<li>
<p>View a buffer as <code>java.nio.ByteBuffer</code>, <code>InputStream</code>, or <code>OutputStream</code>.</p>
</li>
<li>
<p>Determine the index, or the last index, for a given byte.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="databuffers-buffer-pooled"><a class="anchor" href="#databuffers-buffer-pooled"></a>8.3. <code>PooledDataBuffer</code></h3>
<div class="paragraph">
<p>As explained in the Javadoc for
<a href="https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html">ByteBuffer</a>,
byte buffers can be direct or non-direct. Direct buffers may reside outside the Java heap
which eliminates the need for copying for native I/O operations. That makes direct buffers
particularly useful for receiving and sending data over a socket, but they&#8217;re also more
expensive to create and release, which leads to the idea of pooling buffers.</p>
</div>
<div class="paragraph">
<p><code>PooledDataBuffer</code> is an extension of <code>DataBuffer</code> that helps with reference counting which
is essential for byte buffer pooling. How does it work? When a <code>PooledDataBuffer</code> is
allocated the reference count is at 1. Calls to <code>retain()</code> increment the count, while
calls to <code>release()</code> decrement it. As long as the count is above 0, the buffer is
guaranteed not to be released. When the count is decreased to 0, the pooled buffer can be
released, which in practice could mean the reserved memory for the buffer is returned to
the memory pool.</p>
</div>
<div class="paragraph">
<p>Note that instead of operating on <code>PooledDataBuffer</code> directly, in most cases it&#8217;s better
to use the convenience methods in <code>DataBufferUtils</code> that apply release or retain to a
<code>DataBuffer</code> only if it is an instance of <code>PooledDataBuffer</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="databuffers-utils"><a class="anchor" href="#databuffers-utils"></a>8.4. <code>DataBufferUtils</code></h3>
<div class="paragraph">
<p><code>DataBufferUtils</code> offers a number of utility methods to operate on data buffers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Join a stream of data buffers into a single buffer possibly with zero copy, e.g. via
composite buffers, if that&#8217;s supported by the underlying byte buffer API.</p>
</li>
<li>
<p>Turn <code>InputStream</code> or NIO <code>Channel</code> into <code>Flux&lt;DataBuffer&gt;</code>, and vice versa a
<code>Publisher&lt;DataBuffer&gt;</code> into <code>OutputStream</code> or NIO <code>Channel</code>.</p>
</li>
<li>
<p>Methods to release or retain a <code>DataBuffer</code> if the buffer is an instance of
<code>PooledDataBuffer</code>.</p>
</li>
<li>
<p>Skip or take from a stream of bytes until a specific byte count.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="codecs"><a class="anchor" href="#codecs"></a>8.5. Codecs</h3>
<div class="paragraph">
<p>The <code>org.springframework.core.codec</code> package provides the following strategy interfaces:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Encoder</code> to encode <code>Publisher&lt;T&gt;</code> into a stream of data buffers.</p>
</li>
<li>
<p><code>Decoder</code> to decode <code>Publisher&lt;DataBuffer&gt;</code> into a stream of higher level objects.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>spring-core</code> module provides <code>byte[]</code>, <code>ByteBuffer</code>, <code>DataBuffer</code>, <code>Resource</code>, and
<code>String</code> encoder and decoder implementations. The <code>spring-web</code> module adds Jackson JSON,
Jackson Smile, JAXB2, Protocol Buffers and other encoders and decoders. See
<a href="web-reactive.html#webflux-codecs">Codecs</a> in the WebFlux section.</p>
</div>
</div>
<div class="sect2">
<h3 id="databuffers-using"><a class="anchor" href="#databuffers-using"></a>8.6. Using <code>DataBuffer</code></h3>
<div class="paragraph">
<p>When working with data buffers, special care must be taken to ensure buffers are released
since they may be <a href="#databuffers-buffer-pooled">pooled</a>. We&#8217;ll use codecs to illustrate
how that works but the concepts apply more generally. Let&#8217;s see what codecs must do
internally to manage data buffers.</p>
</div>
<div class="paragraph">
<p>A <code>Decoder</code> is the last to read input data buffers, before creating higher level
objects, and therefore it must release them as follows:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>If a <code>Decoder</code> simply reads each input buffer and is ready to
release it immediately, it can do so via <code>DataBufferUtils.release(dataBuffer)</code>.</p>
</li>
<li>
<p>If a <code>Decoder</code> is using <code>Flux</code> or <code>Mono</code> operators such as <code>flatMap</code>, <code>reduce</code>, and
others that prefetch and cache data items internally, or is using operators such as
<code>filter</code>, <code>skip</code>, and others that leave out items, then
<code>doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release)</code> must be added to the
composition chain to ensure such buffers are released prior to being discarded, possibly
also as a result an error or cancellation signal.</p>
</li>
<li>
<p>If a <code>Decoder</code> holds on to one or more data buffers in any other way, it must
ensure they are released when fully read, or in case an error or cancellation signals that
take place before the cached data buffers have been read and released.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note that <code>DataBufferUtils#join</code> offers a safe and efficient way to aggregate a data
buffer stream into a single data buffer. Likewise <code>skipUntilByteCount</code> and
<code>takeUntilByteCount</code> are additional safe methods for decoders to use.</p>
</div>
<div class="paragraph">
<p>An <code>Encoder</code> allocates data buffers that others must read (and release). So an <code>Encoder</code>
doesn&#8217;t have much to do. However an <code>Encoder</code> must take care to release a data buffer if
a serialization error occurs while populating the buffer with data. For example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">DataBuffer buffer = factory.allocateBuffer();
boolean release = true;
try {
    // serialize and populate buffer..
    release = false;
}
finally {
    if (release) {
        DataBufferUtils.release(buffer);
    }
}
return buffer;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">val buffer = factory.allocateBuffer()
var release = true
try {
    // serialize and populate buffer..
    release = false
} finally {
    if (release) {
        DataBufferUtils.release(buffer)
    }
}
return buffer</code></pre>
</div>
</div>
<div class="paragraph">
<p>The consumer of an <code>Encoder</code> is responsible for releasing the data buffers it receives.
In a WebFlux application, the output of the <code>Encoder</code> is used to write to the HTTP server
response, or to the client HTTP request, in which case releasing the data buffers is the
responsibility of the code writing to the server response, or to the client request.</p>
</div>
<div class="paragraph">
<p>Note that when running on Netty, there are debugging options for
<a href="https://github.com/netty/netty/wiki/Reference-counted-objects#troubleshooting-buffer-leaks">troubleshooting buffer leaks</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="spring-jcl"><a class="anchor" href="#spring-jcl"></a>9. Logging</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Since Spring Framework 5.0, Spring comes with its own Commons Logging bridge implemented
in the <code>spring-jcl</code> module. The implementation checks for the presence of the Log4j 2.x
API and the SLF4J 1.7 API in the classpath and uses the first one of those found as the
logging implementation, falling back to the Java platform&#8217;s core logging facilities (also
known as <em>JUL</em> or <code>java.util.logging</code>) if neither Log4j 2.x nor SLF4J is available.</p>
</div>
<div class="paragraph">
<p>Put Log4j 2.x or Logback (or another SLF4J provider) in your classpath, without any extra
bridges, and let the framework auto-adapt to your choice. For further information see the
<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-logging">Spring
Boot Logging Reference Documentation</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring&#8217;s Commons Logging variant is only meant to be used for infrastructure logging
purposes in the core framework and in extensions.</p>
</div>
<div class="paragraph">
<p>For logging needs within application code, prefer direct use of Log4j 2.x, SLF4J, or JUL.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A <code>Log</code> implementation may be retrieved via <code>org.apache.commons.logging.LogFactory</code> as in
the following example.</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">public class MyBean {
    private final Log log = LogFactory.getLog(getClass());
    // ...
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">class MyBean {
  private val log = LogFactory.getLog(javaClass)
  // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix"><a class="anchor" href="#appendix"></a>10. Appendix</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="xsd-schemas"><a class="anchor" href="#xsd-schemas"></a>10.1. XML Schemas</h3>
<div class="paragraph">
<p>This part of the appendix lists XML schemas related to the core container.</p>
</div>
<div class="sect3">
<h4 id="xsd-schemas-util"><a class="anchor" href="#xsd-schemas-util"></a>10.1.1. The <code>util</code> Schema</h4>
<div class="paragraph">
<p>As the name implies, the <code>util</code> tags deal with common, utility configuration
issues, such as configuring collections, referencing constants, and so forth.
To use the tags in the <code>util</code> schema, you need to have the following preamble at the top
of your Spring XML configuration file (the text in the snippet references the
correct schema so that the tags in the <code>util</code> namespace are available to you):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:util="http://www.springframework.org/schema/util"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd"&gt;

        &lt;!-- bean definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-util-constant"><a class="anchor" href="#xsd-schemas-util-constant"></a>Using <code>&lt;util:constant/&gt;</code></h5>
<div class="paragraph">
<p>Consider the following bean definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="..." class="..."&gt;
    &lt;property name="isolation"&gt;
        &lt;bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
                class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" /&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration uses a Spring <code>FactoryBean</code> implementation (the
<code>FieldRetrievingFactoryBean</code>) to set the value of the <code>isolation</code> property on a bean
to the value of the <code>java.sql.Connection.TRANSACTION_SERIALIZABLE</code> constant. This is
all well and good, but it is verbose and (unnecessarily) exposes Spring&#8217;s internal
plumbing to the end user.</p>
</div>
<div class="paragraph">
<p>The following XML Schema-based version is more concise, clearly expresses the
developer&#8217;s intent (&#8220;inject this constant value&#8221;), and it reads better:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="..." class="..."&gt;
    &lt;property name="isolation"&gt;
        &lt;util:constant static-field="java.sql.Connection.TRANSACTION_SERIALIZABLE"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="xsd-schemas-util-frfb"><a class="anchor" href="#xsd-schemas-util-frfb"></a>Setting a Bean Property or Constructor Argument from a Field Value</h6>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html"><code>FieldRetrievingFactoryBean</code></a>
is a <code>FactoryBean</code> that retrieves a <code>static</code> or non-static field value. It is typically
used for retrieving <code>public</code> <code>static</code> <code>final</code> constants, which may then be used to set a
property value or constructor argument for another bean.</p>
</div>
<div class="paragraph">
<p>The following example shows how a <code>static</code> field is exposed, by using the
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html#setStaticField(java.lang.String)"><code>staticField</code></a>
property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="myField"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean"&gt;
    &lt;property name="staticField" value="java.sql.Connection.TRANSACTION_SERIALIZABLE"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is also a convenience usage form where the <code>static</code> field is specified as the bean
name, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This does mean that there is no longer any choice in what the bean <code>id</code> is (so any other
bean that refers to it also has to use this longer name), but this form is very
concise to define and very convenient to use as an inner bean since the <code>id</code> does not have
to be specified for the bean reference, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="..." class="..."&gt;
    &lt;property name="isolation"&gt;
        &lt;bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
                class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" /&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also access a non-static (instance) field of another bean, as
described in the API documentation for the
<a href="https://docs.spring.io/spring-framework/docs/5.3.7/javadoc-api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html"><code>FieldRetrievingFactoryBean</code></a>
class.</p>
</div>
<div class="paragraph">
<p>Injecting enumeration values into beans as either property or constructor arguments is
easy to do in Spring. You do not actually have to do anything or know anything about
the Spring internals (or even about classes such as the <code>FieldRetrievingFactoryBean</code>).
The following example enumeration shows how easy injecting an enum value is:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package javax.persistence;

public enum PersistenceContextType {

    TRANSACTION,
    EXTENDED
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package javax.persistence

enum class PersistenceContextType {

    TRANSACTION,
    EXTENDED
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now consider the following setter of type <code>PersistenceContextType</code> and the corresponding bean definition:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package example;

public class Client {

    private PersistenceContextType persistenceContextType;

    public void setPersistenceContextType(PersistenceContextType type) {
        this.persistenceContextType = type;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package example

class Client {

    lateinit var persistenceContextType: PersistenceContextType
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean class="example.Client"&gt;
    &lt;property name="persistenceContextType" value="TRANSACTION"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-util-property-path"><a class="anchor" href="#xsd-schemas-util-property-path"></a>Using <code>&lt;util:property-path/&gt;</code></h5>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- target bean to be referenced by name --&gt;
&lt;bean id="testBean" class="org.springframework.beans.TestBean" scope="prototype"&gt;
    &lt;property name="age" value="10"/&gt;
    &lt;property name="spouse"&gt;
        &lt;bean class="org.springframework.beans.TestBean"&gt;
            &lt;property name="age" value="11"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;!-- results in 10, which is the value of property 'age' of bean 'testBean' --&gt;
&lt;bean id="testBean.age" class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration uses a Spring <code>FactoryBean</code> implementation (the
<code>PropertyPathFactoryBean</code>) to create a bean (of type <code>int</code>) called <code>testBean.age</code> that
has a value equal to the <code>age</code> property of the <code>testBean</code> bean.</p>
</div>
<div class="paragraph">
<p>Now consider the following example, which adds a <code>&lt;util:property-path/&gt;</code> element:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- target bean to be referenced by name --&gt;
&lt;bean id="testBean" class="org.springframework.beans.TestBean" scope="prototype"&gt;
    &lt;property name="age" value="10"/&gt;
    &lt;property name="spouse"&gt;
        &lt;bean class="org.springframework.beans.TestBean"&gt;
            &lt;property name="age" value="11"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;!-- results in 10, which is the value of property 'age' of bean 'testBean' --&gt;
&lt;util:property-path id="name" path="testBean.age"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value of the <code>path</code> attribute of the <code>&lt;property-path/&gt;</code> element follows the form of
<code>beanName.beanProperty</code>. In this case, it picks up the <code>age</code> property of the bean named
<code>testBean</code>. The value of that <code>age</code> property is <code>10</code>.</p>
</div>
<div class="sect5">
<h6 id="xsd-schemas-util-property-path-dependency"><a class="anchor" href="#xsd-schemas-util-property-path-dependency"></a>Using <code>&lt;util:property-path/&gt;</code> to Set a Bean Property or Constructor Argument</h6>
<div class="paragraph">
<p><code>PropertyPathFactoryBean</code> is a <code>FactoryBean</code> that evaluates a property path on a given
target object. The target object can be specified directly or by a bean name. You can then use this
value in another bean definition as a property value or constructor
argument.</p>
</div>
<div class="paragraph">
<p>The following example shows a path being used against another bean, by name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- target bean to be referenced by name --&gt;
&lt;bean id="person" class="org.springframework.beans.TestBean" scope="prototype"&gt;
    &lt;property name="age" value="10"/&gt;
    &lt;property name="spouse"&gt;
        &lt;bean class="org.springframework.beans.TestBean"&gt;
            &lt;property name="age" value="11"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;!-- results in 11, which is the value of property 'spouse.age' of bean 'person' --&gt;
&lt;bean id="theAge"
        class="org.springframework.beans.factory.config.PropertyPathFactoryBean"&gt;
    &lt;property name="targetBeanName" value="person"/&gt;
    &lt;property name="propertyPath" value="spouse.age"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the following example, a path is evaluated against an inner bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- results in 12, which is the value of property 'age' of the inner bean --&gt;
&lt;bean id="theAge"
        class="org.springframework.beans.factory.config.PropertyPathFactoryBean"&gt;
    &lt;property name="targetObject"&gt;
        &lt;bean class="org.springframework.beans.TestBean"&gt;
            &lt;property name="age" value="12"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="propertyPath" value="age"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is also a shortcut form, where the bean name is the property path.
The following example shows the shortcut form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- results in 10, which is the value of property 'age' of bean 'person' --&gt;
&lt;bean id="person.age"
        class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This form does mean that there is no choice in the name of the bean. Any reference to it
also has to use the same <code>id</code>, which is the path. If used as an inner
bean, there is no need to refer to it at all, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="..." class="..."&gt;
    &lt;property name="age"&gt;
        &lt;bean id="person.age"
                class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can specifically set the result type in the actual definition. This is not necessary
for most use cases, but it can sometimes be useful. See the javadoc for more info on
this feature.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-util-properties"><a class="anchor" href="#xsd-schemas-util-properties"></a>Using <code>&lt;util:properties/&gt;</code></h5>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- creates a java.util.Properties instance with values loaded from the supplied location --&gt;
&lt;bean id="jdbcConfiguration" class="org.springframework.beans.factory.config.PropertiesFactoryBean"&gt;
    &lt;property name="location" value="classpath:com/foo/jdbc-production.properties"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration uses a Spring <code>FactoryBean</code> implementation (the
<code>PropertiesFactoryBean</code>) to instantiate a <code>java.util.Properties</code> instance with values
loaded from the supplied <a href="#resources"><code>Resource</code></a> location).</p>
</div>
<div class="paragraph">
<p>The following example uses a <code>util:properties</code> element to make a more concise representation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- creates a java.util.Properties instance with values loaded from the supplied location --&gt;
&lt;util:properties id="jdbcConfiguration" location="classpath:com/foo/jdbc-production.properties"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-util-list"><a class="anchor" href="#xsd-schemas-util-list"></a>Using <code>&lt;util:list/&gt;</code></h5>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- creates a java.util.List instance with values loaded from the supplied 'sourceList' --&gt;
&lt;bean id="emails" class="org.springframework.beans.factory.config.ListFactoryBean"&gt;
    &lt;property name="sourceList"&gt;
        &lt;list&gt;
            &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="730316101b1c011a1d331b16011c5d1c0114">[email&#160;protected]</a>&lt;/value&gt;
            &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0b796a78606467656260647d4b78677e66782564796c">[email&#160;protected]</a>&lt;/value&gt;
            &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="3142455047435e56585f71565e471f5e4356">[email&#160;protected]</a>&lt;/value&gt;
            &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d0a0bfa2b6b9a2a990b7bfa6febfa2b7">[email&#160;protected]</a>&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration uses a Spring <code>FactoryBean</code> implementation (the
<code>ListFactoryBean</code>) to create a <code>java.util.List</code> instance and initialize it with values taken
from the supplied <code>sourceList</code>.</p>
</div>
<div class="paragraph">
<p>The following example uses a <code>&lt;util:list/&gt;</code> element to make a more concise representation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- creates a java.util.List instance with the supplied values --&gt;
&lt;util:list id="emails"&gt;
    &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="8afaefe9e2e5f8e3e4cae2eff8e5a4e5f8ed">[email&#160;protected]</a>&lt;/value&gt;
    &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="354754465e5a595b5c5e5a437546594058461b5a4752">[email&#160;protected]</a>&lt;/value&gt;
    &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="cab9beabbcb8a5ada3a48aada5bce4a5b8ad">[email&#160;protected]</a>&lt;/value&gt;
    &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e2928d90848b909ba2858d94cc8d9085">[email&#160;protected]</a>&lt;/value&gt;
&lt;/util:list&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also explicitly control the exact type of <code>List</code> that is instantiated and
populated by using the <code>list-class</code> attribute on the <code>&lt;util:list/&gt;</code> element. For
example, if we really need a <code>java.util.LinkedList</code> to be instantiated, we could use the
following configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;util:list id="emails" list-class="java.util.LinkedList"&gt;
    &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1973787a726a71787f6d767c596f787e787b76777d37766b7e">[email&#160;protected]</a>&lt;/value&gt;
    &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="27424b4e5d4667534f4e494c4e49404a4649544455524a57425309485540">[email&#160;protected]</a>&lt;/value&gt;
    &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="ef998e8187808a84af9f869d8e9b8ac1809d88">[email&#160;protected]</a>&lt;/value&gt;
    &lt;value&gt;d'<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5514273634363d3a3b153b303830263c267b3a2732">[email&#160;protected]</a>&lt;/value&gt;
&lt;/util:list&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If no <code>list-class</code> attribute is supplied, the container chooses a <code>List</code> implementation.</p>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-util-map"><a class="anchor" href="#xsd-schemas-util-map"></a>Using <code>&lt;util:map/&gt;</code></h5>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- creates a java.util.Map instance with values loaded from the supplied 'sourceMap' --&gt;
&lt;bean id="emails" class="org.springframework.beans.factory.config.MapFactoryBean"&gt;
    &lt;property name="sourceMap"&gt;
        &lt;map&gt;
            &lt;entry key="pechorin" value="<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="354550565d5a475c5b755d50475a1b5a4752">[email&#160;protected]</a>"/&gt;
            &lt;entry key="raskolnikov" value="<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="2d5f4c5e464241434446425b6d5e4158405e03425f4a">[email&#160;protected]</a>"/&gt;
            &lt;entry key="stavrogin" value="<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9deee9fcebeff2faf4f3ddfaf2ebb3f2effa">[email&#160;protected]</a>"/&gt;
            &lt;entry key="porfiry" value="<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="21514e534748535861464e570f4e5346">[email&#160;protected]</a>"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration uses a Spring <code>FactoryBean</code> implementation (the
<code>MapFactoryBean</code>) to create a <code>java.util.Map</code> instance initialized with key-value pairs
taken from the supplied <code>'sourceMap'</code>.</p>
</div>
<div class="paragraph">
<p>The following example uses a <code>&lt;util:map/&gt;</code> element to make a more concise representation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- creates a java.util.Map instance with the supplied key-value pairs --&gt;
&lt;util:map id="emails"&gt;
    &lt;entry key="pechorin" value="<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="91e1f4f2f9fee3f8ffd1f9f4e3febffee3f6">[email&#160;protected]</a>"/&gt;
    &lt;entry key="raskolnikov" value="<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="057764766e6a696b6c6e6a734576697068762b6a7762">[email&#160;protected]</a>"/&gt;
    &lt;entry key="stavrogin" value="<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="790a0d180f0b161e1017391e160f57160b1e">[email&#160;protected]</a>"/&gt;
    &lt;entry key="porfiry" value="<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f3839c81959a818ab3949c85dd9c8194">[email&#160;protected]</a>"/&gt;
&lt;/util:map&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also explicitly control the exact type of <code>Map</code> that is instantiated and
populated by using the <code>'map-class'</code> attribute on the <code>&lt;util:map/&gt;</code> element. For
example, if we really need a <code>java.util.TreeMap</code> to be instantiated, we could use the
following configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;util:map id="emails" map-class="java.util.TreeMap"&gt;
    &lt;entry key="pechorin" value="<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="5c2c393f34332e35321c34392e3372332e3b">[email&#160;protected]</a>"/&gt;
    &lt;entry key="raskolnikov" value="<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="493b283a222625272022263f093a253c243a67263b2e">[email&#160;protected]</a>"/&gt;
    &lt;entry key="stavrogin" value="<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="91e2e5f0e7e3fef6f8ffd1f6fee7bffee3f6">[email&#160;protected]</a>"/&gt;
    &lt;entry key="porfiry" value="<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c3b3acb1a5aab1ba83a4acb5edacb1a4">[email&#160;protected]</a>"/&gt;
&lt;/util:map&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If no <code>'map-class'</code> attribute is supplied, the container chooses a <code>Map</code> implementation.</p>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-util-set"><a class="anchor" href="#xsd-schemas-util-set"></a>Using <code>&lt;util:set/&gt;</code></h5>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- creates a java.util.Set instance with values loaded from the supplied 'sourceSet' --&gt;
&lt;bean id="emails" class="org.springframework.beans.factory.config.SetFactoryBean"&gt;
    &lt;property name="sourceSet"&gt;
        &lt;set&gt;
            &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="cdbda8aea5a2bfa4a38da5a8bfa2e3a2bfaa">[email&#160;protected]</a>&lt;/value&gt;
            &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="562437253d393a383f3d392016253a233b2578392431">[email&#160;protected]</a>&lt;/value&gt;
            &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7201061304001d151b1c32151d045c1d0015">[email&#160;protected]</a>&lt;/value&gt;
            &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="4939263b2f203b30092e263f67263b2e">[email&#160;protected]</a>&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration uses a Spring <code>FactoryBean</code> implementation (the
<code>SetFactoryBean</code>) to create a <code>java.util.Set</code> instance initialized with values taken
from the supplied <code>sourceSet</code>.</p>
</div>
<div class="paragraph">
<p>The following example uses a <code>&lt;util:set/&gt;</code> element to make a more concise representation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- creates a java.util.Set instance with the supplied values --&gt;
&lt;util:set id="emails"&gt;
    &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="28584d4b40475a414668404d5a4706475a4f">[email&#160;protected]</a>&lt;/value&gt;
    &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="e69487958d898a888f8d8990a6958a938b95c8899481">[email&#160;protected]</a>&lt;/value&gt;
    &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="93e0e7f2e5e1fcf4fafdd3f4fce5bdfce1f4">[email&#160;protected]</a>&lt;/value&gt;
    &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9bebf4e9fdf2e9e2dbfcf4edb5f4e9fc">[email&#160;protected]</a>&lt;/value&gt;
&lt;/util:set&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also explicitly control the exact type of <code>Set</code> that is instantiated and
populated by using the <code>set-class</code> attribute on the <code>&lt;util:set/&gt;</code> element. For
example, if we really need a <code>java.util.TreeSet</code> to be instantiated, we could use the
following configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;util:set id="emails" set-class="java.util.TreeSet"&gt;
    &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="f1819492999e83989fb19994839edf9e8396">[email&#160;protected]</a>&lt;/value&gt;
    &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c5b7a4b6aeaaa9abacaeaab385b6a9b0a8b6ebaab7a2">[email&#160;protected]</a>&lt;/value&gt;
    &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="6c1f180d1a1e030b05022c0b031a42031e0b">[email&#160;protected]</a>&lt;/value&gt;
    &lt;value&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7b0b14091d1209023b1c140d5514091c">[email&#160;protected]</a>&lt;/value&gt;
&lt;/util:set&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If no <code>set-class</code> attribute is supplied, the container chooses a <code>Set</code> implementation.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-aop"><a class="anchor" href="#xsd-schemas-aop"></a>10.1.2. The <code>aop</code> Schema</h4>
<div class="paragraph">
<p>The <code>aop</code> tags deal with configuring all things AOP in Spring, including Spring&#8217;s
own proxy-based AOP framework and Spring&#8217;s integration with the AspectJ AOP framework.
These tags are comprehensively covered in the chapter entitled <a href="#aop">Aspect Oriented Programming with Spring</a>.</p>
</div>
<div class="paragraph">
<p>In the interest of completeness, to use the tags in the <code>aop</code> schema, you need to have
the following preamble at the top of your Spring XML configuration file (the text in the
snippet references the correct schema so that the tags in the <code>aop</code> namespace
are available to you):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd"&gt;

    &lt;!-- bean definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-context"><a class="anchor" href="#xsd-schemas-context"></a>10.1.3. The <code>context</code> Schema</h4>
<div class="paragraph">
<p>The <code>context</code> tags deal with <code>ApplicationContext</code> configuration that relates to plumbing&#8201;&#8212;&#8201;that is, not usually beans that are important to an end-user but rather beans that do
a lot of the &#8220;grunt&#8221; work in Spring, such as <code>BeanfactoryPostProcessors</code>. The following
snippet references the correct schema so that the elements in the <code>context</code> namespace are
available to you:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"&gt;

    &lt;!-- bean definitions here --&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-context-pphc"><a class="anchor" href="#xsd-schemas-context-pphc"></a>Using <code>&lt;property-placeholder/&gt;</code></h5>
<div class="paragraph">
<p>This element activates the replacement of <code>${&#8230;&#8203;}</code> placeholders, which are resolved against a
specified properties file (as a <a href="#resources">Spring resource location</a>). This element
is a convenience mechanism that sets up a <a href="#beans-factory-placeholderconfigurer"><code>PropertySourcesPlaceholderConfigurer</code></a> for you. If you need more control over the specific
<code>PropertySourcesPlaceholderConfigurer</code> setup, you can explicitly define it as a bean yourself.</p>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-context-ac"><a class="anchor" href="#xsd-schemas-context-ac"></a>Using <code>&lt;annotation-config/&gt;</code></h5>
<div class="paragraph">
<p>This element activates the Spring infrastructure to detect annotations in bean classes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring&#8217;s <a href="#beans-factory-metadata"><code>@Configuration</code></a> model</p>
</li>
<li>
<p><a href="#beans-annotation-config"><code>@Autowired</code>/<code>@Inject</code></a>, <code>@Value</code>, and <code>@Lookup</code></p>
</li>
<li>
<p>JSR-250&#8217;s <code>@Resource</code>, <code>@PostConstruct</code>, and <code>@PreDestroy</code> (if available)</p>
</li>
<li>
<p>JAX-WS&#8217;s <code>@WebServiceRef</code> and EJB 3&#8217;s <code>@EJB</code> (if available)</p>
</li>
<li>
<p>JPA&#8217;s <code>@PersistenceContext</code> and <code>@PersistenceUnit</code> (if available)</p>
</li>
<li>
<p>Spring&#8217;s <a href="#context-functionality-events-annotation"><code>@EventListener</code></a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Alternatively, you can choose to explicitly activate the individual <code>BeanPostProcessors</code>
for those annotations.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This element does not activate processing of Spring&#8217;s
<a href="data-access.html#transaction-declarative-annotations"><code>@Transactional</code></a> annotation;
you can use the <a href="data-access.html#tx-decl-explained"><code>&lt;tx:annotation-driven/&gt;</code></a>
element for that purpose. Similarly, Spring&#8217;s
<a href="integration.html#cache-annotations">caching annotations</a> need to be explicitly
<a href="integration.html#cache-annotation-enable">enabled</a> as well.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-context-component-scan"><a class="anchor" href="#xsd-schemas-context-component-scan"></a>Using <code>&lt;component-scan/&gt;</code></h5>
<div class="paragraph">
<p>This element is detailed in the section on <a href="#beans-annotation-config">annotation-based container configuration</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-context-ltw"><a class="anchor" href="#xsd-schemas-context-ltw"></a>Using <code>&lt;load-time-weaver/&gt;</code></h5>
<div class="paragraph">
<p>This element is detailed in the section on <a href="#aop-aj-ltw">load-time weaving with AspectJ in the Spring Framework</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-context-sc"><a class="anchor" href="#xsd-schemas-context-sc"></a>Using <code>&lt;spring-configured/&gt;</code></h5>
<div class="paragraph">
<p>This element is detailed in the section on <a href="#aop-atconfigurable">using AspectJ to dependency inject domain objects with Spring</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="xsd-schemas-context-mbe"><a class="anchor" href="#xsd-schemas-context-mbe"></a>Using <code>&lt;mbean-export/&gt;</code></h5>
<div class="paragraph">
<p>This element is detailed in the section on <a href="integration.html#jmx-context-mbeanexport">configuring annotation-based MBean export</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xsd-schemas-beans"><a class="anchor" href="#xsd-schemas-beans"></a>10.1.4. The Beans Schema</h4>
<div class="paragraph">
<p>Last but not least, we have the elements in the <code>beans</code> schema. These elements
have been in Spring since the very dawn of the framework. Examples of the various elements
in the <code>beans</code> schema are not shown here because they are quite comprehensively covered
in <a href="#beans-factory-properties-detailed">dependencies and configuration in detail</a>
(and, indeed, in that entire <a href="#beans">chapter</a>).</p>
</div>
<div class="paragraph">
<p>Note that you can add zero or more key-value pairs to <code>&lt;bean/&gt;</code> XML definitions.
What, if anything, is done with this extra metadata is totally up to your own custom
logic (and so is typically only of use if you write your own custom elements as described
in the appendix entitled <a href="#xml-custom">XML Schema Authoring</a>).</p>
</div>
<div class="paragraph">
<p>The following example shows the <code>&lt;meta/&gt;</code> element in the context of a surrounding <code>&lt;bean/&gt;</code>
(note that, without any logic to interpret it, the metadata is effectively useless
as it stands).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean id="foo" class="x.y.Foo"&gt;
        &lt;meta key="cacheName" value="foo"/&gt; <i class="conum" data-value="1"></i><b>(1)</b>
        &lt;property name="name" value="Rick"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is the example <code>meta</code> element</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the case of the preceding example, you could assume that there is some logic that consumes
the bean definition and sets up some caching infrastructure that uses the supplied metadata.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="xml-custom"><a class="anchor" href="#xml-custom"></a>10.2. XML Schema Authoring</h3>
<div id="xsd-custom-introduction" class="paragraph">
<p>Since version 2.0, Spring has featured a mechanism for adding schema-based extensions to the
basic Spring XML format for defining and configuring beans. This section covers
how to write your own custom XML bean definition parsers and
integrate such parsers into the Spring IoC container.</p>
</div>
<div class="paragraph">
<p>To facilitate authoring configuration files that use a schema-aware XML editor,
Spring&#8217;s extensible XML configuration mechanism is based on XML Schema. If you are not
familiar with Spring&#8217;s current XML configuration extensions that come with the standard
Spring distribution, you should first read the previous section on <a href="#xsd-schemas">XML Schemas</a>.</p>
</div>
<div class="paragraph">
<p>To create new XML configuration extensions:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#xsd-custom-schema">Author</a> an XML schema to describe your custom element(s).</p>
</li>
<li>
<p><a href="#xsd-custom-namespacehandler">Code</a> a custom <code>NamespaceHandler</code> implementation.</p>
</li>
<li>
<p><a href="#xsd-custom-parser">Code</a> one or more <code>BeanDefinitionParser</code> implementations
(this is where the real work is done).</p>
</li>
<li>
<p><a href="#xsd-custom-registration">Register</a> your new artifacts with Spring.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For a unified example, we create an
XML extension (a custom XML element) that lets us configure objects of the type
<code>SimpleDateFormat</code> (from the <code>java.text</code> package). When we are done,
we will be able to define bean definitions of type <code>SimpleDateFormat</code> as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;myns:dateformat id="dateFormat"
    pattern="yyyy-MM-dd HH:mm"
    lenient="true"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>(We include much more detailed
examples follow later in this appendix. The intent of this first simple example is to walk you
through the basic steps of making a custom extension.)</p>
</div>
<div class="sect3">
<h4 id="xsd-custom-schema"><a class="anchor" href="#xsd-custom-schema"></a>10.2.1. Authoring the Schema</h4>
<div class="paragraph">
<p>Creating an XML configuration extension for use with Spring&#8217;s IoC container starts with
authoring an XML Schema to describe the extension. For our example, we use the following schema
to configure <code>SimpleDateFormat</code> objects:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;!-- myns.xsd (inside package org/springframework/samples/xml) --&gt;

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsd:schema xmlns="http://www.mycompany.example/schema/myns"
        xmlns:xsd="http://www.w3.org/2001/XMLSchema"
        xmlns:beans="http://www.springframework.org/schema/beans"
        targetNamespace="http://www.mycompany.example/schema/myns"
        elementFormDefault="qualified"
        attributeFormDefault="unqualified"&gt;

    &lt;xsd:import namespace="http://www.springframework.org/schema/beans"/&gt;

    &lt;xsd:element name="dateformat"&gt;
        &lt;xsd:complexType&gt;
            &lt;xsd:complexContent&gt;
                &lt;xsd:extension base="beans:identifiedType"&gt; <i class="conum" data-value="1"></i><b>(1)</b>
                    &lt;xsd:attribute name="lenient" type="xsd:boolean"/&gt;
                    &lt;xsd:attribute name="pattern" type="xsd:string" use="required"/&gt;
                &lt;/xsd:extension&gt;
            &lt;/xsd:complexContent&gt;
        &lt;/xsd:complexType&gt;
    &lt;/xsd:element&gt;
&lt;/xsd:schema&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The indicated line contains an extension base for all identifiable tags
(meaning they have an <code>id</code> attribute that we can use as the bean identifier in the
container). We can use this attribute because we imported the Spring-provided
<code>beans</code> namespace.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The preceding schema lets us configure <code>SimpleDateFormat</code> objects directly in an
XML application context file by using the <code>&lt;myns:dateformat/&gt;</code> element, as the following
example shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;myns:dateformat id="dateFormat"
    pattern="yyyy-MM-dd HH:mm"
    lenient="true"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that, after we have created the infrastructure classes, the preceding snippet of XML is
essentially the same as the following XML snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="dateFormat" class="java.text.SimpleDateFormat"&gt;
    &lt;constructor-arg value="yyyy-HH-dd HH:mm"/&gt;
    &lt;property name="lenient" value="true"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second of the two preceding snippets
creates a bean in the container (identified by the name <code>dateFormat</code> of type
<code>SimpleDateFormat</code>) with a couple of properties set.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The schema-based approach to creating configuration format allows for tight integration
with an IDE that has a schema-aware XML editor. By using a properly authored schema, you
can use autocompletion to let a user choose between several configuration options
defined in the enumeration.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="xsd-custom-namespacehandler"><a class="anchor" href="#xsd-custom-namespacehandler"></a>10.2.2. Coding a <code>NamespaceHandler</code></h4>
<div class="paragraph">
<p>In addition to the schema, we need a <code>NamespaceHandler</code> to parse all elements of
this specific namespace that Spring encounters while parsing configuration files. For this example, the
<code>NamespaceHandler</code> should take care of the parsing of the <code>myns:dateformat</code>
element.</p>
</div>
<div class="paragraph">
<p>The <code>NamespaceHandler</code> interface features three methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>init()</code>: Allows for initialization of the <code>NamespaceHandler</code> and is called by
Spring before the handler is used.</p>
</li>
<li>
<p><code>BeanDefinition parse(Element, ParserContext)</code>: Called when Spring encounters a
top-level element (not nested inside a bean definition or a different namespace).
This method can itself register bean definitions, return a bean definition, or both.</p>
</li>
<li>
<p><code>BeanDefinitionHolder decorate(Node, BeanDefinitionHolder, ParserContext)</code>: Called
when Spring encounters an attribute or nested element of a different namespace.
The decoration of one or more bean definitions is used (for example) with the
<a href="#beans-factory-scopes">scopes that Spring supports</a>.
We start by highlighting a simple example, without using decoration, after which
we show decoration in a somewhat more advanced example.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Although you can code your own <code>NamespaceHandler</code> for the entire
namespace (and hence provide code that parses each and every element in the namespace),
it is often the case that each top-level XML element in a Spring XML configuration file
results in a single bean definition (as in our case, where a single <code>&lt;myns:dateformat/&gt;</code>
element results in a single <code>SimpleDateFormat</code> bean definition). Spring features a
number of convenience classes that support this scenario. In the following example, we
use the <code>NamespaceHandlerSupport</code> class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package org.springframework.samples.xml;

import org.springframework.beans.factory.xml.NamespaceHandlerSupport;

public class MyNamespaceHandler extends NamespaceHandlerSupport {

    public void init() {
        registerBeanDefinitionParser("dateformat", new SimpleDateFormatBeanDefinitionParser());
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package org.springframework.samples.xml

import org.springframework.beans.factory.xml.NamespaceHandlerSupport

class MyNamespaceHandler : NamespaceHandlerSupport {

    override fun init() {
        registerBeanDefinitionParser("dateformat", SimpleDateFormatBeanDefinitionParser())
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You may notice that there is not actually a whole lot of parsing logic
in this class. Indeed, the <code>NamespaceHandlerSupport</code> class has a built-in notion of
delegation. It supports the registration of any number of <code>BeanDefinitionParser</code>
instances, to which it delegates to when it needs to parse an element in its
namespace. This clean separation of concerns lets a <code>NamespaceHandler</code> handle the
orchestration of the parsing of all of the custom elements in its namespace while
delegating to <code>BeanDefinitionParsers</code> to do the grunt work of the XML parsing. This
means that each <code>BeanDefinitionParser</code> contains only the logic for parsing a single
custom element, as we can see in the next step.</p>
</div>
</div>
<div class="sect3">
<h4 id="xsd-custom-parser"><a class="anchor" href="#xsd-custom-parser"></a>10.2.3. Using <code>BeanDefinitionParser</code></h4>
<div class="paragraph">
<p>A <code>BeanDefinitionParser</code> is used if the <code>NamespaceHandler</code> encounters an XML
element of the type that has been mapped to the specific bean definition parser
(<code>dateformat</code> in this case). In other words, the <code>BeanDefinitionParser</code> is
responsible for parsing one distinct top-level XML element defined in the schema. In
the parser, we' have access to the XML element (and thus to its subelements, too) so that
we can parse our custom XML content, as you can see in the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package org.springframework.samples.xml;

import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;
import org.springframework.util.StringUtils;
import org.w3c.dom.Element;

import java.text.SimpleDateFormat;

public class SimpleDateFormatBeanDefinitionParser extends AbstractSingleBeanDefinitionParser { <i class="conum" data-value="1"></i><b>(1)</b>

    protected Class getBeanClass(Element element) {
        return SimpleDateFormat.class; <i class="conum" data-value="2"></i><b>(2)</b>
    }

    protected void doParse(Element element, BeanDefinitionBuilder bean) {
        // this will never be null since the schema explicitly requires that a value be supplied
        String pattern = element.getAttribute("pattern");
        bean.addConstructorArgValue(pattern);

        // this however is an optional property
        String lenient = element.getAttribute("lenient");
        if (StringUtils.hasText(lenient)) {
            bean.addPropertyValue("lenient", Boolean.valueOf(lenient));
        }
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We use the Spring-provided <code>AbstractSingleBeanDefinitionParser</code> to handle a lot of
the basic grunt work of creating a single <code>BeanDefinition</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We supply the <code>AbstractSingleBeanDefinitionParser</code> superclass with the type that our
single <code>BeanDefinition</code> represents.</td>
</tr>
</table>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package org.springframework.samples.xml

import org.springframework.beans.factory.support.BeanDefinitionBuilder
import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser
import org.springframework.util.StringUtils
import org.w3c.dom.Element

import java.text.SimpleDateFormat

class SimpleDateFormatBeanDefinitionParser : AbstractSingleBeanDefinitionParser() { <i class="conum" data-value="1"></i><b>(1)</b>

    override fun getBeanClass(element: Element): Class&lt;*&gt;? { <i class="conum" data-value="2"></i><b>(2)</b>
        return SimpleDateFormat::class.java
    }

    override fun doParse(element: Element, bean: BeanDefinitionBuilder) {
        // this will never be null since the schema explicitly requires that a value be supplied
        val pattern = element.getAttribute("pattern")
        bean.addConstructorArgValue(pattern)

        // this however is an optional property
        val lenient = element.getAttribute("lenient")
        if (StringUtils.hasText(lenient)) {
            bean.addPropertyValue("lenient", java.lang.Boolean.valueOf(lenient))
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We use the Spring-provided <code>AbstractSingleBeanDefinitionParser</code> to handle a lot of
the basic grunt work of creating a single <code>BeanDefinition</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>We supply the <code>AbstractSingleBeanDefinitionParser</code> superclass with the type that our
single <code>BeanDefinition</code> represents.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In this simple case, this is all that we need to do. The creation of our single
<code>BeanDefinition</code> is handled by the <code>AbstractSingleBeanDefinitionParser</code> superclass, as
is the extraction and setting of the bean definition&#8217;s unique identifier.</p>
</div>
</div>
<div class="sect3">
<h4 id="xsd-custom-registration"><a class="anchor" href="#xsd-custom-registration"></a>10.2.4. Registering the Handler and the Schema</h4>
<div class="paragraph">
<p>The coding is finished. All that remains to be done is to make the Spring XML
parsing infrastructure aware of our custom element. We do so by registering our custom
<code>namespaceHandler</code> and custom XSD file in two special-purpose properties files. These
properties files are both placed in a <code>META-INF</code> directory in your application and
can, for example, be distributed alongside your binary classes in a JAR file. The Spring
XML parsing infrastructure automatically picks up your new extension by consuming
these special properties files, the formats of which are detailed in the next two sections.</p>
</div>
<div class="sect4">
<h5 id="xsd-custom-registration-spring-handlers"><a class="anchor" href="#xsd-custom-registration-spring-handlers"></a>Writing <code>META-INF/spring.handlers</code></h5>
<div class="paragraph">
<p>The properties file called <code>spring.handlers</code> contains a mapping of XML Schema URIs to
namespace handler classes. For our example, we need to write the following:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>http\://www.mycompany.example/schema/myns=org.springframework.samples.xml.MyNamespaceHandler</pre>
</div>
</div>
<div class="paragraph">
<p>(The <code>:</code> character is a valid delimiter in the Java properties format, so
<code>:</code> character in the URI needs to be escaped with a backslash.)</p>
</div>
<div class="paragraph">
<p>The first part (the key) of the key-value pair is the URI associated with your custom
namespace extension and needs to exactly match exactly the value of the <code>targetNamespace</code>
attribute, as specified in your custom XSD schema.</p>
</div>
</div>
<div class="sect4">
<h5 id="xsd-custom-registration-spring-schemas"><a class="anchor" href="#xsd-custom-registration-spring-schemas"></a>Writing 'META-INF/spring.schemas'</h5>
<div class="paragraph">
<p>The properties file called <code>spring.schemas</code> contains a mapping of XML Schema locations
(referred to, along with the schema declaration, in XML files that use the schema as part
of the <code>xsi:schemaLocation</code> attribute) to classpath resources. This file is needed
to prevent Spring from absolutely having to use a default <code>EntityResolver</code> that requires
Internet access to retrieve the schema file. If you specify the mapping in this
properties file, Spring searches for the schema (in this case,
<code>myns.xsd</code> in the <code>org.springframework.samples.xml</code> package) on the classpath.
The following snippet shows the line we need to add for our custom schema:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>http\://www.mycompany.example/schema/myns/myns.xsd=org/springframework/samples/xml/myns.xsd</pre>
</div>
</div>
<div class="paragraph">
<p>(Remember that the <code>:</code> character must be escaped.)</p>
</div>
<div class="paragraph">
<p>You are encouraged to deploy your XSD file (or files) right alongside
the <code>NamespaceHandler</code> and <code>BeanDefinitionParser</code> classes on the classpath.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xsd-custom-using"><a class="anchor" href="#xsd-custom-using"></a>10.2.5. Using a Custom Extension in Your Spring XML Configuration</h4>
<div class="paragraph">
<p>Using a custom extension that you yourself have implemented is no different from using
one of the &#8220;custom&#8221; extensions that Spring provides. The following
example uses the custom <code>&lt;dateformat/&gt;</code> element developed in the previous steps
in a Spring XML configuration file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:myns="http://www.mycompany.example/schema/myns"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.mycompany.example/schema/myns http://www.mycompany.com/schema/myns/myns.xsd"&gt;

    &lt;!-- as a top-level bean --&gt;
    &lt;myns:dateformat id="defaultDateFormat" pattern="yyyy-MM-dd HH:mm" lenient="true"/&gt; <i class="conum" data-value="1"></i><b>(1)</b>

    &lt;bean id="jobDetailTemplate" abstract="true"&gt;
        &lt;property name="dateFormat"&gt;
            &lt;!-- as an inner bean --&gt;
            &lt;myns:dateformat pattern="HH:mm MM-dd-yyyy"/&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Our custom bean.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="xsd-custom-meat"><a class="anchor" href="#xsd-custom-meat"></a>10.2.6. More Detailed Examples</h4>
<div class="paragraph">
<p>This section presents some more detailed examples of custom XML extensions.</p>
</div>
<div class="sect4">
<h5 id="xsd-custom-custom-nested"><a class="anchor" href="#xsd-custom-custom-nested"></a>Nesting Custom Elements within Custom Elements</h5>
<div class="paragraph">
<p>The example presented in this section shows how you to write the various artifacts required
to satisfy a target of the following configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:foo="http://www.foo.example/schema/component"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.foo.example/schema/component http://www.foo.example/schema/component/component.xsd"&gt;

    &lt;foo:component id="bionic-family" name="Bionic-1"&gt;
        &lt;foo:component name="Mother-1"&gt;
            &lt;foo:component name="Karate-1"/&gt;
            &lt;foo:component name="Sport-1"/&gt;
        &lt;/foo:component&gt;
        &lt;foo:component name="Rock-1"/&gt;
    &lt;/foo:component&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The preceding configuration nests custom extensions within each other. The class
that is actually configured by the <code>&lt;foo:component/&gt;</code> element is the <code>Component</code>
class (shown in the next example). Notice how the <code>Component</code> class does not expose a
setter method for the <code>components</code> property. This makes it hard (or rather impossible)
to configure a bean definition for the <code>Component</code> class by using setter injection.
The following listing shows the <code>Component</code> class:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package com.foo;

import java.util.ArrayList;
import java.util.List;

public class Component {

    private String name;
    private List&lt;Component&gt; components = new ArrayList&lt;Component&gt; ();

    // mmm, there is no setter method for the 'components'
    public void addComponent(Component component) {
        this.components.add(component);
    }

    public List&lt;Component&gt; getComponents() {
        return components;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package com.foo

import java.util.ArrayList

class Component {

    var name: String? = null
    private val components = ArrayList&lt;Component&gt;()

    // mmm, there is no setter method for the 'components'
    fun addComponent(component: Component) {
        this.components.add(component)
    }

    fun getComponents(): List&lt;Component&gt; {
        return components
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The typical solution to this issue is to create a custom <code>FactoryBean</code> that exposes a
setter property for the <code>components</code> property. The following listing shows such a custom
<code>FactoryBean</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package com.foo;

import org.springframework.beans.factory.FactoryBean;

import java.util.List;

public class ComponentFactoryBean implements FactoryBean&lt;Component&gt; {

    private Component parent;
    private List&lt;Component&gt; children;

    public void setParent(Component parent) {
        this.parent = parent;
    }

    public void setChildren(List&lt;Component&gt; children) {
        this.children = children;
    }

    public Component getObject() throws Exception {
        if (this.children != null &amp;&amp; this.children.size() &gt; 0) {
            for (Component child : children) {
                this.parent.addComponent(child);
            }
        }
        return this.parent;
    }

    public Class&lt;Component&gt; getObjectType() {
        return Component.class;
    }

    public boolean isSingleton() {
        return true;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package com.foo

import org.springframework.beans.factory.FactoryBean
import org.springframework.stereotype.Component

class ComponentFactoryBean : FactoryBean&lt;Component&gt; {

    private var parent: Component? = null
    private var children: List&lt;Component&gt;? = null

    fun setParent(parent: Component) {
        this.parent = parent
    }

    fun setChildren(children: List&lt;Component&gt;) {
        this.children = children
    }

    override fun getObject(): Component? {
        if (this.children != null &amp;&amp; this.children!!.isNotEmpty()) {
            for (child in children!!) {
                this.parent!!.addComponent(child)
            }
        }
        return this.parent
    }

    override fun getObjectType(): Class&lt;Component&gt;? {
        return Component::class.java
    }

    override fun isSingleton(): Boolean {
        return true
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This works nicely, but it exposes a lot of Spring plumbing to the end user. What we are
going to do is write a custom extension that hides away all of this Spring plumbing.
If we stick to <a href="#xsd-custom-introduction">the steps described previously</a>, we start off
by creating the XSD schema to define the structure of our custom tag, as the following
listing shows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;

&lt;xsd:schema xmlns="http://www.foo.example/schema/component"
        xmlns:xsd="http://www.w3.org/2001/XMLSchema"
        targetNamespace="http://www.foo.example/schema/component"
        elementFormDefault="qualified"
        attributeFormDefault="unqualified"&gt;

    &lt;xsd:element name="component"&gt;
        &lt;xsd:complexType&gt;
            &lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt;
                &lt;xsd:element ref="component"/&gt;
            &lt;/xsd:choice&gt;
            &lt;xsd:attribute name="id" type="xsd:ID"/&gt;
            &lt;xsd:attribute name="name" use="required" type="xsd:string"/&gt;
        &lt;/xsd:complexType&gt;
    &lt;/xsd:element&gt;

&lt;/xsd:schema&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Again following <a href="#xsd-custom-introduction">the process described earlier</a>,
we then create a custom <code>NamespaceHandler</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package com.foo;

import org.springframework.beans.factory.xml.NamespaceHandlerSupport;

public class ComponentNamespaceHandler extends NamespaceHandlerSupport {

    public void init() {
        registerBeanDefinitionParser("component", new ComponentBeanDefinitionParser());
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package com.foo

import org.springframework.beans.factory.xml.NamespaceHandlerSupport

class ComponentNamespaceHandler : NamespaceHandlerSupport() {

    override fun init() {
        registerBeanDefinitionParser("component", ComponentBeanDefinitionParser())
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next up is the custom <code>BeanDefinitionParser</code>. Remember that we are creating
a <code>BeanDefinition</code> that describes a <code>ComponentFactoryBean</code>. The following
listing shows our custom <code>BeanDefinitionParser</code> implementation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package com.foo;

import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.ManagedList;
import org.springframework.beans.factory.xml.AbstractBeanDefinitionParser;
import org.springframework.beans.factory.xml.ParserContext;
import org.springframework.util.xml.DomUtils;
import org.w3c.dom.Element;

import java.util.List;

public class ComponentBeanDefinitionParser extends AbstractBeanDefinitionParser {

    protected AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext) {
        return parseComponentElement(element);
    }

    private static AbstractBeanDefinition parseComponentElement(Element element) {
        BeanDefinitionBuilder factory = BeanDefinitionBuilder.rootBeanDefinition(ComponentFactoryBean.class);
        factory.addPropertyValue("parent", parseComponent(element));

        List&lt;Element&gt; childElements = DomUtils.getChildElementsByTagName(element, "component");
        if (childElements != null &amp;&amp; childElements.size() &gt; 0) {
            parseChildComponents(childElements, factory);
        }

        return factory.getBeanDefinition();
    }

    private static BeanDefinition parseComponent(Element element) {
        BeanDefinitionBuilder component = BeanDefinitionBuilder.rootBeanDefinition(Component.class);
        component.addPropertyValue("name", element.getAttribute("name"));
        return component.getBeanDefinition();
    }

    private static void parseChildComponents(List&lt;Element&gt; childElements, BeanDefinitionBuilder factory) {
        ManagedList&lt;BeanDefinition&gt; children = new ManagedList&lt;BeanDefinition&gt;(childElements.size());
        for (Element element : childElements) {
            children.add(parseComponentElement(element));
        }
        factory.addPropertyValue("children", children);
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package com.foo

import org.springframework.beans.factory.config.BeanDefinition
import org.springframework.beans.factory.support.AbstractBeanDefinition
import org.springframework.beans.factory.support.BeanDefinitionBuilder
import org.springframework.beans.factory.support.ManagedList
import org.springframework.beans.factory.xml.AbstractBeanDefinitionParser
import org.springframework.beans.factory.xml.ParserContext
import org.springframework.util.xml.DomUtils
import org.w3c.dom.Element

import java.util.List

class ComponentBeanDefinitionParser : AbstractBeanDefinitionParser() {

    override fun parseInternal(element: Element, parserContext: ParserContext): AbstractBeanDefinition? {
        return parseComponentElement(element)
    }

    private fun parseComponentElement(element: Element): AbstractBeanDefinition {
        val factory = BeanDefinitionBuilder.rootBeanDefinition(ComponentFactoryBean::class.java)
        factory.addPropertyValue("parent", parseComponent(element))

        val childElements = DomUtils.getChildElementsByTagName(element, "component")
        if (childElements != null &amp;&amp; childElements.size &gt; 0) {
            parseChildComponents(childElements, factory)
        }

        return factory.getBeanDefinition()
    }

    private fun parseComponent(element: Element): BeanDefinition {
        val component = BeanDefinitionBuilder.rootBeanDefinition(Component::class.java)
        component.addPropertyValue("name", element.getAttribute("name"))
        return component.beanDefinition
    }

    private fun parseChildComponents(childElements: List&lt;Element&gt;, factory: BeanDefinitionBuilder) {
        val children = ManagedList&lt;BeanDefinition&gt;(childElements.size)
        for (element in childElements) {
            children.add(parseComponentElement(element))
        }
        factory.addPropertyValue("children", children)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, the various artifacts need to be registered with the Spring XML infrastructure,
by modifying the <code>META-INF/spring.handlers</code> and <code>META-INF/spring.schemas</code> files, as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># in 'META-INF/spring.handlers'
http\://www.foo.example/schema/component=com.foo.ComponentNamespaceHandler</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># in 'META-INF/spring.schemas'
http\://www.foo.example/schema/component/component.xsd=com/foo/component.xsd</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xsd-custom-custom-just-attributes"><a class="anchor" href="#xsd-custom-custom-just-attributes"></a>Custom Attributes on &#8220;Normal&#8221; Elements</h5>
<div class="paragraph">
<p>Writing your own custom parser and the associated artifacts is not hard. However,
it is sometimes not the right thing to do. Consider a scenario where you need to
add metadata to already existing bean definitions. In this case, you certainly
do not want to have to write your own entire custom extension. Rather, you merely
want to add an additional attribute to the existing bean definition element.</p>
</div>
<div class="paragraph">
<p>By way of another example, suppose that you define a bean definition for a
service object that (unknown to it) accesses a clustered
<a href="https://jcp.org/en/jsr/detail?id=107">JCache</a>, and you want to ensure that the
named JCache instance is eagerly started within the surrounding cluster.
The following listing shows such a definition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;bean id="checkingAccountService" class="com.foo.DefaultCheckingAccountService"
        jcache:cache-name="checking.account"&gt;
    &lt;!-- other dependencies here... --&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can then create another <code>BeanDefinition</code> when the
<code>'jcache:cache-name'</code> attribute is parsed. This <code>BeanDefinition</code> then initializes
the named JCache for us. We can also modify the existing <code>BeanDefinition</code> for the
<code>'checkingAccountService'</code> so that it has a dependency on this new
JCache-initializing <code>BeanDefinition</code>. The following listing shows our <code>JCacheInitializer</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package com.foo;

public class JCacheInitializer {

    private String name;

    public JCacheInitializer(String name) {
        this.name = name;
    }

    public void initialize() {
        // lots of JCache API calls to initialize the named cache...
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package com.foo

class JCacheInitializer(private val name: String) {

    fun initialize() {
        // lots of JCache API calls to initialize the named cache...
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we can move onto the custom extension. First, we need to author
the XSD schema that describes the custom attribute, as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="xml" class="language-xml hljs">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;

&lt;xsd:schema xmlns="http://www.foo.example/schema/jcache"
        xmlns:xsd="http://www.w3.org/2001/XMLSchema"
        targetNamespace="http://www.foo.example/schema/jcache"
        elementFormDefault="qualified"&gt;

    &lt;xsd:attribute name="cache-name" type="xsd:string"/&gt;

&lt;/xsd:schema&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, we need to create the associated <code>NamespaceHandler</code>, as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package com.foo;

import org.springframework.beans.factory.xml.NamespaceHandlerSupport;

public class JCacheNamespaceHandler extends NamespaceHandlerSupport {

    public void init() {
        super.registerBeanDefinitionDecoratorForAttribute("cache-name",
            new JCacheInitializingBeanDefinitionDecorator());
    }

}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package com.foo

import org.springframework.beans.factory.xml.NamespaceHandlerSupport

class JCacheNamespaceHandler : NamespaceHandlerSupport() {

    override fun init() {
        super.registerBeanDefinitionDecoratorForAttribute("cache-name",
                JCacheInitializingBeanDefinitionDecorator())
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Next, we need to create the parser. Note that, in this case, because we are going to parse
an XML attribute, we write a <code>BeanDefinitionDecorator</code> rather than a <code>BeanDefinitionParser</code>.
The following listing shows our <code>BeanDefinitionDecorator</code> implementation:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="java" class="language-java hljs">package com.foo;

import org.springframework.beans.factory.config.BeanDefinitionHolder;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.BeanDefinitionDecorator;
import org.springframework.beans.factory.xml.ParserContext;
import org.w3c.dom.Attr;
import org.w3c.dom.Node;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class JCacheInitializingBeanDefinitionDecorator implements BeanDefinitionDecorator {

    private static final String[] EMPTY_STRING_ARRAY = new String[0];

    public BeanDefinitionHolder decorate(Node source, BeanDefinitionHolder holder,
            ParserContext ctx) {
        String initializerBeanName = registerJCacheInitializer(source, ctx);
        createDependencyOnJCacheInitializer(holder, initializerBeanName);
        return holder;
    }

    private void createDependencyOnJCacheInitializer(BeanDefinitionHolder holder,
            String initializerBeanName) {
        AbstractBeanDefinition definition = ((AbstractBeanDefinition) holder.getBeanDefinition());
        String[] dependsOn = definition.getDependsOn();
        if (dependsOn == null) {
            dependsOn = new String[]{initializerBeanName};
        } else {
            List dependencies = new ArrayList(Arrays.asList(dependsOn));
            dependencies.add(initializerBeanName);
            dependsOn = (String[]) dependencies.toArray(EMPTY_STRING_ARRAY);
        }
        definition.setDependsOn(dependsOn);
    }

    private String registerJCacheInitializer(Node source, ParserContext ctx) {
        String cacheName = ((Attr) source).getValue();
        String beanName = cacheName + "-initializer";
        if (!ctx.getRegistry().containsBeanDefinition(beanName)) {
            BeanDefinitionBuilder initializer = BeanDefinitionBuilder.rootBeanDefinition(JCacheInitializer.class);
            initializer.addConstructorArg(cacheName);
            ctx.getRegistry().registerBeanDefinition(beanName, initializer.getBeanDefinition());
        }
        return beanName;
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="kotlin" class="language-kotlin hljs">package com.foo

import org.springframework.beans.factory.config.BeanDefinitionHolder
import org.springframework.beans.factory.support.AbstractBeanDefinition
import org.springframework.beans.factory.support.BeanDefinitionBuilder
import org.springframework.beans.factory.xml.BeanDefinitionDecorator
import org.springframework.beans.factory.xml.ParserContext
import org.w3c.dom.Attr
import org.w3c.dom.Node

import java.util.ArrayList

class JCacheInitializingBeanDefinitionDecorator : BeanDefinitionDecorator {

    override fun decorate(source: Node, holder: BeanDefinitionHolder,
                        ctx: ParserContext): BeanDefinitionHolder {
        val initializerBeanName = registerJCacheInitializer(source, ctx)
        createDependencyOnJCacheInitializer(holder, initializerBeanName)
        return holder
    }

    private fun createDependencyOnJCacheInitializer(holder: BeanDefinitionHolder,
                                                    initializerBeanName: String) {
        val definition = holder.beanDefinition as AbstractBeanDefinition
        var dependsOn = definition.dependsOn
        dependsOn = if (dependsOn == null) {
            arrayOf(initializerBeanName)
        } else {
            val dependencies = ArrayList(listOf(*dependsOn))
            dependencies.add(initializerBeanName)
            dependencies.toTypedArray()
        }
        definition.setDependsOn(*dependsOn)
    }

    private fun registerJCacheInitializer(source: Node, ctx: ParserContext): String {
        val cacheName = (source as Attr).value
        val beanName = "$cacheName-initializer"
        if (!ctx.registry.containsBeanDefinition(beanName)) {
            val initializer = BeanDefinitionBuilder.rootBeanDefinition(JCacheInitializer::class.java)
            initializer.addConstructorArg(cacheName)
            ctx.registry.registerBeanDefinition(beanName, initializer.getBeanDefinition())
        }
        return beanName
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, we need to register the various artifacts with the Spring XML infrastructure
by modifying the <code>META-INF/spring.handlers</code> and <code>META-INF/spring.schemas</code> files, as follows:</p>
</div>
<div class="literalblock">
<div class="content">
<pre># in 'META-INF/spring.handlers'
http\://www.foo.example/schema/jcache=com.foo.JCacheNamespaceHandler</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre># in 'META-INF/spring.schemas'
http\://www.foo.example/schema/jcache/jcache.xsd=com/foo/jcache.xsd</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="application-startup-steps"><a class="anchor" href="#application-startup-steps"></a>10.3. Application Startup Steps</h3>
<div class="paragraph">
<p>This part of the appendix lists the existing <code>StartupSteps</code> that the core container is instrumented with.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
The name and detailed information about each startup step is not part of the public contract and
is subject to change; this is considered as an implementation detail of the core container and will follow
its behavior changes.
</td>
</tr>
</table>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 15. Application startup steps defined in the core container</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Tags</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.beans.instantiate</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Instantiation of a bean and its dependencies.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>beanName</code> the name of the bean, <code>beanType</code> the type required at the injection point.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.beans.smart-initialize</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initialization of <code>SmartInitializingSingleton</code> beans.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>beanName</code> the name of the bean.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.context.annotated-bean-reader.create</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Creation of the <code>AnnotatedBeanDefinitionReader</code>.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.context.base-packages.scan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Scanning of base packages.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>packages</code> array of base packages for scanning.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.context.beans.post-process</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Beans post-processing phase.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.context.bean-factory.post-process</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invocation of the <code>BeanFactoryPostProcessor</code> beans.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>postProcessor</code> the current post-processor.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.context.beandef-registry.post-process</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invocation of the <code>BeanDefinitionRegistryPostProcessor</code> beans.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>postProcessor</code> the current post-processor.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.context.component-classes.register</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Registration of component classes through <code>AnnotationConfigApplicationContext#register</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>classes</code> array of given classes for registration.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.context.config-classes.enhance</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enhancement of configuration classes with CGLIB proxies.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>classCount</code> count of enhanced classes.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.context.config-classes.parse</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Configuration classes parsing phase with the <code>ConfigurationClassPostProcessor</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>classCount</code> count of processed classes.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.context.refresh</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Application context refresh phase.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 5.3.7<br>
Last updated 2021-05-12 05:38:50 UTC
</div>
</div>
<link rel="stylesheet" href="js/highlight/styles/googlecode.min.css">
<script data-cfasync="false" src="js/cdn-cgi/email-decode.min.js"></script><script src="js/highlight/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
<script type="text/javascript" src="js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="js/toc.js"></script>
<script>if (window.parent == window) {(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','js/google-analytics/analytics.js','ga');ga('create', 'UA-2728886-23', 'auto', {'siteSpeedSampleRate': 100});ga('send', 'pageview');}</script></body>
</html>